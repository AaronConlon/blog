{"pageProps":{"post":{"slug":"使用TypeScript+useContext+useReducer管理数据","content":"\n### 前言\n\n在不引入第三方库的情况下，React Context 可以使用内置的`useContext`和`useReducer`两个钩子来创建状态管理模块。\n\n### 代码\n\n首先，在项目根目录下创建`contexts`目录，内部存放所有的`context`，可以根据不同的用途创建不同的目录，内层创建三个文件：\n\n- context.ts 存放核心 context\n- reducer.ts 存放数据变更专用的 reducer\n- types.ts 存放 TypeScript 类型和接口定义\n\n#### context\n\n代码如下：\n\n```tsx\nimport React, { createContext, useContext } from \"react\";\nimport { IState, IRootAction } from \"./types\";\n\n// 定义初始状态值\nexport const initState: IState = {\n  count: 0,\n  profile: {\n    name: \"Aaron\",\n    age: 100,\n  },\n};\n\n// 定义 context，使用 createContext api\nexport const RootContext = createContext<{\n  state: IState;\n  dispatch: React.Dispatch<IRootAction>;\n}>({\n  state: initState,\n  dispatch: () => null,\n});\n\n// 导出 context 的 provider，用于放置 context\nexport const RootContextProvider = RootContext.Provider;\n// 导出 hooks ，便于获取 state 和 dispatch 函数\nexport const useRootContext = () => useContext(RootContext);\n```\n\n#### reducer\n\n代码如下：\n\n```tsx\nimport { IState, IRootAction } from \"./types\";\n\n// 定义 reducer 的参数类型\nexport const rootReducer = (state: IState, action: IRootAction): IState => {\n  const { type, payload } = action;\n  // 根据类型进行处理，返回最终的 state\n  switch (type) {\n    case \"add_count\":\n      return {\n        ...state,\n        count: state.count + (payload as number),\n      };\n    case \"sub_count\":\n      return {\n        ...state,\n        count: state.count - (payload as number),\n      };\n    case \"update_profile\":\n      return {\n        ...state,\n        profile: payload as typeof state.profile,\n      };\n    default:\n      return state;\n  }\n};\n```\n\n#### types\n\n共用的类型值：\n\n```tsx\nexport interface IState {\n  count: number;\n  profile?: {\n    name: string;\n    age: number;\n  };\n}\n\nexport interface IRootAction {\n  type: \"add_count\" | \"sub_count\" | \"update_profile\";\n  payload:\n    | number\n    | {\n        name: string;\n        age: number;\n      };\n}\n```\n\n### 用法和解析\n\n此时，只要在顶层使用 provider 即可：\n\n```tsx\nimport { useReducer } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { BrowserRouter, Route, Routes } from \"react-router-dom\";\n\nimport \"./App.css\";\n\nimport Total from \"routes/total\";\nimport Home from \"routes/home\";\nimport { rootReducer } from \"contexts/root/reducer\";\nimport { initState, RootContextProvider } from \"contexts/root/context\";\n\nfunction App() {\n  const [state, dispatch] = useReducer(rootReducer, initState);\n\n  return (\n    <RootContextProvider value={{ state, dispatch }}>\n      <BrowserRouter>\n        <div className=\"navs\">\n          <Link to={\"/\"}>Home</Link>\n          <Link to={\"/total\"}>Total</Link>\n        </div>\n        <Routes>\n          <Route path={\"/\"} element={<Home />} />\n          <Route path={\"/total\"} element={<Total />} />\n        </Routes>\n      </BrowserRouter>\n    </RootContextProvider>\n  );\n}\n\nexport default App;\n```\n\n关键在于使用 `useReducer`传入`reducer`和默认数据，得到包含`state`和`dispatch`的数组，将二者传给`Provider`的`value`参数即可。\n\n后续组件便可以如此：\n\n```tsx\nimport CountBtn from \"components/CountBtn\";\nimport { useRootContext } from \"../../contexts/root/context\";\nimport Profile from \"./Profile\";\n\nexport default function Total() {\n  const { state } = useRootContext();\n  const { profile } = state;\n\n  return (\n    <div\n      style={{\n        margin: \"2rem\",\n      }}\n    >\n      <p>count is: {state.count}</p>\n      <CountBtn />\n      <p>\n        I am {profile?.name}, {profile?.age} years old.\n      </p>\n      <Profile profile={profile as any} />\n    </div>\n  );\n}\n```\n\n通过`useRootContext`钩子获取到`state`，同时也可以获取到`dispatch`，有需要就可以修改数据了。\n\n### 重复渲染的问题\n\n当组件内使用了`useRootContext`后，`context`内任意数据变化都会引起当前组件重新渲染，举个例子：\n\n当我使用`dispatch`更新了`count`的值，某个使用了`useRootContext`的组件即使没有使用`count`，也会重新渲染。\n\n这个问题，可以有两种类似的方法解决：\n\n- 方案 1：将组件返回的`jsx`封装成新的组件，将组件需要的数据通过`props`传入进去，并且此新组件通过`React.memo`包裹起来并导出，这时候传入的参数不变，则子组件不会重新渲染，这是利用了`React.memo`比较传入的`props`相等时不渲染的原理。\n- 方案 2：将使用了`useRootContext`的组件 return 的`jsx`部分替换成`useMemo(() => 原先的jsx, [deps])`，原先的`jsx`内依赖的数据全部放到依赖数组里，这是利用了`useMemo`缓存`jsx`的原理。\n\n当然还有更好的方案，比如：\n\n- 拆分 Context ，构造一套更精细的数据更新控制机制，例如《[如何避免 useContext 重渲染](https://juejin.cn/post/6869340244954513421)》中提及的思路\n- 使用第三方库，如[Recoil](https://recoiljs.org/zh-hans/)、[concent · power your react](https://concentjs.github.io/concent-site/)\n\n### 总结\n\n没啥好总结的，用`Recoil`或者`concent`吧。\n","title":"使用TypeScript+useContext+useReducer管理数据","date":"2021/12/24","tags":["TypeScript","状态管理"],"mainImg":"https://images.unsplash.com/photo-1607970669494-309137683be5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDAzNjExNjM&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1607970669494-309137683be5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDAzNjExNjM&ixlib=rb-1.2.1&q=80&w=400","intro":"这是一篇学习使用 TypeScript 去写 React Context 的学习心得。"}},"__N_SSG":true}
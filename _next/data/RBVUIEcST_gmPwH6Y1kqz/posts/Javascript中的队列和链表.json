{"pageProps":{"post":{"slug":"Javascript中的队列和链表","content":"\n长话短说,本文将队列和链表的知识合二为一.通过一些示例再次巩固这部分的知识.大概内容分为:\n\n- 简单队列\n- 双端队列\n- 队列应用\n  - 击鼓传花\n  - 回文字检查\n- 单向链表\n- 双向链表\n- 循环链表\n- 排序链表\n\n  \n\n\n\n# 队列\n\n队列,先进先出.排过队吗?按顺序添加和处理的任务,都可以用`队列`的结构进行存储和消费.\n\n```js\nclass Queue {\n  constructor () {\n    this._items = {}\n    this._count = 0\n    this._lowestCount = 0\n  }\n\n  enqueue(e) {\n    this._items[this._count] = e\n    this._count++\n  }\n  dequeue() {\n    if(this.isEmpty()) return undefined\n    const r = this._items[this._lowestCount]\n    delete this._items[this._lowestCount]\n    this._lowestCount += 1\n    return r\n  }\n\n  isEmpty() {\n    return this._lowestCount === this._count\n  }\n  peek() {\n    return this.isEmpty()  ? undefined : this._items[this._lowestCount]\n  }\n\n  size() {\n    return this._count - this._lowestCount\n  }\n\n  clear() {\n    this._items = {}\n    this._count = 0\n    this._lowestCount = 0\n  }\n  toString() {\n    if(this.isEmpty()) return ''\n    let r = ''\n    for (const iterator of Object.values(this._items)) {\n      r += r === '' ? `${iterator}` : `, ${iterator}`\n    }\n    return r\n  }\n}\n\nlet a = new Queue()\nconsole.log(a.isEmpty())\na.enqueue(1)\na.enqueue('just for fun')\nconsole.log(a.toString())\na.clear()\nconsole.log(a.toString())\n```\n\n普通队列简单,但是有些场景需要对最新入队的元素进行操作.例如,针对需要存储一系列操作的需求.此时,需要灵活处理队首和队尾的数据内容.\n\n当引发撤销操作的时候,操作队列可以从尾部弹出最后的操作记录.\n\n我们需要双端队列.\n\n```js\nclass Deque extends Queue{\n  constructor () {\n    super()\n  }\n  addFront(e) {\n    if(this.isEmpty()) {\n      this.enqueue(e)\n    } else if(this._lowestCount > 0) {\n      this._lowestCount--      \n      this._items[this._lowestCount] = e\n    } else {\n      for (let i = this._count;i>0;i--) {\n        // 往后移动一位\n        this._items[i] = this._items[i - 1]\n      }\n      this._count++\n      this._lowestCount = 0\n      this._items[0] = e\n    }\n  }\n\t// 从队尾出队\n  removeBack() {\n    if(this.isEmpty()) return undefined\n    const lastOne = this._items[this._count - 1]\n    if(this.size() === 1) {\n      this.clear()\n    }\n    delete this._items[this._count - 1]\n    this._count--\n    return lastOne\n  }\n\n  peekBack() {\n    return this._items[this._count]\n  }\n}\n```\n\n其他方法继承于`Queue`,可以实现双端数据操作.\n\n现在,让我们来模拟`击鼓传花`问题.\n\n> *班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。这个时候某个人（比方班长），在击鼓，鼓声停下的一刻，花落在谁手里，谁就进去表演节目*.\n\n```js\nlet a = new Queue();\n['杜小帅', '高海', '董文武', '雪儿', '洛克斯', '庄杯', 'K'].forEach(i => a.enqueue(i));\nlet createANum =  () => Math.random().toFixed(1) * 10\nfunction start(queue) {\n  if(queue.size() === 1) {\n    console.log(`现场唯一的观众: ${queue.dequeue()}`);\n  } else {\n    if(createANum() > 7) {\n      console.log(`${a.dequeue()}, 请开始你的表演.`);\n    } else {\n      queue.enqueue(queue.dequeue())\n    }\n  }\n}\nwhile(a.size() >= 1) {\n  start(a)\n}\n\n// output\n// 庄杯, 请开始你的表演.\n// 董文武, 请开始你的表演.\n// 高海, 请开始你的表演.\n// 杜小帅, 请开始你的表演.\n// 我, 请开始你的表演.\n// 洛克斯, 请开始你的表演.\n// 现场唯一的观众: 雪儿\n```\n\n接下来是回文检查,什么是回文字?\n\n> 回文是指正反序都相等的字符串序列,例如 `lol`,`madam`等等.\n\n最简单的方式就是使用双端队列来处理这个问题.\n\n```js\nfunction palindromeCheaker(str) {\n  if(str === undefined || str === '' || str === null) return false;\n  const deque = new Deque();\n  [...str].forEach(i => deque.enqueue(i));\n  while(deque.size() > 1) {\n    if(deque.removeBack() !== deque.dequeue()) return false\n  }\n  return true\n}\n\nconsole.log(palindromeCheaker('121'), palindromeCheaker('madam'), palindromeCheaker('jay'))\n// output\n// true, true, false\n```\n\nJavaScript 任务也使用了队列这种数据结构.详情可以看看:\n\n[详解JavaScript中的Event Loop（事件循环）机制 - 知乎](https://zhuanlan.zhihu.com/p/33058983)\n\n\n\n# 链表\n\n存储多个元素,数组可能是最常用的数据结构,如果需要从起点或者中间插入元素,数组的操作成本很高.尽管`JavaScript`数组支持了一些方法来做这些事,但是背后的情况同样如此.\n\n> 数组的元素在内存中是连续的,链表则可以是不连续的,链表的关键是使用节点的属性保存下一个或者上一个链表的信息.\n\n相比于传统数组,链表添加或者移除一个元素不需要移动其他元素,大大降低了内存成本.\n\n![](https://pic2.zhimg.com/v2-8158f5bef33b4d38c0ff43d11139a003_1440w.jpg?source=172ae18b)\n\n上图是从网上随便找的示意图.观察可以发现,如果要找到某个节点,需要从`head`一路往下查找.让我们来实现这一数据结构.\n\n```js\nclass LinkedList {\n  constructor() {\n    this.count = 0;\n    this.head = undefined;\n  }\n\n  push(e) {\n    const element = new Node(e)\n    this.count++\n    if (this.head === undefined) {\n      this.head = element\n    } else {\n      let current = this.head\n      while (current.next) {\n        current = current.next\n      }\n      current.next = element\n    }\n  }\n  /**\n   * \n   * @param {number} index 返回删除节点的 element\n   */\n  removeAt(index) {\n    if (index >= 0 && index < this.count) {\n      let current = this.head\n      if (index == 0) {\n        this.head = current.next\n      } else {\n        let prev = this.getElementByIndex(index - 1)\n        current = prev.next\n        prev.next = current.next\n      }\n      this.count--\n      return current.element\n    } else {\n      return undefined\n    }\n  }\n\n  removeValue(element) {\n    const index = this.indexOf(element)\n    return this.removeAt(index)\n  }\n\n  getElementByIndex(index) {\n    if (index >= 0 && index < this.count) {\n      let node = this.head\n      for (let i = 0; i < index && node !== null; i++) {\n        node = node.next\n      }\n      return node\n    } else {\n      return undefined\n    }\n  }\n\n  insert(element, index) {\n    if (index >= 0 && index <= this.count) {\n      const node = new Node(element)\n      if (this.count === 0) {\n        this.head = node\n      } else {\n        let prev = this.getElementByIndex(index - 1)\n        node.next = prev.next\n        prev.next = node\n      }\n      this.count++\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * \n   * @param {any} element search a element, return a index\n   */\n  indexOf(element) {\n    let current = this.head\n    let index = 0\n    while (current) {\n      if (current.element !== element) {\n        current = current.next\n        index++\n      } else {\n        return index\n      }\n    }\n    return -1\n  }\n\n  isEmpty() {\n    return this.count === 0\n  }\n\n  size() {\n    return this.count\n  }\n\n  getHead() {\n    return this.head\n  }\n\n  toString() {\n    if (this.count === 0) {\n      return ''\n    }\n    let current = this.head\n    while (current.next !== undefined) {\n      console.log(current.element);\n      current = current.next\n    }\n    console.log(current.element);\n  }\n}\n\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = undefined;\n  }\n}\n```\n\n来思考一个算法题目,翻转链表:\n\n> 题意：反转一个单链表。\n>\n> 示例: 输入: 1->2->3->4->5->NULL\n> 输出: 5->4->3->2->1->NULL\n\n直接翻转指针,可以避免多余的链表创建和内存占用.\n\n```js\n// data is a LinkedList\nfunction reverseLinkList(data) {\n  if (data.size() > 1) {\n    let current = data.head\n    let prev = undefined\n    let next = undefined\n    while (current !== undefined) {\n      next = current.next;\n      current.next = prev;\n      prev = current\n      current = next\n    }\n    data.head = prev\n    return data\n  } else {\n    return data\n  }\n}\n```\n\n\n\n接着,看看`双向链表`:\n\n```js\nclass DoublyNode extends Node {\n  constructor(element, prev = undefined, next = undefined) {\n    super(element, next)\n    this.prev = prev;\n  }\n}\n\nclass DoublyLinkedList extends LinkedList {\n  constructor() {\n    super()\n    this.tail = undefined;\n  }\n  push(element) {\n    const node = new DoublyNode(element)\n    if (this.count === 0) {\n      this.head = node\n      this.tail = node\n    } else {\n      let current = this.head\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n      node.prev = current\n    }\n    this.tail = node\n    this.count++\n  }\n  insert(element, index) {\n    const node = new DoublyNode(element)\n    if (index >= 0 && index <= this.count) {\n      if (this.count === 0) {\n        this.head = node\n        this.tail = node\n      } else {\n        let oldNode = this.getElementByIndex(index)\n        console.log(oldNode.element, 'is old node');\n        // 新插入节点设置了前后节点\n        node.next = oldNode\n        node.prev = oldNode.prev\n        // 旧的节点设置了 prev\n        oldNode.prev = node\n        if (node.prev) {\n          // 如果前节点存在\n          node.prev.next = node\n        } else {\n          // 不存在则说明插入的是链表头\n          this.head = node\n        }\n      }\n      this.count++\n      return true\n    }\n    return false\n  }\n  getTail() {\n    return this.tail\n  }\n  /**\n   * \n   * @param {number} index 1. 链表长为 1\n   * 2. 长不为 1 => 1.删除首个元素/ 2.删除最后元素 / 3.删除中间元素\n   */\n  removeAt(index) {\n    const node = this.getElementByIndex(index)\n    // 空链表和无效 index\n    if (this.count === 0 && node === undefined) return undefined\n\n    // 链长 1,删除 1\n    if (this.count === 1 && node === this.head) {\n      this.head = undefined\n      this.tail = undefined\n      this.count = 0\n      return node\n    }\n    // 链长不为 1\n    // index 对应的 node 有效\n    if (node === this.head) {\n      this.head = node.next\n    } else if (node === this.tail) {\n      node.prev.next = undefined\n      this.tail = node.prev\n    } else {\n      node.prev.next = node.next\n      node.next.prev = node.prev\n    }\n    this.count--\n    return node\n  }\n}\n```\n\n\n\n双向链表增加了`tail`属性,保存了链表尾部元素,且对每个节点的结构,增加了`prev`属性保存前一个节点信息.\n\n下面看看`双向循环链表`,其跟双向链表的区别在于,对首个元素的`prev`设置为最后一个元素.最后一个元素的`next`设置为首个元素.因此,需要稍微调整代码结构.\n\n```js\nclass LoopDoublyLinkedList extends DoublyLinkedList {\n  constructor() {\n    super()\n  }\n  push(element) {\n    const node = new DoublyNode(element)\n    if (this.count === 0) {\n      this.head = node\n      this.tail = node\n      node.prev = node\n      node.next = node\n    } else {\n      // 新节点的头和尾部改一下\n      node.next = this.head\n      node.prev = this.tail\n      this.tail.next = node\n      this.head.prev = node\n      this.tail = node\n    }\n    this.count++\n  }\n\n  removeAt(index) {\n    const node = this.getElementByIndex(index)\n    if (node) {\n      if (this.count === 1) {\n        this.clear()\n      } else {\n        let prev = node.prev\n        let next = node.next\n        prev.next = next\n        next.prev = prev\n        this.count--\n      }\n      return node\n    } else {\n      return undefined\n    }\n  }\n  insert(element, index) {\n    const node = new DoublyNode(element)\n    let targetNode = this.getElementByIndex(index)\n    if (targetNode === undefined) return false\n\n    // 确定了插入位置\n    if (index === 0) {\n      // 插入表头\n      node.next = this.head.next\n      node.prev = this.tail\n      this.head.prev = node\n      this.head = node\n      this.tail.next = node\n    } else {\n      node.prev = targetNode.prev\n      node.next = targetNode\n      targetNode.prev.next = node\n      targetNode.prev = node\n    }\n    this.count++\n  }\n  clear() {\n    this.head = undefined\n    this.tail = undefined\n    this.count = 0\n  }\n\n  toString() {\n    if (this.count === 0) return ''\n    let current = this.head\n    // console.log(current.element);\n    // console.log(current.next, this.head);\n    while (current !== this.tail) {\n      console.log(current.element);\n      current = current.next\n    }\n    console.log(current.element);\n  }\n}\n```\n\n双向循环链表的关键在于处理新节点的`prev`和`next`值,只要不是`空`链表,则每一个节点都有这两个值.\n\n接下来是`有序链表`.为了让节点之间保持顺序,我们可以修改`insert`方法,让插入的位置由内部计算得出.\n\n```js\nclass SortedLinkedList extends LinkedList {\n  constructor() {\n    super()\n  }\n  insert(element, index=0) {\n    if(this.isEmpty()) {\n      return super.insert(element, 0)\n    }\n    // 自定义方法定义插入位置,用默认 index 代替 index 的效果.\n    const pos = this.getIndexNextSortedElement(element);\n    return super.insert(element, pos)\n  }\n  \n  getIndexNextSortedElement(element) {\n    let current = this.head;\n    let i = 0;\n    // 遍历,直接判断大小,也可以重新定义一个比较函数\n    for(;i < this.size() && current; i++) {\n      if(current.element < element) {\n        return i\n      }\n      current = current.next\n    }\n    return i\n  }\n}\n```\n\n其他方法都是继承的,不需要改变.由于插入的位置程序内部通过特定的比较算法去判断,因此实现了链表的有序性.\n\n在操作和查找一个有序的链表的场景之下,可以使用不同的查找算法提高查找效率.\n\n\n\n> 我想把这些数据结构都保存到自己的工具库中去,因此需要暂时停止下一步:集合和散列表的学习.转向 webpack5 和 babel7 ,用于创建良好的环境,支持自己保存工具库和自己的数据结构.\n>\n> 2021年01月13日00:27:40,晚安.\n\n\n\n# 参考\n\n- [数据结构与算法-链表(上) - 知乎](https://zhuanlan.zhihu.com/p/52878334)\n- [数据结构与算法-链表(下) - 知乎](https://zhuanlan.zhihu.com/p/52841915)\n\n","title":"Javascript中的队列和链表","date":"2021/1/7","tags":["JavaScript","数据结构与算法"],"mainImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"几年前在学校使用 c++ 进行数据结构与算法的学习.学得跟屎一样,丢人现眼.前段时间在飞机上看完了队列和链表部分的内容,还是觉得需要整理一下写成文章."}},"__N_SSG":true}
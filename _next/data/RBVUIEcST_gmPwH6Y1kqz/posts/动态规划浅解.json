{"pageProps":{"post":{"slug":"动态规划浅解","content":"\n### 前言\n\n为了能通过大厂的笔试,算法这一关是必须闯的,其中动态规划可以单独拉出来学习.\n\n### 思想\n\n> 简而言之\n\n动态规划的核心在于`拆`和`解`!在于`尽可能缩小可能的解的空间`!\n\n将一个问题拆成几个子问题,求解这些子问题,把子问题的答案保存起来,最终推断出最大的问题的解.\n\n最大的问题的`最优解`通常是某个算法问题的答案,这个最优解可以由小问题的最优解推出.\n\n对于使用`DP`算法解决问题,需要明确以下三点:\n\n- 设计状态\n- 设计状态转移方程\n- 转移状态\n\n### 实例解析\n\n#### 🐸 跳台阶\n\n[剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)\n\n当年校招时,我一直以为这种笔试题是脑筋急转弯,现在才知道当时有多可笑.\n\n首先,定义一个数组保存若干台阶时有多少种跳法,数组为`dp`,跳上`i`级的台阶的跳法有`dp[i]`种.\n那么最终的结果就是：`dp[n] = dp[n-1] + dp[n-2]`\n\n这里我们就思考初始化状态是什么？显然 dp[0] = 1, dp[1] = 1\n\n代码如下：\n\n```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar numWays = function (n) {\n  let dp = [1, 1];\n  if (n < 2) return 1;\n  for (let i = 2; i <= n; i++) {\n    let types = (dp[0] + dp[1]) % 1000000007;\n    dp[0] = dp[1];\n    dp[1] = types;\n  }\n  return dp[1];\n};\n```\n\n初始化其状态，得出跳 2 次以下都只有 1 种方法的初始状态，然后逐步求新增的台阶直到 n 级。在上述代码中，使用固定长度的数组能节省空间，实质上依然是取最后两个选择的结果，这两个选择的结果被保存到了数组开头而已。\n\n#### 不同路径\n\n[62. 不同路径 - 力扣（LeetCode）](https://leetcode-cn.com/problems/unique-paths/)\n\n首先，如何设计状态？用函数的思路来设计，那么可以用 f(i,j) 表示从左上角走到坐标 (i,j) 的总路径数。\n显然，要走到最后只有两种选择：\n\n- 从目标的上面往下\n- 从目标的左边往右\n\n那么最终的状态转移方程可得：\n`f(i,j) = f(i-1, j) + f(i, j-1)`\n\n接着，我们来初始化一些状态。根据实际题目可知，我们需要用一个二维数组来保存每一个坐标的路径总数。并且无论是第一行还是第一列，都只有一条路可走。\n\n```js\nconst uniquePaths = (m, n) => {\n  // 初始化二维数组\n  const f = new Array(m).fill(0).map(() => new Array(n).fill(0));\n  // 初始化第一行和第一列的路径总数\n  for (let i = 0; i < m; i++) {\n    // 第一行\n    f[0][i] = 1;\n  }\n  for (let j = 0; j < n; j++) {\n    // 第一列\n    f[j][0] = 1;\n  }\n  // 其他位置\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      // 某坐标的路径总数可以根据此前的历史数据计算出来，最终得到 f(i, j)\n      f[i][j] = f[i - 1][j] + f[i][j - 1];\n    }\n  }\n  return f[m - 1][n - 1];\n};\n```\n\n另有题：[64. 最小路径和 - 力扣（LeetCode）](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n依然是状态转移方程的设计：\n`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`\n\n雷同于上一题，但这一题为每一个坐标提供了路径值，以下代码最佳：\n\n```js\nconst minPathSum = (grid) => {\n  const row = grid.length,\n    col = grid[0].length;\n  // 将初始化的数据直接写在 grid 上节省空间\n  for (let i = 1; i < row; i++) {\n    grid[i][0] += grid[i - 1][0];\n  }\n  for (let j = 1; j < col; j++) {\n    grid[0][j] += grid[0][j - 1];\n  }\n  for (let i = 1; i < row; i++) {\n    for (let j = 1; j < col; j++) {\n      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n    }\n  }\n  return grid[row - 1][col - 1];\n};\n```\n\n首先，获取到行和列的数。由于第一行和第一列都只有一个上层选项，并且内部贴边的坐标都依赖于第一行或第一列，因此可以将数据直接更新到二维数组上，然后更新第一行和第一列某个坐标的路径值。\n\n#### 编辑距离\n\n再来一题`Hard`难题,这道题就是[72. 编辑距离 - 力扣（LeetCode）](https://leetcode-cn.com/problems/edit-distance/).说实话,在一开始看这道题的时候我真的一点想法都没有,如果说非要有想法,那就是怀疑我自己智力不足.\n\n这一题需要计算最少的操作数,那么可以脑补一下要用到`Math.min()`来从若干个操作中获取操作数最小的.\n\n`接下来就是顿悟时刻`.\n\n每一个单词都有长度,这两个长度就是`m`和`n`!\n当在某个阶段想要获得最少的操作数时,就可以根据二者的动态下标,选择最佳的操作.\n\n首先是初始化,显然无论如何当某个单词为空字符串的时候,下标会有 0 的存在,这个数组元素就等于添加若干个字母.\n\n也就是说:\n`dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i-1][j]) + 1`\n\n当我们得知历史数据后,可以根据最小的操作去做下一步,选择最小的操作再+1.\n\n```js\nconst minDistance = (word1 = \"horse\", word2 = \"ros\") => {\n  let dp = Array.from(Array(word1.length + 1), () =>\n    Array(word2.length + 1).fill(0)\n  );\n  console.log(dp);\n  for (let i = 1; i <= word1.length; i++) {\n    dp[i][0] = i;\n  }\n\n  for (let j = 1; j <= word2.length; j++) {\n    dp[0][j] = j;\n  }\n\n  for (let i = 1; i <= word1.length; i++) {\n    for (let j = 1; j <= word2.length; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n      }\n    }\n  }\n\n  return dp[word1.length][word2.length];\n};\n```\n\n在 LeetCode 看到一个更好的解法：\n\n```js\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function (word1, word2) {\n  let n = word1.length;\n  let m = word2.length;\n  if (n * m === 0) return n + m;\n  if (word1 === word2) return 0;\n  let dp = [];\n  for (let i = 0; i <= n; i++) {\n    dp.push([]);\n    for (let j = 0; j <= m; j++) {\n      if (i * j) {\n        dp[i][j] =\n          word1[i - 1] == word2[j - 1]\n            ? dp[i - 1][j - 1]\n            : Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n      } else {\n        dp[i][j] = i + j;\n      }\n    }\n  }\n  return dp[n][m];\n};\n```\n\n不用初始化，直接判断是否有字符长度为 0，是则返回另一个的长度。否则根据动态规划的转移方程计算出结果。\n\n> 官方题解的评论区有一个 Python 版本的最优解，使用滚动数组压缩空间，笔者智力不足，有兴趣的可以去看看。\n\n#### 最长递增子序列\n\n> 作者：liweiwei1419\n> 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/\n\n这道题是很经典「动态规划」算法问题。\n\n- 需要对「子序列」和「子串」这两个概念进行区分；\n  - 子序列（subsequence）：子序列并不要求连续，例如：序列 [4, 6, 5] 是 [1, 2, 4, 3, 7, 6, 5] 的一个子序列；\n  - 子串（substring、subarray）：子串一定是原始字符串的连续子串。\n- 题目中的「上升」的意思是「严格上升」。反例： [1, 2, 2, 3] 不能算作「上升子序列」；\n- 子序列中元素的 相对顺序 很重要，子序列中的元素 必须保持在原始数组中的相对顺序。如果把这个限制去掉，将原始数组去重以后，元素的个数即为所求；\n- O(N \\log N)O(NlogN) 的解法根据了「最长上升子序列」问题的特点，设计了合适的状态，使得复杂度从 O(N^2)O(N 2 ) 降到了 O(N \\log N)O(NlogN)。\n\n#### 最长回文子串\n\n> 作者：visa\n> 链接：https://juejin.cn/post/6844903902865784846\n\n首先考虑如果字符串长度为 1，那么答案就是其本身\n\n如果字符串长度等于 2，那么如果 s[i] == s[j] 则说明该字符串为回文\n\n那么如果长度大于 2 呢？s[i] == s[j]的情况下 s[i + 1] == s[j-1]，也说明该字符串为回文\n\n如此推论，结果如下：\n\n```js\nvar longestPalindrome = function (s) {\n  if (s.length == 1) {\n    // 长度1，返回本身\n    return s;\n  }\n\n  // 创建二阶数组存储从j到i是否是回文数组，0为不回文，1为回文\n  let arr = [];\n  for (let i = 0; i < s.length; i++) {\n    arr[i] = [];\n  }\n\n  // 存储最长回文子串的起始位置\n  let begin = 0;\n  // 存储最长子串的长度\n  let max = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    let j = 0;\n    while (j <= i) {\n      // 如果 i-j <= 1 时，说明i位置和j位置要么是重合的，要么是相邻的，即为最后一次查找\n      // 否则继续查询[j + 1]到[i - 1]是否为回文\n      if (s[j] == s[i] && (i - j <= 1 || arr[j + 1][i - 1])) {\n        // 如果符合上述条件，说明j到i是回文\n        arr[j][i] = 1;\n        if (i - j + 1 > max) {\n          // 如果当前子串大于存储的子串长度，则替换之\n          begin = j;\n          // 注意+1，比如从3到5的长度为3 = 5 - 3 + 1\n          max = i - j + 1;\n        }\n      }\n      j++;\n    }\n  }\n  return s.substr(begin, max);\n};\n```\n\n### 总结\n\n其实，算法对笔者这类非天才开发者来说，需要在日常中多思考和积累，临时抱佛脚是不现实的。\n","title":"动态规划浅解","date":"2021/12/11","tags":["算法"],"mainImg":"https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=400","intro":"动态规划到底是什么玩意?"}},"__N_SSG":true}
{"pageProps":{"post":{"slug":"从ES6到ESNext","contentHtml":"<p><code>ECMA</code>是一个将信息标准化的组织,<code>JavaScript</code>被提交到<code>ECMA</code>后诞生了一个新的语言标准<code>ECMAScript</code>.而<code>JavaScript</code>只是该标准最流行的一个实现.浏览器厂商根据该标准实现自己浏览器版本的<code>JavaScript</code>功能,因此少数的功能,每个浏览器的实现和效果可能有所不同.</p>\n<h1>总览</h1>\n<p><code>ES2015</code>就是 2015 年标准化的,但是在<code>ES2015</code>发布之前,<code>ES6</code>的名字就已经流行起来了.</p>\n<p>2016 年6 月,<code>ES2016</code>即<code>ES7</code>.</p>\n<p>2017 年 6 月,<code>ECMAScript第八版</code>被标准化,我们称之为<code>ES2017</code>或者<code>ES8</code>.</p>\n<p>有些文章提到的<code>ESNext</code>,这种说法被指代下一个版本的<code>ECMAScript</code>.</p>\n<p>在日常开发中,经常可以看到使用<code>babel</code>等转译器将新版本的代码转化为指定版本,以支持浏览器功能.</p>\n<p>话不多说,让我们再回顾一遍<code>ES6</code>的功能.</p>\n<ul>\n<li>使用<code>let</code>和<code>const</code></li>\n<li>模板字面量</li>\n<li>解构</li>\n<li>展开运算符</li>\n<li>箭头函数</li>\n<li>类</li>\n<li>模块</li>\n</ul>\n<p>当我写下上面这些功能的时候,其实已经发现这些功能已经广泛应用在我的日常开发中了.</p>\n<p>首先,<code>let</code>和<code>const</code>声明的值,无法重复声明,<code>let</code>声明的值可以重复赋值和修改类型,而<code>const</code>则声明只读的变量.</p>\n<p><code>var</code>声明的变量会被提升到变量范围的顶部.坚持使用<code>let</code>和<code>const</code>则不会出现这种令人迷惑的隐式行为.作用域的行为跟<code>Java</code>和<code>c</code>等语言一致.大大减少了<code>var</code>产生的迷惑行为.</p>\n<p>关于<code>模板字面量</code>,真的太棒了.</p>\n<pre><code><span>let</span> a = <span>1</span>\n<span class=\"lineNumber\">2</span><span>console</span>.log(<span>`a\n<span class=\"lineNumber\">3</span>b\n<span class=\"lineNumber\">4</span>c<span>${a}</span>\n<span class=\"lineNumber\">5</span>`</span>)\n<span class=\"lineNumber\">6</span><span>// 变量替换和换行保留</span></code></pre> \n\n<p>箭头函数,自不必说,极大的方便了简化了函数的语法.但是箭头函数的<code>this</code>跟普通函数又不太一样.</p>\n<ul>\n<li><strong>箭头函数中的this,使用了词法作用域去查找,而不是动态作用域</strong></li>\n<li>不能用<code>call</code>手动修改<code>this</code></li>\n<li>不存在普通函数内的<code>this</code>,<code>caller</code>和<code>arguments</code></li>\n<li>无原型</li>\n</ul>\n<p>这里摘抄一份推荐中的<code>面试宝典</code>内的解释,非常喜欢.</p>\n<blockquote>\n<p>对于词法作用域而言，一旦函数定义，所有变量都是确定的，不会因执行的位置/方式而改变。但是当访问 this 的时候，情况却大不一样了。</p>\n</blockquote>\n<p>调用一个函数有四个方式：</p>\n<pre><code><span><span>function</span> <span>a</span>(<span></span>) </span>{ }   <span>// 定义</span>\n<span class=\"lineNumber\">2</span><span>let</span> b = { a }\n<span class=\"lineNumber\">3</span><span>let</span> c = {}\n<span class=\"lineNumber\">4</span>a()                <span>// 以函数方式调用</span>\n<span class=\"lineNumber\">5</span><span>new</span> a()            <span>// 以构造函数的方式调用</span>\n<span class=\"lineNumber\">6</span>b.a()              <span>// 以对象方法的方式调用</span>\n<span class=\"lineNumber\">7</span>a.apply(c)         <span>// 通过它们的 apply/call 方法间接调用</span></code></pre> \n\n<p>在这四个方式下，this 的指向均不同。以函数方式调用，this 指向 window；以构造函数的方式调用，this 指向所构造的实例对象；以对象方法的方式调用，this 指向其所在的对象；通过它们的 apply/call 方法间接调用，this 的指向取决于传入的参数。而这就是 JavaScript 中的动态作用域。</p>\n<p>另外,ES5 的函数支持默认值.这是从前不支持的,极大提升了灵活性.普通函数内置 <code>arguments</code>变量,保存了类数组的参数数据.可以通过下表获取参数传入的值.</p>\n<p>话说回来,继续说展开运算符,非常有用.</p>\n<pre><code><span>let</span> params = [<span>1</span>,<span>2</span>,<span>3</span>]\n<span class=\"lineNumber\">2</span><span>console</span>.log(sum(...params))\n<span class=\"lineNumber\">3</span><span>// 自动扩展,等同于ES5</span>\n<span class=\"lineNumber\">4</span><span>console</span>.log(sum.apply(<span>undefined</span>, params))\n<span class=\"lineNumber\">5</span> \n<span class=\"lineNumber\">6</span><span>// 当做剩余参数使用</span>\n<span class=\"lineNumber\">7</span><span><span>function</span> <span>demo</span>(<span>a, b, ...others</span>) </span>{\n<span class=\"lineNumber\">8</span>  <span>// others是数组,不是类数组.可以使用Array的原型链方法</span>\n<span class=\"lineNumber\">9</span>}</code></pre> \n\n<p><strong>数组和对象解构,属性方法简写,简写方法名这些语法</strong>真的很酷.</p>\n<pre><code><span>let</span> [x, y] = [<span>'a'</span>, <span>'b'</span>]\n<span class=\"lineNumber\">2</span><span>// x = a</span>\n<span class=\"lineNumber\">3</span><span>// y = b</span>\n<span class=\"lineNumber\">4</span><span>let</span> demo = {<span>c</span>: <span>1</span>, <span>d</span>: <span>2</span>}\n<span class=\"lineNumber\">5</span><span>let</span> {c , d} = demo\n<span class=\"lineNumber\">6</span><span>// c = 1</span>\n<span class=\"lineNumber\">7</span><span>// d = 2</span>\n<span class=\"lineNumber\">8</span><span>let</span> d = {c, d}\n<span class=\"lineNumber\">9</span><span>// d = {c: 1, d: 2}</span>\n<span class=\"lineNumber\">10</span><span>const</span> foo = {\n<span class=\"lineNumber\">11</span>  <span>name</span>: <span>'aaron'</span>,\n<span class=\"lineNumber\">12</span>  <span><span>sayHi</span>(<span></span>)</span> {\n<span class=\"lineNumber\">13</span>    <span>console</span>.log(<span>'hi'</span>)\n<span class=\"lineNumber\">14</span>  }\n<span class=\"lineNumber\">15</span>}\n<span class=\"lineNumber\">16</span>foo.sayHi() <span>// 'hi'</span></code></pre> \n\n<p>另外,使用类进行编程在 JavaScript 的世界里,是从<code>ES6</code>的时候流行起来的.</p>\n<pre><code><span><span>class</span> <span>MathBook</span> <span>extends</span> <span>Book</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span>name</span>)</span> {\n<span class=\"lineNumber\">3</span>    <span>super</span>(name) <span>// 调用父类构造函数</span>\n<span class=\"lineNumber\">4</span>    <span>this</span>.name = name\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span>  <span><span>getName</span>(<span></span>)</span> {\n<span class=\"lineNumber\">7</span>    <span>return</span> <span>this</span>.name\n<span class=\"lineNumber\">8</span>  }\n<span class=\"lineNumber\">9</span>}</code></pre> \n\n<p><strong>JavaScript 的 class 的实现方式依然是基于原型的</strong>,如果你喜欢<code>class</code>,则使用<code>class</code>.我更喜欢原型.</p>\n<p>另外,类支持属性存取器.类的属性不是私有的,建议使用下划线开头的社区命名模式.</p>\n<pre><code><span><span>class</span> <span>Person</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span>name</span>)</span>{\n<span class=\"lineNumber\">3</span>    <span>this</span>._name = name\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span>set</span> <span>name</span>(<span>v</span>) {\n<span class=\"lineNumber\">6</span>    <span>this</span>._name = v\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span>get</span> <span>name</span>() {\n<span class=\"lineNumber\">9</span>    <span>return</span> <span>this</span>._name\n<span class=\"lineNumber\">10</span>  }\n<span class=\"lineNumber\">11</span>}</code></pre> \n\n<blockquote>\n<p>依然可以获取 Person 实例的 _name 属性.</p>\n</blockquote>\n<p><strong>模块</strong>已经被广泛应用了.<code>nodejs</code>开发中的<code>require</code>语句使用的是<code>commonJS</code>模块.<code>ES6</code>的模块见示例:</p>\n<pre><code><span>// somename.js</span>\n<span class=\"lineNumber\">2</span><span>const</span> a = <span><span>v</span> =></span> v\n<span class=\"lineNumber\">3</span><span>exports</span> {a}\n<span class=\"lineNumber\">4</span> \n<span class=\"lineNumber\">5</span><span>// 引用</span>\n<span class=\"lineNumber\">6</span><span>import</span> {a} <span>from</span> ./somename\n<span class=\"lineNumber\">7</span><span>// 重命名</span>\n<span class=\"lineNumber\">8</span><span>import</span> {a <span>as</span> b} <span>from</span> ./somename\n<span class=\"lineNumber\">9</span><span>// other style</span>\n<span class=\"lineNumber\">10</span><span>import</span> * <span>as</span> Lib <span>from</span> ./somename\n<span class=\"lineNumber\">11</span><span>// call a</span>\n<span class=\"lineNumber\">12</span>Lib.a\n<span class=\"lineNumber\">13</span> \n<span class=\"lineNumber\">14</span><span>// 每个 js 文件都支持一个 default 导出</span>\n<span class=\"lineNumber\">15</span><span>export</span> <span>default</span> Some;\n<span class=\"lineNumber\">16</span><span>// 引入</span>\n<span class=\"lineNumber\">17</span><span>import</span> Some <span>from</span> somename\n<span class=\"lineNumber\">18</span><span>// 或者直接导出</span>\n<span class=\"lineNumber\">19</span><span>export</span> <span>const</span> a = <span>() =></span> <span>1</span></code></pre> \n\n<p>如果想在<code>nodejs</code>中使用<code>ES6</code>模块导入导出方案,可以参考:<a href=\"https://medium.com/@josephinegyamera/using-es6-syntax-import-export-in-node-js-with-babel-7ef48b874c52\">Using ES6 syntax “import/export” in Node js with Babel | by Josephine Gyamera | Medium</a></p>\n<p>另外,mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。</p>\n<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。</p>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51205665\">JS 中 lambda 表达式中的 this 到底如何理解 - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/47132493\">面试宝典之箭头函数中的this - 知乎</a></li>\n<li><a href=\"https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html\">少年，不要滥用箭头函数啊 - jingsam</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html\">Node.js 如何处理 ES6 模块 - 阮一峰的网络日志</a></li>\n</ul>\n","title":"从ES6到ESNext","date":"2020/12/28","tags":["算法","JavaScript"],"mainImg":"https://images.unsplash.com/photo-1605088807164-d62040fcd980?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1605088807164-d62040fcd980?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"回顾 ES2015(ES6),简介 ES7 到 ESNext.有趣的 JavaScript 世界,有趣的技术发展历程."}},"__N_SSG":true}
{"pageProps":{"post":{"slug":"Javascript-理论与常识","contentHtml":"<p>2020年12月27日22:46:02,ES6 看起来已经不是新知识点了,本文从新版 ECMAScript 特性开始说起.</p>\n<h1>ES7(2018) 新特性</h1>\n<p><code>Array.prototype.includes</code>能快速查找数组中是否包含某个元素,包括<code>NaN</code>,之前的<code>indexOf</code>方法也能检查数组中的元素,但是不支持<code>NaN</code>的检查.我们知道<code>NaN !== NaN</code>.</p>\n<p>另外,JavaScript 支持了指数函数的<code>中缀表示法</code></p>\n<pre><code><span>let</span> n = <span>2</span>**<span>3</span> \n<span class=\"lineNumber\">2</span>=> <span>2</span>*<span>2</span>*<span>2</span> \n<span class=\"lineNumber\">3</span>=> <span>8</span>\n<span class=\"lineNumber\">4</span><span>let</span> a = <span>2</span>\n<span class=\"lineNumber\">5</span>a **= <span>2</span> <span>// a = a * a</span>\n<span class=\"lineNumber\">6</span><span>let</span> b = <span>3</span>\n<span class=\"lineNumber\">7</span>b **= <span>3</span> <span>// b = b * b * b</span></code></pre> \n\n<h1>ES8(2019) 新特性</h1>\n<p><code>Object.values</code>和<code>Object.entries</code>.</p>\n<p>返回接收参数(对象或者数组)的可枚举属性的值的数组,后者是键值对数组.</p>\n<pre><code><span>let</span> obj = {<span>x</span>: <span>'xx'</span>, <span>y</span>: <span>1</span>}\n<span class=\"lineNumber\">2</span><span>Object</span>.values(obj) \n<span class=\"lineNumber\">3</span>=> [<span>'xx'</span>, <span>1</span>]\n<span class=\"lineNumber\">4</span><span>Object</span>.entries(obj)\n<span class=\"lineNumber\">5</span>=> [[<span>'x'</span>, <span>'xx'</span>], [<span>'y'</span>, <span>1</span>]]</code></pre> \n\n<p>也算是对之前只有<code>Object.keys</code>的补全吧.</p>\n<blockquote>\n<p>在 chrome 下,Object 的这三个方法都不能取得原型链上的值</p>\n</blockquote>\n<p><code>Object</code>还增加了<code>getOnwPropertyDescriptors</code>方法.接收一个对象作为参数,返回此对象所有自身描述符,如果没有任何自身属性,返回空对象.<code>IE</code>不支持这个特性.</p>\n<pre><code><span>const</span> obj = { \n<span class=\"lineNumber\">2</span>  <span>get</span> <span>es7</span>() { <span>return</span> <span>7</span>; },\n<span class=\"lineNumber\">3</span>  <span>get</span> <span>es8</span>() { <span>return</span> <span>8</span>; }\n<span class=\"lineNumber\">4</span>};\n<span class=\"lineNumber\">5</span><span>Object</span>.getOwnPropertyDescriptors(obj);\n<span class=\"lineNumber\">6</span><span>// {</span>\n<span class=\"lineNumber\">7</span><span>//   es7: {</span>\n<span class=\"lineNumber\">8</span><span>//     configurable: true,</span>\n<span class=\"lineNumber\">9</span><span>//     enumerable: true,</span>\n<span class=\"lineNumber\">10</span><span>//     get: function es7(){}, //the getter function</span>\n<span class=\"lineNumber\">11</span><span>//     set: undefined</span>\n<span class=\"lineNumber\">12</span><span>//   },</span>\n<span class=\"lineNumber\">13</span><span>//   es8: {</span>\n<span class=\"lineNumber\">14</span><span>//     configurable: true,</span>\n<span class=\"lineNumber\">15</span><span>//     enumerable: true,</span>\n<span class=\"lineNumber\">16</span><span>//     get: function es8(){}, //the getter function</span>\n<span class=\"lineNumber\">17</span><span>//     set: undefined</span>\n<span class=\"lineNumber\">18</span><span>//   }</span>\n<span class=\"lineNumber\">19</span><span>// }</span></code></pre> \n\n<p>字符串方面,增加了两个有趣的方法:</p>\n<ul>\n<li>\n<p><code>String.padStart(targetLength,[padString])</code> *targetLength：*当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p>\n<p><em>padString：</em>(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。</p>\n</li>\n<li>\n<p><code>String.padEnd(targetLength,padString])</code> 参数释义同上。</p>\n</li>\n</ul>\n<p>我觉得在做<code>cli</code>输出数据,或者在<code>table</code>上能用到.</p>\n<p>现在,对象和参数,数组都支持结尾逗号了.下面的代码都不会报错.</p>\n<pre><code><span>//定义参数时</span>\n<span class=\"lineNumber\">2</span><span><span>function</span> <span>foo</span>(<span>\n<span class=\"lineNumber\">3</span>    param1,\n<span class=\"lineNumber\">4</span>    param2,<span>//结尾逗号</span>\n<span class=\"lineNumber\">5</span></span>) </span>{}\n<span class=\"lineNumber\">6</span><span>//传参时</span>\n<span class=\"lineNumber\">7</span>foo(\n<span class=\"lineNumber\">8</span>    <span>'coffe'</span>,\n<span class=\"lineNumber\">9</span>    <span>'1891'</span>,<span>//结尾逗号</span>\n<span class=\"lineNumber\">10</span>);\n<span class=\"lineNumber\">11</span><span>//对象中</span>\n<span class=\"lineNumber\">12</span><span>let</span> obj = {\n<span class=\"lineNumber\">13</span>    <span>\"a\"</span>: <span>'coffe'</span>,\n<span class=\"lineNumber\">14</span>    <span>\"b\"</span>: <span>'1891'</span>,<span>//结尾逗号</span>\n<span class=\"lineNumber\">15</span>};\n<span class=\"lineNumber\">16</span><span>//数组中</span>\n<span class=\"lineNumber\">17</span><span>let</span> arr = [\n<span class=\"lineNumber\">18</span>    <span>'coffe'</span>,\n<span class=\"lineNumber\">19</span>    <span>'1891'</span>,<span>//结尾逗号</span>\n<span class=\"lineNumber\">20</span>];</code></pre> \n\n<p>如此一来有以下两个好处:</p>\n<ul>\n<li>重新排列项目更简单,如果最后一项改变位置,则不必删除逗号.</li>\n<li>帮助 git 等版本控制系统追踪实际发生的变化.</li>\n</ul>\n<pre><code>[\n<span class=\"lineNumber\">2</span>  <span>'coffe'</span>\n<span class=\"lineNumber\">3</span>]\n<span class=\"lineNumber\">4</span><span>// 变更</span>\n<span class=\"lineNumber\">5</span>[\n<span class=\"lineNumber\">6</span>  <span>'coffe'</span>,\n<span class=\"lineNumber\">7</span>  <span>'1995'</span>\n<span class=\"lineNumber\">8</span>]</code></pre> \n\n<p>现在采用结尾逗号,则在变动追踪的时候只会显示<code>1995</code>的变动,减少了无用信息的上报.</p>\n<p>支持了<code>异步函数</code>.让我们能摆脱回调地狱(callback hell).</p>\n<pre><code><span>async</span> <span><span>function</span> <span>asyncFunc</span>(<span></span>) </span>{\n<span class=\"lineNumber\">2</span>    <span>const</span> result = <span>await</span> otherAsyncFunc();<span>// otherAsyncFunc()返回一个Promise对象</span>\n<span class=\"lineNumber\">3</span>    <span>console</span>.log(result);\n<span class=\"lineNumber\">4</span>}\n<span class=\"lineNumber\">5</span> \n<span class=\"lineNumber\">6</span><span>// 等同于:</span>\n<span class=\"lineNumber\">7</span><span><span>function</span> <span>asyncFunc</span>(<span></span>) </span>{\n<span class=\"lineNumber\">8</span>    <span>return</span> otherAsyncFunc()<span>// otherAsyncFunc()返回一个Promise对象</span>\n<span class=\"lineNumber\">9</span>    .then(<span><span>result</span> =></span> {\n<span class=\"lineNumber\">10</span>        <span>console</span>.log(result);\n<span class=\"lineNumber\">11</span>    });\n<span class=\"lineNumber\">12</span>}</code></pre> \n\n<p>有一本小书专门讲解<code>Async Functions</code>,后续补看.</p>\n<p>另外,<code>ES8</code>支持了<code>共享内存和原子对象</code>.</p>\n<p>请移步看看这里,<a href=\"https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/\">A cartoon intro to ArrayBuffers and SharedArrayBuffers - Mozilla Hacks - the Web developer blog</a>.</p>\n<p><code>SharedArrayBuffer</code>对象用来表示通用固定长度的原始二进制数据缓冲区,类似<code>ArrayBuffer</code>对象.这里涉及到浏览器端的多线程<code>work</code>处理逻辑，共享数据和原子操作。</p>\n<h1>ES9如何？</h1>\n<p>首先，支持了异步迭代器。</p>\n<pre><code><span>async</span> <span><span>function</span> <span>fn</span>(<span>arr</span>) </span>{\n<span class=\"lineNumber\">2</span>    <span>for</span> (<span>let</span> i <span>of</span> arr) {\n<span class=\"lineNumber\">3</span>        <span>await</span> someFn(i)\n<span class=\"lineNumber\">4</span>    }\n<span class=\"lineNumber\">5</span>}</code></pre> \n\n<p>上述代码依然无法让循环实现异步，而是同步执行，且在内部的异步函数得出结果之前全部调用完成。</p>\n<pre><code>\n<span class=\"lineNumber\">2</span><span>const</span> promises = [\n<span class=\"lineNumber\">3</span>    <span>new</span> <span>Promise</span>(<span><span>resolve</span> =></span> resolve(<span>1</span>)),\n<span class=\"lineNumber\">4</span>    <span>new</span> <span>Promise</span>(<span><span>resolve</span> =></span> resolve(<span>2</span>)),\n<span class=\"lineNumber\">5</span>    <span>new</span> <span>Promise</span>(<span><span>resolve</span> =></span> resolve(<span>3</span>))\n<span class=\"lineNumber\">6</span>]\n<span class=\"lineNumber\">7</span><span>async</span> <span><span>function</span> <span>foo</span>(<span></span>) </span>{\n<span class=\"lineNumber\">8</span>    <span>for</span> <span>await</span> (<span>let</span> i <span>of</span> promises) {        \n<span class=\"lineNumber\">9</span>        <span>console</span>.log(i)\n<span class=\"lineNumber\">10</span>    }\n<span class=\"lineNumber\">11</span>}\n<span class=\"lineNumber\">12</span>foo()\n<span class=\"lineNumber\">13</span>=> <span>1</span>,<span>2</span>,<span>3</span></code></pre> \n\n<p>如果我们可能需要用到异步循环，注意引入<code>ES9</code>的支持。</p>\n<p><strong>ES9</strong>支持了 <code>promise</code>在最后时刻执行<code>finally</code>函数.</p>\n<p><strong>并且重新修订了字面量的转义</strong>,终于支持了<code>String.raw</code>.后续的字符串模版全部不会被转义.</p>\n<pre><code><span>let</span> s = <span>`\\u{54}`</span> <span>//会转义成unicode \"T\"</span>\n<span class=\"lineNumber\">2</span><span>console</span>.log(s);<span>//>> T</span>\n<span class=\"lineNumber\">3</span> \n<span class=\"lineNumber\">4</span><span>let</span> str = <span>String</span>.raw<span>`\\u{54}`</span>; <span>//不会被转义</span>\n<span class=\"lineNumber\">5</span><span>console</span>.log(str);<span>//>> \\u{54}</span></code></pre> \n\n<p>关于扩展运算符,<code>ES6</code>只支持数组的扩展.现在终于能操作对象了.</p>\n<pre><code><span>const</span> obj = {\n<span class=\"lineNumber\">2</span>  <span>a</span>: <span>1</span>,\n<span class=\"lineNumber\">3</span>  <span>b</span>: <span>2</span>,\n<span class=\"lineNumber\">4</span>  <span>c</span>: <span>3</span>\n<span class=\"lineNumber\">5</span>};\n<span class=\"lineNumber\">6</span><span>const</span> { a, ...param } = obj; <span>//这里...是rest</span>\n<span class=\"lineNumber\">7</span><span>console</span>.log(a); <span>//>> 1</span>\n<span class=\"lineNumber\">8</span><span>console</span>.log(param); <span>//>> {b: 2, c: 3}</span>\n<span class=\"lineNumber\">9</span> \n<span class=\"lineNumber\">10</span><span><span>function</span> <span>foo</span>(<span>{ a, ...param }</span>) </span>{<span>//这里...还是rest</span>\n<span class=\"lineNumber\">11</span>  <span>console</span>.log(a); <span>//>> 1</span>\n<span class=\"lineNumber\">12</span>  <span>console</span>.log(param); <span>//>> {b: 2, c: 3}</span>\n<span class=\"lineNumber\">13</span>}\n<span class=\"lineNumber\">14</span> \n<span class=\"lineNumber\">15</span><span>const</span> param = { <span>b</span>: <span>2</span>, <span>c</span>: <span>3</span> };\n<span class=\"lineNumber\">16</span>foo({ <span>a</span>: <span>1</span>, ...param });  <span>//此处...为spread</span></code></pre> \n\n<p><code>ES9</code>还对正则表达式提供了非常给力的支持.例如之前<code>.</code>能匹配除了<code>回车</code>外的所有字符,现在添加<code>flag</code>标志<code>s</code>,就可以匹配回车了.</p>\n<pre><code>/hello.world/s.test(<span>'hello\\nworld'</span>) \n<span class=\"lineNumber\">2</span>=> <span>true</span>\n<span class=\"lineNumber\">3</span>/a.b/s.text(<span>`a\n<span class=\"lineNumber\">4</span>b`</span>)\n<span class=\"lineNumber\">5</span>=> <span>true</span></code></pre> \n\n<p>另外,对正则表达式命名捕获组也进行了支持:</p>\n<pre><code><span>const</span> reDate = <span>/(\\d{4})-(\\d{2})-(\\d{2})/</span>,\n<span class=\"lineNumber\">2</span>  match = reDate.exec(<span>\"2018-08-06\"</span>);\n<span class=\"lineNumber\">3</span><span>console</span>.log(match);<span>//>> [2018-08-06, 2018, 08, 06]</span>\n<span class=\"lineNumber\">4</span> \n<span class=\"lineNumber\">5</span><span>//这样就可以直接用索引来获取年月日：</span>\n<span class=\"lineNumber\">6</span><span>let</span> year = match[<span>1</span>]; <span>//>> 2018</span>\n<span class=\"lineNumber\">7</span><span>let</span> month = match[<span>2</span>]; <span>//>> 08</span>\n<span class=\"lineNumber\">8</span><span>let</span> day = match[<span>3</span>]; <span>//>> 06</span>\n<span class=\"lineNumber\">9</span><span>// 一旦字符串顺序变化,则除了要修改正则表达式之外,还需要修改上面三行取值的代码.</span></code></pre> \n\n<p><code>ES9</code>支持对匹配组进行命名,获取匹配结果的时候可以通过分组的名字获取.</p>\n<pre><code><span>const</span> reDate = <span>/(?&#x3C;year>\\d{4})-(?&#x3C;month>\\d{2})-(?&#x3C;day>\\d{2})/</span>,\n<span class=\"lineNumber\">2</span>  match = reDate.exec(<span>\"2018-08-06\"</span>);\n<span class=\"lineNumber\">3</span><span>console</span>.log(match);\n<span class=\"lineNumber\">4</span><span>//>> [2018-08-06, 08, 06, 2018, groups: {day: 06, month: 08, year: 2018}]</span>\n<span class=\"lineNumber\">5</span> \n<span class=\"lineNumber\">6</span><span>//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span>\n<span class=\"lineNumber\">7</span><span>let</span> year = match.groups.year; <span>//>> 2018</span>\n<span class=\"lineNumber\">8</span><span>let</span> month = match.groups.month; <span>//>> 08</span>\n<span class=\"lineNumber\">9</span><span>let</span> day = match.groups.day; <span>//>> 06</span></code></pre> \n\n<p>正则表达式的进阶小书里提及的断言,之前只支持正向现行断言,<code>ES9</code>支持了后行断言.</p>\n","title":"Javascript-理论与常识","date":"2020/12/27","tags":["Javascript"],"mainImg":"https://images.unsplash.com/photo-1519938504322-49904910c363?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1519938504322-49904910c363?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"阅读安全内参,学习 JavaScript 理论知识,加深对 JavaScript 的了解,提高熟练度,巩固基础.话说回来,本来打算接着看你不知道的 JavaScript,结果作者说写第二版,行吧,先不看,先等第二版出来再说."}},"__N_SSG":true}
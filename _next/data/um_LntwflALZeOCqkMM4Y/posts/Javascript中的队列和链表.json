{"pageProps":{"post":{"slug":"Javascript中的队列和链表","contentHtml":"<p>长话短说,本文将队列和链表的知识合二为一.通过一些示例再次巩固这部分的知识.大概内容分为:</p>\n<ul>\n<li>\n<p>简单队列</p>\n</li>\n<li>\n<p>双端队列</p>\n</li>\n<li>\n<p>队列应用</p>\n<ul>\n<li>击鼓传花</li>\n<li>回文字检查</li>\n</ul>\n</li>\n<li>\n<p>单向链表</p>\n</li>\n<li>\n<p>双向链表</p>\n</li>\n<li>\n<p>循环链表</p>\n</li>\n<li>\n<p>排序链表</p>\n</li>\n</ul>\n<h1>队列</h1>\n<p>队列,先进先出.排过队吗?按顺序添加和处理的任务,都可以用<code>队列</code>的结构进行存储和消费.</p>\n<pre><code><span><span>class</span> <span>Queue</span> </span>{\n<span class=\"lineNumber\">2</span>  <span>constructor</span> (<span></span>) {\n<span class=\"lineNumber\">3</span>    <span>this</span>._items = {}\n<span class=\"lineNumber\">4</span>    <span>this</span>._count = <span>0</span>\n<span class=\"lineNumber\">5</span>    <span>this</span>._lowestCount = <span>0</span>\n<span class=\"lineNumber\">6</span>  }\n<span class=\"lineNumber\">7</span> \n<span class=\"lineNumber\">8</span>  <span><span>enqueue</span>(<span>e</span>)</span> {\n<span class=\"lineNumber\">9</span>    <span>this</span>._items[<span>this</span>._count] = e\n<span class=\"lineNumber\">10</span>    <span>this</span>._count++\n<span class=\"lineNumber\">11</span>  }\n<span class=\"lineNumber\">12</span>  <span><span>dequeue</span>(<span></span>)</span> {\n<span class=\"lineNumber\">13</span>    <span>if</span>(<span>this</span>.isEmpty()) <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">14</span>    <span>const</span> r = <span>this</span>._items[<span>this</span>._lowestCount]\n<span class=\"lineNumber\">15</span>    <span>delete</span> <span>this</span>._items[<span>this</span>._lowestCount]\n<span class=\"lineNumber\">16</span>    <span>this</span>._lowestCount += <span>1</span>\n<span class=\"lineNumber\">17</span>    <span>return</span> r\n<span class=\"lineNumber\">18</span>  }\n<span class=\"lineNumber\">19</span> \n<span class=\"lineNumber\">20</span>  <span><span>isEmpty</span>(<span></span>)</span> {\n<span class=\"lineNumber\">21</span>    <span>return</span> <span>this</span>._lowestCount === <span>this</span>._count\n<span class=\"lineNumber\">22</span>  }\n<span class=\"lineNumber\">23</span>  <span><span>peek</span>(<span></span>)</span> {\n<span class=\"lineNumber\">24</span>    <span>return</span> <span>this</span>.isEmpty()  ? <span>undefined</span> : <span>this</span>._items[<span>this</span>._lowestCount]\n<span class=\"lineNumber\">25</span>  }\n<span class=\"lineNumber\">26</span> \n<span class=\"lineNumber\">27</span>  <span><span>size</span>(<span></span>)</span> {\n<span class=\"lineNumber\">28</span>    <span>return</span> <span>this</span>._count - <span>this</span>._lowestCount\n<span class=\"lineNumber\">29</span>  }\n<span class=\"lineNumber\">30</span> \n<span class=\"lineNumber\">31</span>  <span><span>clear</span>(<span></span>)</span> {\n<span class=\"lineNumber\">32</span>    <span>this</span>._items = {}\n<span class=\"lineNumber\">33</span>    <span>this</span>._count = <span>0</span>\n<span class=\"lineNumber\">34</span>    <span>this</span>._lowestCount = <span>0</span>\n<span class=\"lineNumber\">35</span>  }\n<span class=\"lineNumber\">36</span>  <span><span>toString</span>(<span></span>)</span> {\n<span class=\"lineNumber\">37</span>    <span>if</span>(<span>this</span>.isEmpty()) <span>return</span> <span>''</span>\n<span class=\"lineNumber\">38</span>    <span>let</span> r = <span>''</span>\n<span class=\"lineNumber\">39</span>    <span>for</span> (<span>const</span> iterator <span>of</span> <span>Object</span>.values(<span>this</span>._items)) {\n<span class=\"lineNumber\">40</span>      r += r === <span>''</span> ? <span>`<span>${iterator}</span>`</span> : <span>`, <span>${iterator}</span>`</span>\n<span class=\"lineNumber\">41</span>    }\n<span class=\"lineNumber\">42</span>    <span>return</span> r\n<span class=\"lineNumber\">43</span>  }\n<span class=\"lineNumber\">44</span>}\n<span class=\"lineNumber\">45</span> \n<span class=\"lineNumber\">46</span><span>let</span> a = <span>new</span> Queue()\n<span class=\"lineNumber\">47</span><span>console</span>.log(a.isEmpty())\n<span class=\"lineNumber\">48</span>a.enqueue(<span>1</span>)\n<span class=\"lineNumber\">49</span>a.enqueue(<span>'just for fun'</span>)\n<span class=\"lineNumber\">50</span><span>console</span>.log(a.toString())\n<span class=\"lineNumber\">51</span>a.clear()\n<span class=\"lineNumber\">52</span><span>console</span>.log(a.toString())</code></pre> \n\n<p>普通队列简单,但是有些场景需要对最新入队的元素进行操作.例如,针对需要存储一系列操作的需求.此时,需要灵活处理队首和队尾的数据内容.</p>\n<p>当引发撤销操作的时候,操作队列可以从尾部弹出最后的操作记录.</p>\n<p>我们需要双端队列.</p>\n<pre><code><span><span>class</span> <span>Deque</span> <span>extends</span> <span>Queue</span></span>{\n<span class=\"lineNumber\">2</span>  <span>constructor</span> (<span></span>) {\n<span class=\"lineNumber\">3</span>    <span>super</span>()\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span><span>addFront</span>(<span>e</span>)</span> {\n<span class=\"lineNumber\">6</span>    <span>if</span>(<span>this</span>.isEmpty()) {\n<span class=\"lineNumber\">7</span>      <span>this</span>.enqueue(e)\n<span class=\"lineNumber\">8</span>    } <span>else</span> <span>if</span>(<span>this</span>._lowestCount > <span>0</span>) {\n<span class=\"lineNumber\">9</span>      <span>this</span>._lowestCount--      \n<span class=\"lineNumber\">10</span>      <span>this</span>._items[<span>this</span>._lowestCount] = e\n<span class=\"lineNumber\">11</span>    } <span>else</span> {\n<span class=\"lineNumber\">12</span>      <span>for</span> (<span>let</span> i = <span>this</span>._count;i><span>0</span>;i--) {\n<span class=\"lineNumber\">13</span>        <span>// 往后移动一位</span>\n<span class=\"lineNumber\">14</span>        <span>this</span>._items[i] = <span>this</span>._items[i - <span>1</span>]\n<span class=\"lineNumber\">15</span>      }\n<span class=\"lineNumber\">16</span>      <span>this</span>._count++\n<span class=\"lineNumber\">17</span>      <span>this</span>._lowestCount = <span>0</span>\n<span class=\"lineNumber\">18</span>      <span>this</span>._items[<span>0</span>] = e\n<span class=\"lineNumber\">19</span>    }\n<span class=\"lineNumber\">20</span>  }\n<span class=\"lineNumber\">21</span>\t<span>// 从队尾出队</span>\n<span class=\"lineNumber\">22</span>  <span><span>removeBack</span>(<span></span>)</span> {\n<span class=\"lineNumber\">23</span>    <span>if</span>(<span>this</span>.isEmpty()) <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">24</span>    <span>const</span> lastOne = <span>this</span>._items[<span>this</span>._count - <span>1</span>]\n<span class=\"lineNumber\">25</span>    <span>if</span>(<span>this</span>.size() === <span>1</span>) {\n<span class=\"lineNumber\">26</span>      <span>this</span>.clear()\n<span class=\"lineNumber\">27</span>    }\n<span class=\"lineNumber\">28</span>    <span>delete</span> <span>this</span>._items[<span>this</span>._count - <span>1</span>]\n<span class=\"lineNumber\">29</span>    <span>this</span>._count--\n<span class=\"lineNumber\">30</span>    <span>return</span> lastOne\n<span class=\"lineNumber\">31</span>  }\n<span class=\"lineNumber\">32</span> \n<span class=\"lineNumber\">33</span>  <span><span>peekBack</span>(<span></span>)</span> {\n<span class=\"lineNumber\">34</span>    <span>return</span> <span>this</span>._items[<span>this</span>._count]\n<span class=\"lineNumber\">35</span>  }\n<span class=\"lineNumber\">36</span>}</code></pre> \n\n<p>其他方法继承于<code>Queue</code>,可以实现双端数据操作.</p>\n<p>现在,让我们来模拟<code>击鼓传花</code>问题.</p>\n<blockquote>\n<p><em>班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。这个时候某个人（比方班长），在击鼓，鼓声停下的一刻，花落在谁手里，谁就进去表演节目</em>.</p>\n</blockquote>\n<pre><code><span>let</span> a = <span>new</span> Queue();\n<span class=\"lineNumber\">2</span>[<span>'杜小帅'</span>, <span>'高海'</span>, <span>'董文武'</span>, <span>'雪儿'</span>, <span>'洛克斯'</span>, <span>'庄杯'</span>, <span>'K'</span>].forEach(<span><span>i</span> =></span> a.enqueue(i));\n<span class=\"lineNumber\">3</span><span>let</span> createANum =  <span>() =></span> <span>Math</span>.random().toFixed(<span>1</span>) * <span>10</span>\n<span class=\"lineNumber\">4</span><span><span>function</span> <span>start</span>(<span>queue</span>) </span>{\n<span class=\"lineNumber\">5</span>  <span>if</span>(queue.size() === <span>1</span>) {\n<span class=\"lineNumber\">6</span>    <span>console</span>.log(<span>`现场唯一的观众: <span>${queue.dequeue()}</span>`</span>);\n<span class=\"lineNumber\">7</span>  } <span>else</span> {\n<span class=\"lineNumber\">8</span>    <span>if</span>(createANum() > <span>7</span>) {\n<span class=\"lineNumber\">9</span>      <span>console</span>.log(<span>`<span>${a.dequeue()}</span>, 请开始你的表演.`</span>);\n<span class=\"lineNumber\">10</span>    } <span>else</span> {\n<span class=\"lineNumber\">11</span>      queue.enqueue(queue.dequeue())\n<span class=\"lineNumber\">12</span>    }\n<span class=\"lineNumber\">13</span>  }\n<span class=\"lineNumber\">14</span>}\n<span class=\"lineNumber\">15</span><span>while</span>(a.size() >= <span>1</span>) {\n<span class=\"lineNumber\">16</span>  start(a)\n<span class=\"lineNumber\">17</span>}\n<span class=\"lineNumber\">18</span> \n<span class=\"lineNumber\">19</span><span>// output</span>\n<span class=\"lineNumber\">20</span><span>// 庄杯, 请开始你的表演.</span>\n<span class=\"lineNumber\">21</span><span>// 董文武, 请开始你的表演.</span>\n<span class=\"lineNumber\">22</span><span>// 高海, 请开始你的表演.</span>\n<span class=\"lineNumber\">23</span><span>// 杜小帅, 请开始你的表演.</span>\n<span class=\"lineNumber\">24</span><span>// 我, 请开始你的表演.</span>\n<span class=\"lineNumber\">25</span><span>// 洛克斯, 请开始你的表演.</span>\n<span class=\"lineNumber\">26</span><span>// 现场唯一的观众: 雪儿</span></code></pre> \n\n<p>接下来是回文检查,什么是回文字?</p>\n<blockquote>\n<p>回文是指正反序都相等的字符串序列,例如 <code>lol</code>,<code>madam</code>等等.</p>\n</blockquote>\n<p>最简单的方式就是使用双端队列来处理这个问题.</p>\n<pre><code><span><span>function</span> <span>palindromeCheaker</span>(<span>str</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span>if</span>(str === <span>undefined</span> || str === <span>''</span> || str === <span>null</span>) <span>return</span> <span>false</span>;\n<span class=\"lineNumber\">3</span>  <span>const</span> deque = <span>new</span> Deque();\n<span class=\"lineNumber\">4</span>  [...str].forEach(<span><span>i</span> =></span> deque.enqueue(i));\n<span class=\"lineNumber\">5</span>  <span>while</span>(deque.size() > <span>1</span>) {\n<span class=\"lineNumber\">6</span>    <span>if</span>(deque.removeBack() !== deque.dequeue()) <span>return</span> <span>false</span>\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span>return</span> <span>true</span>\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span> \n<span class=\"lineNumber\">11</span><span>console</span>.log(palindromeCheaker(<span>'121'</span>), palindromeCheaker(<span>'madam'</span>), palindromeCheaker(<span>'jay'</span>))\n<span class=\"lineNumber\">12</span><span>// output</span>\n<span class=\"lineNumber\">13</span><span>// true, true, false</span></code></pre> \n\n<p>JavaScript 任务也使用了队列这种数据结构.详情可以看看:</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33058983\">详解JavaScript中的Event Loop（事件循环）机制 - 知乎</a></p>\n<h1>链表</h1>\n<p>存储多个元素,数组可能是最常用的数据结构,如果需要从起点或者中间插入元素,数组的操作成本很高.尽管<code>JavaScript</code>数组支持了一些方法来做这些事,但是背后的情况同样如此.</p>\n<blockquote>\n<p>数组的元素在内存中是连续的,链表则可以是不连续的,链表的关键是使用节点的属性保存下一个或者上一个链表的信息.</p>\n</blockquote>\n<p>相比于传统数组,链表添加或者移除一个元素不需要移动其他元素,大大降低了内存成本.</p>\n<p><img src=\"https://pic2.zhimg.com/v2-8158f5bef33b4d38c0ff43d11139a003_1440w.jpg?source=172ae18b\" alt=\"\"></p>\n<p>上图是从网上随便找的示意图.观察可以发现,如果要找到某个节点,需要从<code>head</code>一路往下查找.让我们来实现这一数据结构.</p>\n<pre><code><span><span>class</span> <span>LinkedList</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span>this</span>.count = <span>0</span>;\n<span class=\"lineNumber\">4</span>    <span>this</span>.head = <span>undefined</span>;\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span>  <span><span>push</span>(<span>e</span>)</span> {\n<span class=\"lineNumber\">8</span>    <span>const</span> element = <span>new</span> Node(e)\n<span class=\"lineNumber\">9</span>    <span>this</span>.count++\n<span class=\"lineNumber\">10</span>    <span>if</span> (<span>this</span>.head === <span>undefined</span>) {\n<span class=\"lineNumber\">11</span>      <span>this</span>.head = element\n<span class=\"lineNumber\">12</span>    } <span>else</span> {\n<span class=\"lineNumber\">13</span>      <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">14</span>      <span>while</span> (current.next) {\n<span class=\"lineNumber\">15</span>        current = current.next\n<span class=\"lineNumber\">16</span>      }\n<span class=\"lineNumber\">17</span>      current.next = element\n<span class=\"lineNumber\">18</span>    }\n<span class=\"lineNumber\">19</span>  }\n<span class=\"lineNumber\">20</span>  <span>/**\n<span class=\"lineNumber\">21</span>   * \n<span class=\"lineNumber\">22</span>   * <span>@param <span>{number}</span> </span>index 返回删除节点的 element\n<span class=\"lineNumber\">23</span>   */</span>\n<span class=\"lineNumber\">24</span>  <span><span>removeAt</span>(<span>index</span>)</span> {\n<span class=\"lineNumber\">25</span>    <span>if</span> (index >= <span>0</span> &#x26;&#x26; index &#x3C; <span>this</span>.count) {\n<span class=\"lineNumber\">26</span>      <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">27</span>      <span>if</span> (index == <span>0</span>) {\n<span class=\"lineNumber\">28</span>        <span>this</span>.head = current.next\n<span class=\"lineNumber\">29</span>      } <span>else</span> {\n<span class=\"lineNumber\">30</span>        <span>let</span> prev = <span>this</span>.getElementByIndex(index - <span>1</span>)\n<span class=\"lineNumber\">31</span>        current = prev.next\n<span class=\"lineNumber\">32</span>        prev.next = current.next\n<span class=\"lineNumber\">33</span>      }\n<span class=\"lineNumber\">34</span>      <span>this</span>.count--\n<span class=\"lineNumber\">35</span>      <span>return</span> current.element\n<span class=\"lineNumber\">36</span>    } <span>else</span> {\n<span class=\"lineNumber\">37</span>      <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">38</span>    }\n<span class=\"lineNumber\">39</span>  }\n<span class=\"lineNumber\">40</span> \n<span class=\"lineNumber\">41</span>  <span><span>removeValue</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">42</span>    <span>const</span> index = <span>this</span>.indexOf(element)\n<span class=\"lineNumber\">43</span>    <span>return</span> <span>this</span>.removeAt(index)\n<span class=\"lineNumber\">44</span>  }\n<span class=\"lineNumber\">45</span> \n<span class=\"lineNumber\">46</span>  <span><span>getElementByIndex</span>(<span>index</span>)</span> {\n<span class=\"lineNumber\">47</span>    <span>if</span> (index >= <span>0</span> &#x26;&#x26; index &#x3C; <span>this</span>.count) {\n<span class=\"lineNumber\">48</span>      <span>let</span> node = <span>this</span>.head\n<span class=\"lineNumber\">49</span>      <span>for</span> (<span>let</span> i = <span>0</span>; i &#x3C; index &#x26;&#x26; node !== <span>null</span>; i++) {\n<span class=\"lineNumber\">50</span>        node = node.next\n<span class=\"lineNumber\">51</span>      }\n<span class=\"lineNumber\">52</span>      <span>return</span> node\n<span class=\"lineNumber\">53</span>    } <span>else</span> {\n<span class=\"lineNumber\">54</span>      <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">55</span>    }\n<span class=\"lineNumber\">56</span>  }\n<span class=\"lineNumber\">57</span> \n<span class=\"lineNumber\">58</span>  <span><span>insert</span>(<span>element, index</span>)</span> {\n<span class=\"lineNumber\">59</span>    <span>if</span> (index >= <span>0</span> &#x26;&#x26; index &#x3C;= <span>this</span>.count) {\n<span class=\"lineNumber\">60</span>      <span>const</span> node = <span>new</span> Node(element)\n<span class=\"lineNumber\">61</span>      <span>if</span> (<span>this</span>.count === <span>0</span>) {\n<span class=\"lineNumber\">62</span>        <span>this</span>.head = node\n<span class=\"lineNumber\">63</span>      } <span>else</span> {\n<span class=\"lineNumber\">64</span>        <span>let</span> prev = <span>this</span>.getElementByIndex(index - <span>1</span>)\n<span class=\"lineNumber\">65</span>        node.next = prev.next\n<span class=\"lineNumber\">66</span>        prev.next = node\n<span class=\"lineNumber\">67</span>      }\n<span class=\"lineNumber\">68</span>      <span>this</span>.count++\n<span class=\"lineNumber\">69</span>    } <span>else</span> {\n<span class=\"lineNumber\">70</span>      <span>return</span> <span>false</span>\n<span class=\"lineNumber\">71</span>    }\n<span class=\"lineNumber\">72</span>  }\n<span class=\"lineNumber\">73</span> \n<span class=\"lineNumber\">74</span>  <span>/**\n<span class=\"lineNumber\">75</span>   * \n<span class=\"lineNumber\">76</span>   * <span>@param <span>{any}</span> </span>element search a element, return a index\n<span class=\"lineNumber\">77</span>   */</span>\n<span class=\"lineNumber\">78</span>  <span><span>indexOf</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">79</span>    <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">80</span>    <span>let</span> index = <span>0</span>\n<span class=\"lineNumber\">81</span>    <span>while</span> (current) {\n<span class=\"lineNumber\">82</span>      <span>if</span> (current.element !== element) {\n<span class=\"lineNumber\">83</span>        current = current.next\n<span class=\"lineNumber\">84</span>        index++\n<span class=\"lineNumber\">85</span>      } <span>else</span> {\n<span class=\"lineNumber\">86</span>        <span>return</span> index\n<span class=\"lineNumber\">87</span>      }\n<span class=\"lineNumber\">88</span>    }\n<span class=\"lineNumber\">89</span>    <span>return</span> -<span>1</span>\n<span class=\"lineNumber\">90</span>  }\n<span class=\"lineNumber\">91</span> \n<span class=\"lineNumber\">92</span>  <span><span>isEmpty</span>(<span></span>)</span> {\n<span class=\"lineNumber\">93</span>    <span>return</span> <span>this</span>.count === <span>0</span>\n<span class=\"lineNumber\">94</span>  }\n<span class=\"lineNumber\">95</span> \n<span class=\"lineNumber\">96</span>  <span><span>size</span>(<span></span>)</span> {\n<span class=\"lineNumber\">97</span>    <span>return</span> <span>this</span>.count\n<span class=\"lineNumber\">98</span>  }\n<span class=\"lineNumber\">99</span> \n<span class=\"lineNumber\">100</span>  <span><span>getHead</span>(<span></span>)</span> {\n<span class=\"lineNumber\">101</span>    <span>return</span> <span>this</span>.head\n<span class=\"lineNumber\">102</span>  }\n<span class=\"lineNumber\">103</span> \n<span class=\"lineNumber\">104</span>  <span><span>toString</span>(<span></span>)</span> {\n<span class=\"lineNumber\">105</span>    <span>if</span> (<span>this</span>.count === <span>0</span>) {\n<span class=\"lineNumber\">106</span>      <span>return</span> <span>''</span>\n<span class=\"lineNumber\">107</span>    }\n<span class=\"lineNumber\">108</span>    <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">109</span>    <span>while</span> (current.next !== <span>undefined</span>) {\n<span class=\"lineNumber\">110</span>      <span>console</span>.log(current.element);\n<span class=\"lineNumber\">111</span>      current = current.next\n<span class=\"lineNumber\">112</span>    }\n<span class=\"lineNumber\">113</span>    <span>console</span>.log(current.element);\n<span class=\"lineNumber\">114</span>  }\n<span class=\"lineNumber\">115</span>}\n<span class=\"lineNumber\">116</span> \n<span class=\"lineNumber\">117</span><span><span>class</span> <span>Node</span> </span>{\n<span class=\"lineNumber\">118</span>  <span><span>constructor</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">119</span>    <span>this</span>.element = element;\n<span class=\"lineNumber\">120</span>    <span>this</span>.next = <span>undefined</span>;\n<span class=\"lineNumber\">121</span>  }\n<span class=\"lineNumber\">122</span>}</code></pre> \n\n<p>来思考一个算法题目,翻转链表:</p>\n<blockquote>\n<p>题意：反转一个单链表。</p>\n<p>示例: 输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL</p>\n</blockquote>\n<p>直接翻转指针,可以避免多余的链表创建和内存占用.</p>\n<pre><code><span>// data is a LinkedList</span>\n<span class=\"lineNumber\">2</span><span><span>function</span> <span>reverseLinkList</span>(<span>data</span>) </span>{\n<span class=\"lineNumber\">3</span>  <span>if</span> (data.size() > <span>1</span>) {\n<span class=\"lineNumber\">4</span>    <span>let</span> current = data.head\n<span class=\"lineNumber\">5</span>    <span>let</span> prev = <span>undefined</span>\n<span class=\"lineNumber\">6</span>    <span>let</span> next = <span>undefined</span>\n<span class=\"lineNumber\">7</span>    <span>while</span> (current !== <span>undefined</span>) {\n<span class=\"lineNumber\">8</span>      next = current.next;\n<span class=\"lineNumber\">9</span>      current.next = prev;\n<span class=\"lineNumber\">10</span>      prev = current\n<span class=\"lineNumber\">11</span>      current = next\n<span class=\"lineNumber\">12</span>    }\n<span class=\"lineNumber\">13</span>    data.head = prev\n<span class=\"lineNumber\">14</span>    <span>return</span> data\n<span class=\"lineNumber\">15</span>  } <span>else</span> {\n<span class=\"lineNumber\">16</span>    <span>return</span> data\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span>}</code></pre> \n\n<p>接着,看看<code>双向链表</code>:</p>\n<pre><code><span><span>class</span> <span>DoublyNode</span> <span>extends</span> <span>Node</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span>element, prev = <span>undefined</span>, next = <span>undefined</span></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span>super</span>(element, next)\n<span class=\"lineNumber\">4</span>    <span>this</span>.prev = prev;\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span>}\n<span class=\"lineNumber\">7</span> \n<span class=\"lineNumber\">8</span><span><span>class</span> <span>DoublyLinkedList</span> <span>extends</span> <span>LinkedList</span> </span>{\n<span class=\"lineNumber\">9</span>  <span><span>constructor</span>(<span></span>)</span> {\n<span class=\"lineNumber\">10</span>    <span>super</span>()\n<span class=\"lineNumber\">11</span>    <span>this</span>.tail = <span>undefined</span>;\n<span class=\"lineNumber\">12</span>  }\n<span class=\"lineNumber\">13</span>  <span><span>push</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">14</span>    <span>const</span> node = <span>new</span> DoublyNode(element)\n<span class=\"lineNumber\">15</span>    <span>if</span> (<span>this</span>.count === <span>0</span>) {\n<span class=\"lineNumber\">16</span>      <span>this</span>.head = node\n<span class=\"lineNumber\">17</span>      <span>this</span>.tail = node\n<span class=\"lineNumber\">18</span>    } <span>else</span> {\n<span class=\"lineNumber\">19</span>      <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">20</span>      <span>while</span> (current.next) {\n<span class=\"lineNumber\">21</span>        current = current.next\n<span class=\"lineNumber\">22</span>      }\n<span class=\"lineNumber\">23</span>      current.next = node\n<span class=\"lineNumber\">24</span>      node.prev = current\n<span class=\"lineNumber\">25</span>    }\n<span class=\"lineNumber\">26</span>    <span>this</span>.tail = node\n<span class=\"lineNumber\">27</span>    <span>this</span>.count++\n<span class=\"lineNumber\">28</span>  }\n<span class=\"lineNumber\">29</span>  <span><span>insert</span>(<span>element, index</span>)</span> {\n<span class=\"lineNumber\">30</span>    <span>const</span> node = <span>new</span> DoublyNode(element)\n<span class=\"lineNumber\">31</span>    <span>if</span> (index >= <span>0</span> &#x26;&#x26; index &#x3C;= <span>this</span>.count) {\n<span class=\"lineNumber\">32</span>      <span>if</span> (<span>this</span>.count === <span>0</span>) {\n<span class=\"lineNumber\">33</span>        <span>this</span>.head = node\n<span class=\"lineNumber\">34</span>        <span>this</span>.tail = node\n<span class=\"lineNumber\">35</span>      } <span>else</span> {\n<span class=\"lineNumber\">36</span>        <span>let</span> oldNode = <span>this</span>.getElementByIndex(index)\n<span class=\"lineNumber\">37</span>        <span>console</span>.log(oldNode.element, <span>'is old node'</span>);\n<span class=\"lineNumber\">38</span>        <span>// 新插入节点设置了前后节点</span>\n<span class=\"lineNumber\">39</span>        node.next = oldNode\n<span class=\"lineNumber\">40</span>        node.prev = oldNode.prev\n<span class=\"lineNumber\">41</span>        <span>// 旧的节点设置了 prev</span>\n<span class=\"lineNumber\">42</span>        oldNode.prev = node\n<span class=\"lineNumber\">43</span>        <span>if</span> (node.prev) {\n<span class=\"lineNumber\">44</span>          <span>// 如果前节点存在</span>\n<span class=\"lineNumber\">45</span>          node.prev.next = node\n<span class=\"lineNumber\">46</span>        } <span>else</span> {\n<span class=\"lineNumber\">47</span>          <span>// 不存在则说明插入的是链表头</span>\n<span class=\"lineNumber\">48</span>          <span>this</span>.head = node\n<span class=\"lineNumber\">49</span>        }\n<span class=\"lineNumber\">50</span>      }\n<span class=\"lineNumber\">51</span>      <span>this</span>.count++\n<span class=\"lineNumber\">52</span>      <span>return</span> <span>true</span>\n<span class=\"lineNumber\">53</span>    }\n<span class=\"lineNumber\">54</span>    <span>return</span> <span>false</span>\n<span class=\"lineNumber\">55</span>  }\n<span class=\"lineNumber\">56</span>  <span><span>getTail</span>(<span></span>)</span> {\n<span class=\"lineNumber\">57</span>    <span>return</span> <span>this</span>.tail\n<span class=\"lineNumber\">58</span>  }\n<span class=\"lineNumber\">59</span>  <span>/**\n<span class=\"lineNumber\">60</span>   * \n<span class=\"lineNumber\">61</span>   * <span>@param <span>{number}</span> </span>index 1. 链表长为 1\n<span class=\"lineNumber\">62</span>   * 2. 长不为 1 => 1.删除首个元素/ 2.删除最后元素 / 3.删除中间元素\n<span class=\"lineNumber\">63</span>   */</span>\n<span class=\"lineNumber\">64</span>  <span><span>removeAt</span>(<span>index</span>)</span> {\n<span class=\"lineNumber\">65</span>    <span>const</span> node = <span>this</span>.getElementByIndex(index)\n<span class=\"lineNumber\">66</span>    <span>// 空链表和无效 index</span>\n<span class=\"lineNumber\">67</span>    <span>if</span> (<span>this</span>.count === <span>0</span> &#x26;&#x26; node === <span>undefined</span>) <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">68</span> \n<span class=\"lineNumber\">69</span>    <span>// 链长 1,删除 1</span>\n<span class=\"lineNumber\">70</span>    <span>if</span> (<span>this</span>.count === <span>1</span> &#x26;&#x26; node === <span>this</span>.head) {\n<span class=\"lineNumber\">71</span>      <span>this</span>.head = <span>undefined</span>\n<span class=\"lineNumber\">72</span>      <span>this</span>.tail = <span>undefined</span>\n<span class=\"lineNumber\">73</span>      <span>this</span>.count = <span>0</span>\n<span class=\"lineNumber\">74</span>      <span>return</span> node\n<span class=\"lineNumber\">75</span>    }\n<span class=\"lineNumber\">76</span>    <span>// 链长不为 1</span>\n<span class=\"lineNumber\">77</span>    <span>// index 对应的 node 有效</span>\n<span class=\"lineNumber\">78</span>    <span>if</span> (node === <span>this</span>.head) {\n<span class=\"lineNumber\">79</span>      <span>this</span>.head = node.next\n<span class=\"lineNumber\">80</span>    } <span>else</span> <span>if</span> (node === <span>this</span>.tail) {\n<span class=\"lineNumber\">81</span>      node.prev.next = <span>undefined</span>\n<span class=\"lineNumber\">82</span>      <span>this</span>.tail = node.prev\n<span class=\"lineNumber\">83</span>    } <span>else</span> {\n<span class=\"lineNumber\">84</span>      node.prev.next = node.next\n<span class=\"lineNumber\">85</span>      node.next.prev = node.prev\n<span class=\"lineNumber\">86</span>    }\n<span class=\"lineNumber\">87</span>    <span>this</span>.count--\n<span class=\"lineNumber\">88</span>    <span>return</span> node\n<span class=\"lineNumber\">89</span>  }\n<span class=\"lineNumber\">90</span>}</code></pre> \n\n<p>双向链表增加了<code>tail</code>属性,保存了链表尾部元素,且对每个节点的结构,增加了<code>prev</code>属性保存前一个节点信息.</p>\n<p>下面看看<code>双向循环链表</code>,其跟双向链表的区别在于,对首个元素的<code>prev</code>设置为最后一个元素.最后一个元素的<code>next</code>设置为首个元素.因此,需要稍微调整代码结构.</p>\n<pre><code><span><span>class</span> <span>LoopDoublyLinkedList</span> <span>extends</span> <span>DoublyLinkedList</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span>super</span>()\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span><span>push</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">6</span>    <span>const</span> node = <span>new</span> DoublyNode(element)\n<span class=\"lineNumber\">7</span>    <span>if</span> (<span>this</span>.count === <span>0</span>) {\n<span class=\"lineNumber\">8</span>      <span>this</span>.head = node\n<span class=\"lineNumber\">9</span>      <span>this</span>.tail = node\n<span class=\"lineNumber\">10</span>      node.prev = node\n<span class=\"lineNumber\">11</span>      node.next = node\n<span class=\"lineNumber\">12</span>    } <span>else</span> {\n<span class=\"lineNumber\">13</span>      <span>// 新节点的头和尾部改一下</span>\n<span class=\"lineNumber\">14</span>      node.next = <span>this</span>.head\n<span class=\"lineNumber\">15</span>      node.prev = <span>this</span>.tail\n<span class=\"lineNumber\">16</span>      <span>this</span>.tail.next = node\n<span class=\"lineNumber\">17</span>      <span>this</span>.head.prev = node\n<span class=\"lineNumber\">18</span>      <span>this</span>.tail = node\n<span class=\"lineNumber\">19</span>    }\n<span class=\"lineNumber\">20</span>    <span>this</span>.count++\n<span class=\"lineNumber\">21</span>  }\n<span class=\"lineNumber\">22</span> \n<span class=\"lineNumber\">23</span>  <span><span>removeAt</span>(<span>index</span>)</span> {\n<span class=\"lineNumber\">24</span>    <span>const</span> node = <span>this</span>.getElementByIndex(index)\n<span class=\"lineNumber\">25</span>    <span>if</span> (node) {\n<span class=\"lineNumber\">26</span>      <span>if</span> (<span>this</span>.count === <span>1</span>) {\n<span class=\"lineNumber\">27</span>        <span>this</span>.clear()\n<span class=\"lineNumber\">28</span>      } <span>else</span> {\n<span class=\"lineNumber\">29</span>        <span>let</span> prev = node.prev\n<span class=\"lineNumber\">30</span>        <span>let</span> next = node.next\n<span class=\"lineNumber\">31</span>        prev.next = next\n<span class=\"lineNumber\">32</span>        next.prev = prev\n<span class=\"lineNumber\">33</span>        <span>this</span>.count--\n<span class=\"lineNumber\">34</span>      }\n<span class=\"lineNumber\">35</span>      <span>return</span> node\n<span class=\"lineNumber\">36</span>    } <span>else</span> {\n<span class=\"lineNumber\">37</span>      <span>return</span> <span>undefined</span>\n<span class=\"lineNumber\">38</span>    }\n<span class=\"lineNumber\">39</span>  }\n<span class=\"lineNumber\">40</span>  <span><span>insert</span>(<span>element, index</span>)</span> {\n<span class=\"lineNumber\">41</span>    <span>const</span> node = <span>new</span> DoublyNode(element)\n<span class=\"lineNumber\">42</span>    <span>let</span> targetNode = <span>this</span>.getElementByIndex(index)\n<span class=\"lineNumber\">43</span>    <span>if</span> (targetNode === <span>undefined</span>) <span>return</span> <span>false</span>\n<span class=\"lineNumber\">44</span> \n<span class=\"lineNumber\">45</span>    <span>// 确定了插入位置</span>\n<span class=\"lineNumber\">46</span>    <span>if</span> (index === <span>0</span>) {\n<span class=\"lineNumber\">47</span>      <span>// 插入表头</span>\n<span class=\"lineNumber\">48</span>      node.next = <span>this</span>.head.next\n<span class=\"lineNumber\">49</span>      node.prev = <span>this</span>.tail\n<span class=\"lineNumber\">50</span>      <span>this</span>.head.prev = node\n<span class=\"lineNumber\">51</span>      <span>this</span>.head = node\n<span class=\"lineNumber\">52</span>      <span>this</span>.tail.next = node\n<span class=\"lineNumber\">53</span>    } <span>else</span> {\n<span class=\"lineNumber\">54</span>      node.prev = targetNode.prev\n<span class=\"lineNumber\">55</span>      node.next = targetNode\n<span class=\"lineNumber\">56</span>      targetNode.prev.next = node\n<span class=\"lineNumber\">57</span>      targetNode.prev = node\n<span class=\"lineNumber\">58</span>    }\n<span class=\"lineNumber\">59</span>    <span>this</span>.count++\n<span class=\"lineNumber\">60</span>  }\n<span class=\"lineNumber\">61</span>  <span><span>clear</span>(<span></span>)</span> {\n<span class=\"lineNumber\">62</span>    <span>this</span>.head = <span>undefined</span>\n<span class=\"lineNumber\">63</span>    <span>this</span>.tail = <span>undefined</span>\n<span class=\"lineNumber\">64</span>    <span>this</span>.count = <span>0</span>\n<span class=\"lineNumber\">65</span>  }\n<span class=\"lineNumber\">66</span> \n<span class=\"lineNumber\">67</span>  <span><span>toString</span>(<span></span>)</span> {\n<span class=\"lineNumber\">68</span>    <span>if</span> (<span>this</span>.count === <span>0</span>) <span>return</span> <span>''</span>\n<span class=\"lineNumber\">69</span>    <span>let</span> current = <span>this</span>.head\n<span class=\"lineNumber\">70</span>    <span>// console.log(current.element);</span>\n<span class=\"lineNumber\">71</span>    <span>// console.log(current.next, this.head);</span>\n<span class=\"lineNumber\">72</span>    <span>while</span> (current !== <span>this</span>.tail) {\n<span class=\"lineNumber\">73</span>      <span>console</span>.log(current.element);\n<span class=\"lineNumber\">74</span>      current = current.next\n<span class=\"lineNumber\">75</span>    }\n<span class=\"lineNumber\">76</span>    <span>console</span>.log(current.element);\n<span class=\"lineNumber\">77</span>  }\n<span class=\"lineNumber\">78</span>}</code></pre> \n\n<p>双向循环链表的关键在于处理新节点的<code>prev</code>和<code>next</code>值,只要不是<code>空</code>链表,则每一个节点都有这两个值.</p>\n<p>接下来是<code>有序链表</code>.为了让节点之间保持顺序,我们可以修改<code>insert</code>方法,让插入的位置由内部计算得出.</p>\n<pre><code><span><span>class</span> <span>SortedLinkedList</span> <span>extends</span> <span>LinkedList</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span>super</span>()\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span><span>insert</span>(<span>element, index=<span>0</span></span>)</span> {\n<span class=\"lineNumber\">6</span>    <span>if</span>(<span>this</span>.isEmpty()) {\n<span class=\"lineNumber\">7</span>      <span>return</span> <span>super</span>.insert(element, <span>0</span>)\n<span class=\"lineNumber\">8</span>    }\n<span class=\"lineNumber\">9</span>    <span>// 自定义方法定义插入位置,用默认 index 代替 index 的效果.</span>\n<span class=\"lineNumber\">10</span>    <span>const</span> pos = <span>this</span>.getIndexNextSortedElement(element);\n<span class=\"lineNumber\">11</span>    <span>return</span> <span>super</span>.insert(element, pos)\n<span class=\"lineNumber\">12</span>  }\n<span class=\"lineNumber\">13</span>  \n<span class=\"lineNumber\">14</span>  <span><span>getIndexNextSortedElement</span>(<span>element</span>)</span> {\n<span class=\"lineNumber\">15</span>    <span>let</span> current = <span>this</span>.head;\n<span class=\"lineNumber\">16</span>    <span>let</span> i = <span>0</span>;\n<span class=\"lineNumber\">17</span>    <span>// 遍历,直接判断大小,也可以重新定义一个比较函数</span>\n<span class=\"lineNumber\">18</span>    <span>for</span>(;i &#x3C; <span>this</span>.size() &#x26;&#x26; current; i++) {\n<span class=\"lineNumber\">19</span>      <span>if</span>(current.element &#x3C; element) {\n<span class=\"lineNumber\">20</span>        <span>return</span> i\n<span class=\"lineNumber\">21</span>      }\n<span class=\"lineNumber\">22</span>      current = current.next\n<span class=\"lineNumber\">23</span>    }\n<span class=\"lineNumber\">24</span>    <span>return</span> i\n<span class=\"lineNumber\">25</span>  }\n<span class=\"lineNumber\">26</span>}</code></pre> \n\n<p>其他方法都是继承的,不需要改变.由于插入的位置程序内部通过特定的比较算法去判断,因此实现了链表的有序性.</p>\n<p>在操作和查找一个有序的链表的场景之下,可以使用不同的查找算法提高查找效率.</p>\n<blockquote>\n<p>我想把这些数据结构都保存到自己的工具库中去,因此需要暂时停止下一步:集合和散列表的学习.转向 webpack5 和 babel7 ,用于创建良好的环境,支持自己保存工具库和自己的数据结构.</p>\n<p>2021年01月13日00:27:40,晚安.</p>\n</blockquote>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/52878334\">数据结构与算法-链表(上) - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/52841915\">数据结构与算法-链表(下) - 知乎</a></li>\n</ul>\n","title":"Javascript中的队列和链表","date":"2021/1/7","tags":["JavaScript","数据结构与算法"],"mainImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"几年前在学校使用 c++ 进行数据结构与算法的学习.学得跟屎一样,丢人现眼.前段时间在飞机上看完了队列和链表部分的内容,还是觉得需要整理一下写成文章."}},"__N_SSG":true}
{"pageProps":{"post":{"slug":"实现一个Promise-A+规范的Promise类","contentHtml":"<p>各位订阅的小伙伴们早上好，今天我们来一起学习一下如何一步步实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>类。</p>\n<p>我在看《探索 ES6》这本书的时候，突然想要更深入理解 <code>Promise</code> 的设计理念和设计原理，于是我看了一些关于如何实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>实例的文章和介绍，搜索了一些相关的知识，也阅读了其他人的 <code>Promise</code>实现源码。</p>\n<p>结果令我很振奋，通过实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>类，我对<code>Promise</code>的理解有了不错的进步 😂。</p>\n<p>总结下来就是，优先学习<code>ES6 Promise</code>知识，然后再阅读<code>Promise/A+</code>规范和第三方开发者的<code>Promise</code>实现和知识分享，最后我们便可以依据<code>Promise/A+</code>的规范一步步创建我们自己的实现逻辑。</p>\n<p>那就废话少说，开始吧。</p>\n<h2>从规范到实现</h2>\n<p>在开始写代码之前，我们先阅读一下<a href=\"https://promisesaplus.com/\">Promises/A+</a>的官方文档。</p>\n<h4>几个术语</h4>\n<p>言而简之，官方文档上提及了五个术语，如下所示：</p>\n<ul>\n<li>Promise</li>\n<li>thenable</li>\n<li>value</li>\n<li>exception</li>\n<li>reason</li>\n</ul>\n<p><code>Promise</code>是一个具有<code>then</code>方法的对象或函数，并且此对象或者函数遵循<code>Promise/A+</code>规范。</p>\n<p><code>thenable</code>指的是一个对象或函数具有一个<code>then</code>方法</p>\n<p><code>value</code>是一个合法的<code>Javascript</code>值。</p>\n<p><code>exception</code>是一个使用<code>throw</code>语句抛出的值。</p>\n<p><code>reason</code>则是<code>Promise</code>状态转为<code>Rejected</code>的原因。</p>\n<h4>规范简述</h4>\n<p>阅读规范有助于我们编写代码，整理思路，最终写出一个能通过所有<code>Promise/A+</code>测试用例的<code>Promise</code>实现版本。</p>\n<h5>Promise State</h5>\n<ul>\n<li>\n<p>2.1.1 一个<code>Promise</code>的状态只有如下三种：</p>\n</li>\n<li>\n<p>pending 初始化状态</p>\n<ul>\n<li>2.1.1.1 可以显式转换状态至<code>fulfilled</code>或<code>rejected</code></li>\n</ul>\n</li>\n<li>\n<p>fulfilled 成功</p>\n<ul>\n<li>2.1.2.1 状态不可再转换</li>\n<li>2.1.2.2 具有一个不可改变的<code>value</code></li>\n</ul>\n</li>\n<li>\n<p>rejected 失败</p>\n<ul>\n<li>2.1.3.1 状态不可再转换</li>\n<li>2.1.3.2 具有一个不可改变的<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>不可改变意味着可以使用<code>===</code>进行比较，并且始终为<code>true</code>，并非完全的深层属性不可变。</p>\n</blockquote>\n<p>除此之外，使用<code>new</code>实例化的时候，我们需要为构造函数提供一个<code>executor</code>函数参数。</p>\n<h5>思考🤔</h5>\n<p>现在我们从最简单的状态需求开始，假设我们处于一个密闭空间，触手可及的只有手头的键盘。</p>\n<p>思考一下如何实现上述<code>Promise State</code>，用少量词汇组织将要写的代码的内容，例如：</p>\n<ul>\n<li>我的 Promise 实现命名为<code>Yo</code></li>\n<li><code>Yo</code>初始化的时候设置初始值和初始状态，状态可以转变为<code>fulfilled</code>或者<code>rejected</code>。</li>\n<li><code>Yi</code>具备两个静态方法来显式转换其状态：<code>fulfill</code>和<code>Reject</code>，当状态为<code>pending</code>时才执行逻辑，这样一来一旦状态改变后续再执行此方法就无碍了。</li>\n</ul>\n<blockquote>\n<p>注释里写明对应的规范信息条目</p>\n</blockquote>\n<p>很快，我们的实现如下：</p>\n<pre><code><span>// 将一些常用到的变量保存起来，</span>\n<span class=\"lineNumber\">2</span><span>const</span> PENDING = <span>'pending'</span>\n<span class=\"lineNumber\">3</span><span>const</span> FULFILLED = <span>'fulfilled'</span>\n<span class=\"lineNumber\">4</span><span>const</span> REJECTED = <span>'rejected'</span>\n<span class=\"lineNumber\">5</span><span>const</span> nop = <span>() =></span> {}\n<span class=\"lineNumber\">6</span><span>const</span> $undefined = <span>undefined</span>\n<span class=\"lineNumber\">7</span><span>const</span> $function = <span>\"function\"</span>\n<span class=\"lineNumber\">8</span><span>// 使用 Symbol 为 Promise 的属性提供保护</span>\n<span class=\"lineNumber\">9</span><span>const</span> promiseState = <span>Symbol</span>(<span>\"promiseState\"</span>)\n<span class=\"lineNumber\">10</span><span>const</span> promiseValue = <span>Symbol</span>(<span>\"promiseValue\"</span>)\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span><span><span>class</span> <span>Yo</span> </span>{\n<span class=\"lineNumber\">13</span>  <span><span>constructor</span>(<span>executor</span>)</span> {\n<span class=\"lineNumber\">14</span>    <span>// executor 提前检查，如果有异常则不创建额外的内部变量和属性方法，直接抛出异常</span>\n<span class=\"lineNumber\">15</span>    <span>if</span>(executor === $undefined) {\n<span class=\"lineNumber\">16</span>      <span>throw</span> <span>new</span> <span>TypeError</span>(<span>\"You have to give a executor param.\"</span>)\n<span class=\"lineNumber\">17</span>    }\n<span class=\"lineNumber\">18</span>    <span>if</span>(<span>typeof</span> executor !== $function) {\n<span class=\"lineNumber\">19</span>      <span>throw</span> <span>new</span> <span>TypeError</span>(<span>\"Executor must be a function.\"</span>)\n<span class=\"lineNumber\">20</span>    }\n<span class=\"lineNumber\">21</span>    <span>this</span>[promiseState] = PENDING <span>// 2.1.1</span>\n<span class=\"lineNumber\">22</span>    <span>this</span>[promiseValue] = $undefined\n<span class=\"lineNumber\">23</span>    <span>try</span> {\n<span class=\"lineNumber\">24</span>      executor(<span>this</span>.$resolve.bind(<span>this</span>), <span>this</span>.$reject.bind(<span>this</span>))\n<span class=\"lineNumber\">25</span>    } <span>catch</span> (e) {\n<span class=\"lineNumber\">26</span>      <span>this</span>.$reject.bind(<span>this</span>)(e)\n<span class=\"lineNumber\">27</span>    }\n<span class=\"lineNumber\">28</span>  }\n<span class=\"lineNumber\">29</span> \n<span class=\"lineNumber\">30</span>  $resolve(value) {\n<span class=\"lineNumber\">31</span>    <span>if</span>(<span>this</span>[promiseState] !== PENDING) <span>return</span> <span>// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">32</span>    <span>this</span>[promiseState] = FULFILLED <span>// 2.1.1.1</span>\n<span class=\"lineNumber\">33</span>    <span>this</span>[promiseValue] = value <span>// 2.1.2.2</span>\n<span class=\"lineNumber\">34</span>  }\n<span class=\"lineNumber\">35</span> \n<span class=\"lineNumber\">36</span>  $reject(reason) {\n<span class=\"lineNumber\">37</span>    <span>if</span>(<span>this</span>[promiseState] !== PENDING) <span>return</span> <span>// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">38</span>    <span>this</span>[promiseState] = REJECTED <span>// 2.1.1.1</span>\n<span class=\"lineNumber\">39</span>    <span>this</span>[promiseValue] = reason <span>// 2.1.3.2</span>\n<span class=\"lineNumber\">40</span>  }\n<span class=\"lineNumber\">41</span>}</code></pre> \n\n<h5><code>then</code>方法</h5>\n<blockquote>\n<p><code>then</code>方法是<code>Promise/A+</code>规范的核心部分。</p>\n</blockquote>\n<p>一个<code>Promise</code>必须提供一个<code>then</code>方法以访问其<code>value</code>或<code>reason</code>,此方法需要接受两个可选参数：</p>\n<pre><code>promise.then(onFulfilled, onRejected)</code></pre> \n\n<p>其规范如下：</p>\n<ul>\n<li>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选的\n<ul>\n<li>2.2.1.1 如果<code>onFulfilled</code>不是一个函数，则忽略此参数</li>\n<li>2.2.1.2 如果<code>onRejected</code>不是一个函数，则忽略此参数</li>\n</ul>\n</li>\n<li>2.2.2 如果<code>onFulfilled</code>是一个函数\n<ul>\n<li>2.2.2.1 此函数在<code>promise</code>状态为<code>fulfilled</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.2.2 此函数不可在<code>promise</code>状态为<code>fullfilled</code>之前被调用</li>\n<li>2.2.2.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.3 如果<code>onRejected</code>是一个函数\n<ul>\n<li>2.2.3.1 此函数在<code>promise</code>状态为<code>rejected</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.3.2 此函数不可在<code>promise</code>状态为<code>rejected</code>之前被调用</li>\n<li>2.2.3.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.4 <code>onFulfilled</code>和<code>onRejected</code>将被异步调用（在当前执行栈清空之前无法被调用）</li>\n<li>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为一个函数被调用（内部不应使用<code>this</code>值，原因在于严格模式和非严格模式的<code>this</code>值不一致）</li>\n<li>2.2.6 <code>then</code>可以在同一个<code>promise</code>实例上被多次调用，因此我们可以在不同的地方使用某个<code>promise.then</code>f方法\n<ul>\n<li>2.2.6.1 当<code>promise</code>状态为<code>fulfilled</code>时，所有的<code>then</code>上传入的<code>onFulfilled</code>函数将会按调用的次序依次执行</li>\n<li>2.2.6.2 当<code>promise</code>状态为<code>rejected</code>时，所有的<code>then</code>上传入的<code>onRejected</code>函数将会按调用的次序依次执行</li>\n</ul>\n</li>\n<li>2.2.7 <code>then</code>方法最终将返回一个新的<code>promise</code>实例: <code>promise2 = promise1.then(onFulfilled, onRejected)</code>\n<ul>\n<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个值<code>x</code>，执行<code>Promise</code>的解析步骤： <code>[[Resolve]](promise2, x)</code></li>\n<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>抛出一个异常<code>e</code>，则<code>promise2</code>直接<code>reject(e)</code></li>\n<li>2.2.7.3 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>fulfilled</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和值。</li>\n<li>2.2.7.4 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>rejected</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<h5>完善 ✍️</h5>\n<p>按规范的定义，在上述代码的基础下，我们来完善<code>then</code>方法。</p>\n<pre><code><span><span>class</span> <span>Yo</span> </span>{\n<span class=\"lineNumber\">2</span>  <span><span>constructor</span>(<span>executor</span>)</span> {\n<span class=\"lineNumber\">3</span>    ...\n<span class=\"lineNumber\">4</span>    <span>this</span>[promiseConsumers] = []\n<span class=\"lineNumber\">5</span>    <span>try</span> {\n<span class=\"lineNumber\">6</span>      executor(<span>this</span>.$_resolve.bind(<span>this</span>), <span>this</span>.$reject.bind(<span>this</span>))\n<span class=\"lineNumber\">7</span>    } <span>catch</span> (e) {\n<span class=\"lineNumber\">8</span>      <span>this</span>.$reject.bind(<span>this</span>)(e)\n<span class=\"lineNumber\">9</span>    }\n<span class=\"lineNumber\">10</span>  }\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span>  $resolve(value) {\n<span class=\"lineNumber\">13</span>    <span>if</span>(<span>this</span>[promiseState] !== PENDING) <span>return</span> <span>// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">14</span>    <span>this</span>[promiseState] = FULFILLED <span>// 2.1.1.1</span>\n<span class=\"lineNumber\">15</span>    <span>this</span>[promiseValue] = value <span>// 2.1.2.2</span>\n<span class=\"lineNumber\">16</span>    <span>this</span>.broadcast()\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span> \n<span class=\"lineNumber\">19</span>  $reject(reason) {\n<span class=\"lineNumber\">20</span>    <span>if</span>(<span>this</span>[promiseState] !== PENDING) <span>return</span> <span>// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">21</span>    <span>this</span>[promiseState] = REJECTED <span>// 2.1.1.1</span>\n<span class=\"lineNumber\">22</span>    <span>this</span>[promiseValue] = reason <span>// 2.1.3.2</span>\n<span class=\"lineNumber\">23</span>    <span>this</span>.broadcast()\n<span class=\"lineNumber\">24</span>  }\n<span class=\"lineNumber\">25</span> \n<span class=\"lineNumber\">26</span>  <span>static</span> <span><span>then</span>(<span>onFulfilled, onRejected</span>)</span> {\n<span class=\"lineNumber\">27</span>    <span>const</span> promise = <span>new</span> Yo(nop) <span>// then 方法返回的新实例</span>\n<span class=\"lineNumber\">28</span>    <span>// 2.2.1.1</span>\n<span class=\"lineNumber\">29</span>    promise.onFulfilled = <span>typeof</span> onFulfilled === $function ? onFulfilled : $undefined;\n<span class=\"lineNumber\">30</span>    <span>// 2.2.1.2</span>\n<span class=\"lineNumber\">31</span>    promise.onRejected = <span>typeof</span> onRejected === $function ? onRejected : $undefined;\n<span class=\"lineNumber\">32</span>    <span>// 2.2.6.1, 2.2.6.2</span>\n<span class=\"lineNumber\">33</span>    <span>this</span>[promiseConsumers].push(promise)\n<span class=\"lineNumber\">34</span>    <span>this</span>.broadcast()\n<span class=\"lineNumber\">35</span>    <span>// 2.2.7</span>\n<span class=\"lineNumber\">36</span>    <span>return</span> promise\n<span class=\"lineNumber\">37</span>  }\n<span class=\"lineNumber\">38</span> \n<span class=\"lineNumber\">39</span>  <span>static</span> <span><span>broadcast</span>(<span></span>)</span> {\n<span class=\"lineNumber\">40</span>    <span>const</span> promise = <span>this</span>;\n<span class=\"lineNumber\">41</span>    <span>// 2.2.2.1, .2.2.2.2, 2.2.3.1, 2.2.3.2</span>\n<span class=\"lineNumber\">42</span>    <span>if</span>(<span>this</span>[promiseState] === PENDING) <span>return</span>\n<span class=\"lineNumber\">43</span>    <span>// 2.2.6.1, 2.2.6.2, 2.2.2.3, 2.2.3.3</span>\n<span class=\"lineNumber\">44</span>    <span>const</span> callbackName = promise[promiseState] === FULFILLED ? <span>\"onFulfilled\"</span> : <span>\"onRejected\"</span>\n<span class=\"lineNumber\">45</span>    <span>const</span> resolver = promise[promiseState] === FULFILLED ? <span>\"$resolve\"</span> : <span>\"$reject\"</span>\n<span class=\"lineNumber\">46</span>    soon(\n<span class=\"lineNumber\">47</span>      <span><span>function</span>(<span></span>) </span>{\n<span class=\"lineNumber\">48</span>        <span>// 2.2.6.1, 2.2.6.2, 2.2.2.3, 2.2.3.3</span>\n<span class=\"lineNumber\">49</span>        <span>const</span> consumers = promise[promiseConsumers].splice(<span>0</span>)\n<span class=\"lineNumber\">50</span>        <span>for</span> (<span>let</span> index = <span>0</span>; index &#x3C; consumers.length; index++) {\n<span class=\"lineNumber\">51</span>          <span>const</span> consumer = consumers[index];\n<span class=\"lineNumber\">52</span>          <span>try</span> {\n<span class=\"lineNumber\">53</span>            <span>const</span> callback = consumer[callbackName] <span>// 获取 then 方法执行的时候传入的函数</span>\n<span class=\"lineNumber\">54</span>            <span>const</span> value = promise[promiseValue]\n<span class=\"lineNumber\">55</span>            <span>// 2.2.1.1, 2.2.1.2, 2.2.5 without context</span>\n<span class=\"lineNumber\">56</span>            <span>if</span>(callback) {\n<span class=\"lineNumber\">57</span>              consumer[<span>'$resolve'</span>](callback(value))\n<span class=\"lineNumber\">58</span>            } <span>else</span> {\n<span class=\"lineNumber\">59</span>              <span>// onFulfilled / onRejected 不是函数</span>\n<span class=\"lineNumber\">60</span>              <span>// 2.2.7.3, 2.2.7.4</span>\n<span class=\"lineNumber\">61</span>              consumer[resolver](value)\n<span class=\"lineNumber\">62</span>            }\n<span class=\"lineNumber\">63</span>          } <span>catch</span> (e) {\n<span class=\"lineNumber\">64</span>            <span>// 异常则设为 rejected</span>\n<span class=\"lineNumber\">65</span>            consumer[<span>'$reject'</span>](e)\n<span class=\"lineNumber\">66</span>          }\n<span class=\"lineNumber\">67</span>        }\n<span class=\"lineNumber\">68</span>      }\n<span class=\"lineNumber\">69</span>    )\n<span class=\"lineNumber\">70</span>  }\n<span class=\"lineNumber\">71</span>}\n<span class=\"lineNumber\">72</span> \n<span class=\"lineNumber\">73</span><span>// soon function come from Zousan.js</span>\n<span class=\"lineNumber\">74</span><span>const</span> soon = (<span>() =></span> {\n<span class=\"lineNumber\">75</span>  <span>const</span> fq = [],  <span>// function queue</span>\n<span class=\"lineNumber\">76</span>    <span>// avoid using shift() by maintaining a start pointer</span>\n<span class=\"lineNumber\">77</span>    <span>// and remove items in chunks of 1024 (bufferSize)</span>\n<span class=\"lineNumber\">78</span>    bufferSize = <span>1024</span>\n<span class=\"lineNumber\">79</span>  <span>let</span> fqStart = <span>0</span>\n<span class=\"lineNumber\">80</span>  <span><span>function</span> <span>callQueue</span>(<span></span>) </span>{\n<span class=\"lineNumber\">81</span>    <span>while</span>(fq.length - fqStart) {\n<span class=\"lineNumber\">82</span>      <span>try</span> {\n<span class=\"lineNumber\">83</span>        fq[fqStart]()\n<span class=\"lineNumber\">84</span>      } <span>catch</span> (err) {\n<span class=\"lineNumber\">85</span>        <span>console</span>.log(err)\n<span class=\"lineNumber\">86</span>      }\n<span class=\"lineNumber\">87</span>      fq[fqStart++] = <span>undefined</span> <span>// increase start pointer and dereference function just called</span>\n<span class=\"lineNumber\">88</span>      <span>if</span>(fqStart === bufferSize) {\n<span class=\"lineNumber\">89</span>        fq.splice(<span>0</span>, bufferSize)\n<span class=\"lineNumber\">90</span>        fqStart = <span>0</span>\n<span class=\"lineNumber\">91</span>      }\n<span class=\"lineNumber\">92</span>    }\n<span class=\"lineNumber\">93</span>  }\n<span class=\"lineNumber\">94</span>  <span>// run the callQueue function asyncrhonously as fast as possible</span>\n<span class=\"lineNumber\">95</span>  <span>// 执行此函数，返回的函数赋值给 cqYield</span>\n<span class=\"lineNumber\">96</span>  <span>const</span> cqYield = (<span>() =></span> {\n<span class=\"lineNumber\">97</span>    <span>// 返回一个函数并且执行</span>\n<span class=\"lineNumber\">98</span>    <span>// This is the fastest way browsers have to yield processing</span>\n<span class=\"lineNumber\">99</span>    <span>if</span>(<span>typeof</span> MutationObserver !== <span>'undefined'</span>)\n<span class=\"lineNumber\">100</span>    {\n<span class=\"lineNumber\">101</span>      <span>// first, create a div not attached to DOM to \"observe\"</span>\n<span class=\"lineNumber\">102</span>      <span>const</span> dd = <span>document</span>.createElement(<span>\"div\"</span>)\n<span class=\"lineNumber\">103</span>      <span>const</span> mo = <span>new</span> MutationObserver(callQueue)\n<span class=\"lineNumber\">104</span>      mo.observe(dd, { <span>attributes</span>: <span>true</span> })\n<span class=\"lineNumber\">105</span> \n<span class=\"lineNumber\">106</span>      <span>return</span> <span><span>function</span>(<span></span>) </span>{ dd.setAttribute(<span>\"a\"</span>,<span>0</span>) } <span>// trigger callback to</span>\n<span class=\"lineNumber\">107</span>    }\n<span class=\"lineNumber\">108</span> \n<span class=\"lineNumber\">109</span>    <span>// if No MutationObserver - this is the next best thing for Node</span>\n<span class=\"lineNumber\">110</span>    <span>if</span>(<span>typeof</span> process !== <span>'undefined'</span> &#x26;&#x26; <span>typeof</span> process.nextTick === <span>\"function\"</span>)\n<span class=\"lineNumber\">111</span>      <span>return</span> <span><span>function</span>(<span></span>) </span>{ process.nextTick(callQueue) }\n<span class=\"lineNumber\">112</span> \n<span class=\"lineNumber\">113</span>    <span>// if No MutationObserver - this is the next best thing for MSIE</span>\n<span class=\"lineNumber\">114</span>    <span>if</span>(<span>typeof</span> setImmediate !== _undefinedString)\n<span class=\"lineNumber\">115</span>      <span>return</span> <span><span>function</span>(<span></span>) </span>{ setImmediate(callQueue) }\n<span class=\"lineNumber\">116</span> \n<span class=\"lineNumber\">117</span>    <span>// final fallback - shouldn't be used for much except very old browsers</span>\n<span class=\"lineNumber\">118</span>    <span>return</span> <span><span>function</span>(<span></span>) </span>{ <span>setTimeout</span>(callQueue,<span>0</span>) }\n<span class=\"lineNumber\">119</span>  })()\n<span class=\"lineNumber\">120</span>  <span>// this is the function that will be assigned to soon</span>\n<span class=\"lineNumber\">121</span>  <span>// it take the function to call and examines all arguments</span>\n<span class=\"lineNumber\">122</span>  <span>return</span> <span><span>fn</span> =></span> {\n<span class=\"lineNumber\">123</span>    fq.push(fn) <span>// push the function and any remaining arguments along with context</span>\n<span class=\"lineNumber\">124</span>    <span>if</span>((fq.length - fqStart) === <span>1</span>) { <span>// upon addubg our first entry, keck off the callback</span>\n<span class=\"lineNumber\">125</span>      cqYield()\n<span class=\"lineNumber\">126</span>    }\n<span class=\"lineNumber\">127</span>  }\n<span class=\"lineNumber\">128</span>})()</code></pre> \n\n<p>网上对于状态转换后异步调用<code>onFulfilled</code>或者<code>onRejected</code>的逻辑实现众说纷纭，我最喜欢的实现来源于<code>@trincot</code>大神在 Stack Overflow 上的解答，感兴趣可以查看文末参考链接。</p>\n<p>对于在状态变更后异步调用之前注册的回调函数的解法如下：</p>\n<ul>\n<li>使用<code>consumers</code>数组存放<code>then</code>方法返回的<code>promise</code></li>\n<li>在<code>then</code>方法中，为每个将要返回的<code>promise</code>添加其传入的同名参数<code>onFulfilled</code>和<code>onRejected</code>作为<code>Promise</code>上的属性。</li>\n<li>对于某些已经转换过状态的<code>Promise</code>实例，需要在<code>then</code>方法中调用一次<code>broadcast</code>方法。</li>\n</ul>\n<blockquote>\n<p><code>broadcast</code> 方法非常关键，在<code>resolve</code>、<code>reject</code>、<code>then</code>方法中都会调用一次。</p>\n</blockquote>\n<p>我们使用<code>broadcast</code>方法来做一个“广播”的功能，当<code>Promise</code>状态转换之后就视其状态创建微任务，异步调用<code>consumers</code>数组中所有的<code>Promise</code>上的属性方法<code>onFulfilled</code>或者<code>onRejected</code>。</p>\n<p>另外，如何创建微任务以异步执行相关函数也是实现<code>Promise</code>类的关键，这里我学习了<code>@bluejava</code>前辈的<code>Promise</code>实现方案：<code>Zousan.js</code> ，文末有其<code>github</code>仓库地址。</p>\n<p>在<code>zousan.js</code>中，作者特地创建了一个<code>soon</code>函数，将传入的函数参数尽可能快速地创建微任务以执行。</p>\n<p>其核心便是如果是浏览器环境并且支持<code>MutationObserver</code>，则创建文档节点使用此<code>API</code>创建微任务最终执行目标函数，如若不支持则检查<code>process.nextTick</code>和<code>setImmediate</code>是否可用，最后用<code>setTimeout</code>兜底创建宏任务以达到异步调用目标函数的目的。</p>\n<p>至此，我们的<code>Yo</code>类几近完成，最后就是规范第三点：<code>The Promise Resolution Procedure</code>。</p>\n<h5>The Promise Resolution Procedure</h5>\n<blockquote>\n<p>Promise Resolution procedure 表示为<code>[[Resolve]](promise, x)</code>,为什么我们需要实现此规范？</p>\n</blockquote>\n<p>当我们在<code>executor</code>函数中使用<code>resolve</code>或者<code>reject</code>方法的时候，传入的参数可以是任意有效的<code>Javascript</code>值。某些场景下，这个值可能是一个原始类型的数据，也可能是一个<code>thenables</code>对象，亦或是一个其他<code>Promise</code>实现方案创建的<code>Promise</code>实例。</p>\n<p><strong>我们需要处理这个问题，让不同的传参都有一个一致且确切的处理方案。</strong></p>\n<p>那么，就让我们继续看规范是如何定义的。</p>\n<p>执行<code>[[Resolve]](promise, x)</code>的步骤如下：</p>\n<ul>\n<li>2.3.1 如果<code>promise</code>和<code>x</code>引用的是同一个对象，则<code>reject</code>一个<code>TypeError</code>异常作为<code>reason</code></li>\n<li>2.3.2 如果<code>x</code>是一个<code>Promise</code>，则采纳其状态\n<ul>\n<li>2.3.2.1 如果<code>x</code>是<code>pending</code>的，则<code>promise</code>保持<code>pending</code>直到<code>x</code>状态改变</li>\n<li>2.3.2.2 、2.3.2.3 <code>x</code>状态稳定后，直接沿用其<code>value</code>或<code>reason</code></li>\n</ul>\n</li>\n<li>2.3.3 如若其不是<code>Promise</code>而是一个普通<code>thenable</code>对象\n<ul>\n<li>2.3.3.1 设<code>then</code>等于<code>x.then</code></li>\n<li>2.3.3.2 如果获取<code>x.then</code>值的时候抛出异常，则<code>reject</code>此<code>promise</code>，并且将异常作为<code>reason</code></li>\n<li>2.3.3.3 如果<code>then</code>是一个函数，则将<code>x</code>绑定为此函数的<code>this</code>对象，依次传入可以改变当前<code>promise</code>状态的方法<code>resolve</code>和<code>reject</code>\n<ul>\n<li>2.3.3.3.1 如若<code>resolve</code>执行并传入一个<code>y</code>值，则执行<code>[[Resolve]](promise, y)</code></li>\n<li>2.3.3.3.2 如若<code>reject</code>执行并且传入一个<code>reason</code>,则采纳此<code>reason</code>作为<code>rejected</code>状态的<code>reason</code></li>\n<li>2.3.3.3.3 如若<code>resolve</code>和<code>reject</code>都被调用，或者多次调用，则以先调用的优先，并且只执行首次调用，后续调用直接忽略</li>\n<li>2.3.3.3.4 如若调用<code>then</code>的时候抛出了异常\n<ul>\n<li>2.3.3.3.4.1 如若<code>resolve</code>或<code>reject</code>被调用了，则忽略此异常</li>\n<li>2.3.3.3.4.2 否则，<code>reject</code>此异常作为其<code>reason</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.3.3.4 如若<code>then</code>不是一个函数，则此<code>promise</code>以<code>x</code>为<code>value</code>，状态转为<code>fulfilled</code></li>\n</ul>\n</li>\n<li>2.3.4 如若<code>x</code>不是对象或者函数，则此<code>promise</code>以<code>x</code>为<code>value</code>，状态转为<code>fulfilled</code></li>\n</ul>\n<p>对于<code>Promise</code>来说，转换状态的函数才需要考虑上述规范如何实现。</p>\n<p>我们继续来完善未完成的代码。</p>\n<p>由于需要处理复杂的<code>resolve</code>函数，而不仅仅在其<code>settled</code>之后更改状态和设置<code>value</code>或者<code>reason</code>，我选择将此方法命名为<code>$_resolve</code>，从而与原来简单的<code>$resolve</code>方法区分开来。</p>\n<pre><code><span><span>class</span> <span>Yo</span> </span>{\n<span class=\"lineNumber\">2</span>  ...\n<span class=\"lineNumber\">3</span>    $_resolve(x) {\n<span class=\"lineNumber\">4</span>    <span>let</span> hasCalled,then;\n<span class=\"lineNumber\">5</span>    <span>// 2.3.1</span>\n<span class=\"lineNumber\">6</span>    <span>if</span>(<span>this</span> === x) {\n<span class=\"lineNumber\">7</span>      <span>console</span>.log(<span>'circular'</span>);\n<span class=\"lineNumber\">8</span>      <span>throw</span> <span>new</span> <span>TypeError</span>(<span>\"Circular reference error, value is promise itself.\"</span>)\n<span class=\"lineNumber\">9</span>    }\n<span class=\"lineNumber\">10</span>    <span>// 2.3.2</span>\n<span class=\"lineNumber\">11</span>    <span>if</span>(x <span>instanceof</span> Yo) {\n<span class=\"lineNumber\">12</span>      <span>console</span>.log(<span>'instance'</span>);\n<span class=\"lineNumber\">13</span>      <span>// 2.3.2.1, 2.3.2.2, 2.3.2.3</span>\n<span class=\"lineNumber\">14</span>      x.then(<span>this</span>.$_resolve.bind(<span>this</span>), <span>this</span>.$reject.bind(<span>this</span>))\n<span class=\"lineNumber\">15</span>    } <span>else</span> <span>if</span>(x === <span>Object</span>(x)) {\n<span class=\"lineNumber\">16</span>      <span>// 2.3.3</span>\n<span class=\"lineNumber\">17</span>      <span>try</span> {\n<span class=\"lineNumber\">18</span>        <span>// 2.3.3.1</span>\n<span class=\"lineNumber\">19</span>        then = x.then;\n<span class=\"lineNumber\">20</span>        <span>if</span>(<span>typeof</span> then === $function) {\n<span class=\"lineNumber\">21</span>          <span>// 2.3.3.3</span>\n<span class=\"lineNumber\">22</span>          then.call(\n<span class=\"lineNumber\">23</span>            x,\n<span class=\"lineNumber\">24</span>            <span>// first argument resolvePromise</span>\n<span class=\"lineNumber\">25</span>            <span><span>function</span>(<span>y</span>) </span>{\n<span class=\"lineNumber\">26</span>              <span>if</span>(hasCalled) <span>return</span>\n<span class=\"lineNumber\">27</span>              hasCalled = <span>true</span>\n<span class=\"lineNumber\">28</span>              <span>// 2.3.3.3.1</span>\n<span class=\"lineNumber\">29</span>              <span>this</span>.$_resolve(y)\n<span class=\"lineNumber\">30</span>            }.bind(<span>this</span>),\n<span class=\"lineNumber\">31</span>            <span>// second argument is rejectPromise</span>\n<span class=\"lineNumber\">32</span>            <span><span>function</span> (<span>reasonY</span>) </span>{\n<span class=\"lineNumber\">33</span>              <span>if</span>(hasCalled) <span>return</span>\n<span class=\"lineNumber\">34</span>              hasCalled = <span>true</span>\n<span class=\"lineNumber\">35</span>              <span>// 2.3.3.3.2</span>\n<span class=\"lineNumber\">36</span>              <span>this</span>.$reject(reasonY)\n<span class=\"lineNumber\">37</span>            }.bind(<span>this</span>)\n<span class=\"lineNumber\">38</span>          )\n<span class=\"lineNumber\">39</span>        } <span>else</span> {\n<span class=\"lineNumber\">40</span>          <span>// 2.3.3.4 原始值</span>\n<span class=\"lineNumber\">41</span>          <span>this</span>.$resolve(x)\n<span class=\"lineNumber\">42</span>        }\n<span class=\"lineNumber\">43</span>      } <span>catch</span> (e) {\n<span class=\"lineNumber\">44</span>        <span>// 2.3.3.2, 2.3.3.3.4 异常</span>\n<span class=\"lineNumber\">45</span>        <span>if</span>(hasCalled) <span>return</span> <span>// 2.3.3.3.4.1</span>\n<span class=\"lineNumber\">46</span>        <span>this</span>.$reject(e) <span>// 2.3.3.3.4.2</span>\n<span class=\"lineNumber\">47</span>      }\n<span class=\"lineNumber\">48</span>    } <span>else</span> {\n<span class=\"lineNumber\">49</span>      <span>// 2.3.4 原始值</span>\n<span class=\"lineNumber\">50</span>      <span>this</span>.$resolve(x)\n<span class=\"lineNumber\">51</span>    }\n<span class=\"lineNumber\">52</span>  }\n<span class=\"lineNumber\">53</span>  ...\n<span class=\"lineNumber\">54</span>}</code></pre> \n\n<p>至此</p>\n<p>对于一个<code>Promise</code>的实现来说，我们还需要添加一个<code>catch</code>方法，这个方法可以看成<code>then</code>方法的语法糖。</p>\n<p>当然，静态方法<code>resolve</code>和<code>reject</code>也可以简单添加进来。</p>\n<pre><code><span><span>class</span> <span>Yo</span></span>{\n<span class=\"lineNumber\">2</span>  ...\n<span class=\"lineNumber\">3</span>  <span>catch</span>(onRejected) {\n<span class=\"lineNumber\">4</span>    <span>return</span> <span>this</span>.then($undefined, onRejected)\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span>\t<span>static</span> <span><span>reject</span>(<span>reason</span>)</span> {\n<span class=\"lineNumber\">8</span>    <span>return</span> <span>new</span> Yo(<span>(<span>_, reject</span>) =></span> {\n<span class=\"lineNumber\">9</span>      reject(reason)\n<span class=\"lineNumber\">10</span>    })\n<span class=\"lineNumber\">11</span>  }\n<span class=\"lineNumber\">12</span> \n<span class=\"lineNumber\">13</span>  <span>static</span> <span><span>resolve</span>(<span>value</span>)</span> {\n<span class=\"lineNumber\">14</span>    <span>return</span> <span>new</span> Yo(<span><span>resolve</span> =></span> {\n<span class=\"lineNumber\">15</span>      resolve(value)\n<span class=\"lineNumber\">16</span>    })\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span>\t...\n<span class=\"lineNumber\">19</span>}</code></pre> \n\n<p>最后，使用<code>promises-aplus-tests</code>对我们的实现进行测试。</p>\n<p>在安装了依赖包之后，为<code>Yo</code>添加了<code>deferred</code>静态方法如下：</p>\n<pre><code><span><span>class</span> <span>Yo</span> </span>{\n<span class=\"lineNumber\">2</span>  ...\n<span class=\"lineNumber\">3</span>  <span>static</span> <span><span>deferred</span>(<span></span>)</span> {\n<span class=\"lineNumber\">4</span>    <span>const</span> result = {}\n<span class=\"lineNumber\">5</span>    result.promise = <span>new</span> Yo(<span>(<span>resolve, reject</span>) =></span> {\n<span class=\"lineNumber\">6</span>      result.resolve = resolve\n<span class=\"lineNumber\">7</span>      result.reject = reject\n<span class=\"lineNumber\">8</span>    })\n<span class=\"lineNumber\">9</span>    <span>return</span> result\n<span class=\"lineNumber\">10</span>  }\n<span class=\"lineNumber\">11</span>  ...\n<span class=\"lineNumber\">12</span>}</code></pre> \n\n<p>然后在<code>package.json</code>的<code>scripts</code>字段中添加测试命令，最后使用<code>yarn run test</code>进行测试如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/1.png\" alt=\"\"></p>\n<p>自此，我们实现了遵守<code>Promise/A+</code>规范的<code>Promise</code>，也许<code>Yo</code>不够健壮，甚至有一些常用的方法并未提供，但作为一个用于学习<code>Promise</code>知识的简单实现，<code>Yo</code>已经良好的完成了任务，所有代码如下图所示（亦可通过参考的最后一条访问 GitHub 仓库源码）：</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/Fxu8L5TQb3z9tl7.png\" alt=\"carbon 2.png\"></p>\n<p>完结撒花。</p>\n<h2>写在最后</h2>\n<p>通过学习<code>ES6 Promise</code>的知识，再阅读网上一些开发者的第三方<code>Promise</code>实现示例，对我们理解和使用<code>Promise</code>进行异步编程非常有用，亲自实现一个能通过<code>Promise/A+</code>测试用例测试的<code>Promise</code>实现让笔者对<code>Promise</code>的应用能力得到了一定程度的增强。</p>\n<p>再会~</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244\">Basic Javascript promise implementation attempt - Stack Overflow</a></li>\n<li><a href=\"https://github.com/bluejava/zousan\">bluejava/zousan: A Lightning Fast, Yet Very Small Promise A+ Compliant Implementation</a></li>\n<li><a href=\"https://github.com/youyiqin/yo\">youyiqin/yo</a> 源代码</li>\n</ul>\n","title":"实现一个Promise-A+规范的Promise类","date":"2021/5/12","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=400","intro":"为了学习 Promise 的原理，加深对异步 Promise 的理解，我们很有必要学习如何实现一个符合 Promise/A+ 规范的 Promise 类"}},"__N_SSG":true}
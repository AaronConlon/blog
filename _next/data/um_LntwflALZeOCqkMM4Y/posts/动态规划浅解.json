{"pageProps":{"post":{"slug":"动态规划浅解","contentHtml":"<h3>前言</h3>\n<p>为了能通过大厂的笔试,算法这一关是必须闯的,其中动态规划可以单独拉出来学习.</p>\n<h3>思想</h3>\n<blockquote>\n<p>简而言之</p>\n</blockquote>\n<p>动态规划的核心在于<code>拆</code>和<code>解</code>!在于<code>尽可能缩小可能的解的空间</code>!</p>\n<p>将一个问题拆成几个子问题,求解这些子问题,把子问题的答案保存起来,最终推断出最大的问题的解.</p>\n<p>最大的问题的<code>最优解</code>通常是某个算法问题的答案,这个最优解可以由小问题的最优解推出.</p>\n<p>对于使用<code>DP</code>算法解决问题,需要明确以下三点:</p>\n<ul>\n<li>设计状态</li>\n<li>设计状态转移方程</li>\n<li>转移状态</li>\n</ul>\n<h3>实例解析</h3>\n<h4>🐸 跳台阶</h4>\n<p><a href=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\">剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）</a></p>\n<p>当年校招时,我一直以为这种笔试题是脑筋急转弯,现在才知道当时有多可笑.</p>\n<p>首先,定义一个数组保存若干台阶时有多少种跳法,数组为<code>dp</code>,跳上<code>i</code>级的台阶的跳法有<code>dp[i]</code>种.\n那么最终的结果就是：<code>dp[n] = dp[n-1] + dp[n-2]</code></p>\n<p>这里我们就思考初始化状态是什么？显然 dp[0] = 1, dp[1] = 1</p>\n<p>代码如下：</p>\n<pre><code><span>/**\n<span class=\"lineNumber\">2</span> * <span>@param <span>{number}</span> <span>n</span></span>\n<span class=\"lineNumber\">3</span> * <span>@return <span>{number}</span></span>\n<span class=\"lineNumber\">4</span> */</span>\n<span class=\"lineNumber\">5</span><span>var</span> numWays = <span><span>function</span> (<span>n</span>) </span>{\n<span class=\"lineNumber\">6</span>  <span>let</span> dp = [<span>1</span>, <span>1</span>];\n<span class=\"lineNumber\">7</span>  <span>if</span> (n &#x3C; <span>2</span>) <span>return</span> <span>1</span>;\n<span class=\"lineNumber\">8</span>  <span>for</span> (<span>let</span> i = <span>2</span>; i &#x3C;= n; i++) {\n<span class=\"lineNumber\">9</span>    <span>let</span> types = (dp[<span>0</span>] + dp[<span>1</span>]) % <span>1000000007</span>;\n<span class=\"lineNumber\">10</span>    dp[<span>0</span>] = dp[<span>1</span>];\n<span class=\"lineNumber\">11</span>    dp[<span>1</span>] = types;\n<span class=\"lineNumber\">12</span>  }\n<span class=\"lineNumber\">13</span>  <span>return</span> dp[<span>1</span>];\n<span class=\"lineNumber\">14</span>};</code></pre> \n\n<p>初始化其状态，得出跳 2 次以下都只有 1 种方法的初始状态，然后逐步求新增的台阶直到 n 级。在上述代码中，使用固定长度的数组能节省空间，实质上依然是取最后两个选择的结果，这两个选择的结果被保存到了数组开头而已。</p>\n<h4>不同路径</h4>\n<p><a href=\"https://leetcode-cn.com/problems/unique-paths/\">62. 不同路径 - 力扣（LeetCode）</a></p>\n<p>首先，如何设计状态？用函数的思路来设计，那么可以用 f(i,j) 表示从左上角走到坐标 (i,j) 的总路径数。\n显然，要走到最后只有两种选择：</p>\n<ul>\n<li>从目标的上面往下</li>\n<li>从目标的左边往右</li>\n</ul>\n<p>那么最终的状态转移方程可得：\n<code>f(i,j) = f(i-1, j) + f(i, j-1)</code></p>\n<p>接着，我们来初始化一些状态。根据实际题目可知，我们需要用一个二维数组来保存每一个坐标的路径总数。并且无论是第一行还是第一列，都只有一条路可走。</p>\n<pre><code><span>const</span> uniquePaths = <span>(<span>m, n</span>) =></span> {\n<span class=\"lineNumber\">2</span>  <span>// 初始化二维数组</span>\n<span class=\"lineNumber\">3</span>  <span>const</span> f = <span>new</span> <span>Array</span>(m).fill(<span>0</span>).map(<span>() =></span> <span>new</span> <span>Array</span>(n).fill(<span>0</span>));\n<span class=\"lineNumber\">4</span>  <span>// 初始化第一行和第一列的路径总数</span>\n<span class=\"lineNumber\">5</span>  <span>for</span> (<span>let</span> i = <span>0</span>; i &#x3C; m; i++) {\n<span class=\"lineNumber\">6</span>    <span>// 第一行</span>\n<span class=\"lineNumber\">7</span>    f[<span>0</span>][i] = <span>1</span>;\n<span class=\"lineNumber\">8</span>  }\n<span class=\"lineNumber\">9</span>  <span>for</span> (<span>let</span> j = <span>0</span>; j &#x3C; n; j++) {\n<span class=\"lineNumber\">10</span>    <span>// 第一列</span>\n<span class=\"lineNumber\">11</span>    f[j][<span>0</span>] = <span>1</span>;\n<span class=\"lineNumber\">12</span>  }\n<span class=\"lineNumber\">13</span>  <span>// 其他位置</span>\n<span class=\"lineNumber\">14</span>  <span>for</span> (<span>let</span> i = <span>1</span>; i &#x3C; m; i++) {\n<span class=\"lineNumber\">15</span>    <span>for</span> (<span>let</span> j = <span>1</span>; j &#x3C; n; j++) {\n<span class=\"lineNumber\">16</span>      <span>// 某坐标的路径总数可以根据此前的历史数据计算出来，最终得到 f(i, j)</span>\n<span class=\"lineNumber\">17</span>      f[i][j] = f[i - <span>1</span>][j] + f[i][j - <span>1</span>];\n<span class=\"lineNumber\">18</span>    }\n<span class=\"lineNumber\">19</span>  }\n<span class=\"lineNumber\">20</span>  <span>return</span> f[m - <span>1</span>][n - <span>1</span>];\n<span class=\"lineNumber\">21</span>};</code></pre> \n\n<p>另有题：<a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">64. 最小路径和 - 力扣（LeetCode）</a></p>\n<p>依然是状态转移方程的设计：\n<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></p>\n<p>雷同于上一题，但这一题为每一个坐标提供了路径值，以下代码最佳：</p>\n<pre><code><span>const</span> minPathSum = <span>(<span>grid</span>) =></span> {\n<span class=\"lineNumber\">2</span>  <span>const</span> row = grid.length,\n<span class=\"lineNumber\">3</span>    col = grid[<span>0</span>].length;\n<span class=\"lineNumber\">4</span>  <span>// 将初始化的数据直接写在 grid 上节省空间</span>\n<span class=\"lineNumber\">5</span>  <span>for</span> (<span>let</span> i = <span>1</span>; i &#x3C; row; i++) {\n<span class=\"lineNumber\">6</span>    grid[i][<span>0</span>] += grid[i - <span>1</span>][<span>0</span>];\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span>for</span> (<span>let</span> j = <span>1</span>; j &#x3C; col; j++) {\n<span class=\"lineNumber\">9</span>    grid[<span>0</span>][j] += grid[<span>0</span>][j - <span>1</span>];\n<span class=\"lineNumber\">10</span>  }\n<span class=\"lineNumber\">11</span>  <span>for</span> (<span>let</span> i = <span>1</span>; i &#x3C; row; i++) {\n<span class=\"lineNumber\">12</span>    <span>for</span> (<span>let</span> j = <span>1</span>; j &#x3C; col; j++) {\n<span class=\"lineNumber\">13</span>      grid[i][j] += <span>Math</span>.min(grid[i - <span>1</span>][j], grid[i][j - <span>1</span>]);\n<span class=\"lineNumber\">14</span>    }\n<span class=\"lineNumber\">15</span>  }\n<span class=\"lineNumber\">16</span>  <span>return</span> grid[row - <span>1</span>][col - <span>1</span>];\n<span class=\"lineNumber\">17</span>};</code></pre> \n\n<p>首先，获取到行和列的数。由于第一行和第一列都只有一个上层选项，并且内部贴边的坐标都依赖于第一行或第一列，因此可以将数据直接更新到二维数组上，然后更新第一行和第一列某个坐标的路径值。</p>\n<h4>编辑距离</h4>\n<p>再来一题<code>Hard</code>难题,这道题就是<a href=\"https://leetcode-cn.com/problems/edit-distance/\">72. 编辑距离 - 力扣（LeetCode）</a>.说实话,在一开始看这道题的时候我真的一点想法都没有,如果说非要有想法,那就是怀疑我自己智力不足.</p>\n<p>这一题需要计算最少的操作数,那么可以脑补一下要用到<code>Math.min()</code>来从若干个操作中获取操作数最小的.</p>\n<p><code>接下来就是顿悟时刻</code>.</p>\n<p>每一个单词都有长度,这两个长度就是<code>m</code>和<code>n</code>!\n当在某个阶段想要获得最少的操作数时,就可以根据二者的动态下标,选择最佳的操作.</p>\n<p>首先是初始化,显然无论如何当某个单词为空字符串的时候,下标会有 0 的存在,这个数组元素就等于添加若干个字母.</p>\n<p>也就是说:\n<code>dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i-1][j]) + 1</code></p>\n<p>当我们得知历史数据后,可以根据最小的操作去做下一步,选择最小的操作再+1.</p>\n<pre><code><span>const</span> minDistance = <span>(<span>word1 = <span>\"horse\"</span>, word2 = <span>\"ros\"</span></span>) =></span> {\n<span class=\"lineNumber\">2</span>  <span>let</span> dp = <span>Array</span>.from(<span>Array</span>(word1.length + <span>1</span>), <span>() =></span>\n<span class=\"lineNumber\">3</span>    <span>Array</span>(word2.length + <span>1</span>).fill(<span>0</span>)\n<span class=\"lineNumber\">4</span>  );\n<span class=\"lineNumber\">5</span>  <span>console</span>.log(dp);\n<span class=\"lineNumber\">6</span>  <span>for</span> (<span>let</span> i = <span>1</span>; i &#x3C;= word1.length; i++) {\n<span class=\"lineNumber\">7</span>    dp[i][<span>0</span>] = i;\n<span class=\"lineNumber\">8</span>  }\n<span class=\"lineNumber\">9</span> \n<span class=\"lineNumber\">10</span>  <span>for</span> (<span>let</span> j = <span>1</span>; j &#x3C;= word2.length; j++) {\n<span class=\"lineNumber\">11</span>    dp[<span>0</span>][j] = j;\n<span class=\"lineNumber\">12</span>  }\n<span class=\"lineNumber\">13</span> \n<span class=\"lineNumber\">14</span>  <span>for</span> (<span>let</span> i = <span>1</span>; i &#x3C;= word1.length; i++) {\n<span class=\"lineNumber\">15</span>    <span>for</span> (<span>let</span> j = <span>1</span>; j &#x3C;= word2.length; j++) {\n<span class=\"lineNumber\">16</span>      <span>if</span> (word1[i - <span>1</span>] === word2[j - <span>1</span>]) {\n<span class=\"lineNumber\">17</span>        dp[i][j] = dp[i - <span>1</span>][j - <span>1</span>];\n<span class=\"lineNumber\">18</span>      } <span>else</span> {\n<span class=\"lineNumber\">19</span>        dp[i][j] = <span>Math</span>.min(dp[i - <span>1</span>][j], dp[i][j - <span>1</span>], dp[i - <span>1</span>][j - <span>1</span>]) + <span>1</span>;\n<span class=\"lineNumber\">20</span>      }\n<span class=\"lineNumber\">21</span>    }\n<span class=\"lineNumber\">22</span>  }\n<span class=\"lineNumber\">23</span> \n<span class=\"lineNumber\">24</span>  <span>return</span> dp[word1.length][word2.length];\n<span class=\"lineNumber\">25</span>};</code></pre> \n\n<p>在 LeetCode 看到一个更好的解法：</p>\n<pre><code><span>/**\n<span class=\"lineNumber\">2</span> * <span>@param <span>{string}</span> <span>word1</span></span>\n<span class=\"lineNumber\">3</span> * <span>@param <span>{string}</span> <span>word2</span></span>\n<span class=\"lineNumber\">4</span> * <span>@return <span>{number}</span></span>\n<span class=\"lineNumber\">5</span> */</span>\n<span class=\"lineNumber\">6</span><span>var</span> minDistance = <span><span>function</span> (<span>word1, word2</span>) </span>{\n<span class=\"lineNumber\">7</span>  <span>let</span> n = word1.length;\n<span class=\"lineNumber\">8</span>  <span>let</span> m = word2.length;\n<span class=\"lineNumber\">9</span>  <span>if</span> (n * m === <span>0</span>) <span>return</span> n + m;\n<span class=\"lineNumber\">10</span>  <span>if</span> (word1 === word2) <span>return</span> <span>0</span>;\n<span class=\"lineNumber\">11</span>  <span>let</span> dp = [];\n<span class=\"lineNumber\">12</span>  <span>for</span> (<span>let</span> i = <span>0</span>; i &#x3C;= n; i++) {\n<span class=\"lineNumber\">13</span>    dp.push([]);\n<span class=\"lineNumber\">14</span>    <span>for</span> (<span>let</span> j = <span>0</span>; j &#x3C;= m; j++) {\n<span class=\"lineNumber\">15</span>      <span>if</span> (i * j) {\n<span class=\"lineNumber\">16</span>        dp[i][j] =\n<span class=\"lineNumber\">17</span>          word1[i - <span>1</span>] == word2[j - <span>1</span>]\n<span class=\"lineNumber\">18</span>            ? dp[i - <span>1</span>][j - <span>1</span>]\n<span class=\"lineNumber\">19</span>            : <span>Math</span>.min(dp[i - <span>1</span>][j], dp[i][j - <span>1</span>], dp[i - <span>1</span>][j - <span>1</span>]) + <span>1</span>;\n<span class=\"lineNumber\">20</span>      } <span>else</span> {\n<span class=\"lineNumber\">21</span>        dp[i][j] = i + j;\n<span class=\"lineNumber\">22</span>      }\n<span class=\"lineNumber\">23</span>    }\n<span class=\"lineNumber\">24</span>  }\n<span class=\"lineNumber\">25</span>  <span>return</span> dp[n][m];\n<span class=\"lineNumber\">26</span>};</code></pre> \n\n<p>不用初始化，直接判断是否有字符长度为 0，是则返回另一个的长度。否则根据动态规划的转移方程计算出结果。</p>\n<blockquote>\n<p>官方题解的评论区有一个 Python 版本的最优解，使用滚动数组压缩空间，笔者智力不足，有兴趣的可以去看看。</p>\n</blockquote>\n<h4>最长递增子序列</h4>\n<blockquote>\n<p>作者：liweiwei1419\n链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/</p>\n</blockquote>\n<p>这道题是很经典「动态规划」算法问题。</p>\n<ul>\n<li>需要对「子序列」和「子串」这两个概念进行区分；\n<ul>\n<li>子序列（subsequence）：子序列并不要求连续，例如：序列 [4, 6, 5] 是 [1, 2, 4, 3, 7, 6, 5] 的一个子序列；</li>\n<li>子串（substring、subarray）：子串一定是原始字符串的连续子串。</li>\n</ul>\n</li>\n<li>题目中的「上升」的意思是「严格上升」。反例： [1, 2, 2, 3] 不能算作「上升子序列」；</li>\n<li>子序列中元素的 相对顺序 很重要，子序列中的元素 必须保持在原始数组中的相对顺序。如果把这个限制去掉，将原始数组去重以后，元素的个数即为所求；</li>\n<li>O(N \\log N)O(NlogN) 的解法根据了「最长上升子序列」问题的特点，设计了合适的状态，使得复杂度从 O(N^2)O(N 2 ) 降到了 O(N \\log N)O(NlogN)。</li>\n</ul>\n<h4>最长回文子串</h4>\n<blockquote>\n<p>作者：visa\n链接：https://juejin.cn/post/6844903902865784846</p>\n</blockquote>\n<p>首先考虑如果字符串长度为 1，那么答案就是其本身</p>\n<p>如果字符串长度等于 2，那么如果 s[i] == s[j] 则说明该字符串为回文</p>\n<p>那么如果长度大于 2 呢？s[i] == s[j]的情况下 s[i + 1] == s[j-1]，也说明该字符串为回文</p>\n<p>如此推论，结果如下：</p>\n<pre><code><span>var</span> longestPalindrome = <span><span>function</span> (<span>s</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span>if</span> (s.length == <span>1</span>) {\n<span class=\"lineNumber\">3</span>    <span>// 长度1，返回本身</span>\n<span class=\"lineNumber\">4</span>    <span>return</span> s;\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span>  <span>// 创建二阶数组存储从j到i是否是回文数组，0为不回文，1为回文</span>\n<span class=\"lineNumber\">8</span>  <span>let</span> arr = [];\n<span class=\"lineNumber\">9</span>  <span>for</span> (<span>let</span> i = <span>0</span>; i &#x3C; s.length; i++) {\n<span class=\"lineNumber\">10</span>    arr[i] = [];\n<span class=\"lineNumber\">11</span>  }\n<span class=\"lineNumber\">12</span> \n<span class=\"lineNumber\">13</span>  <span>// 存储最长回文子串的起始位置</span>\n<span class=\"lineNumber\">14</span>  <span>let</span> begin = <span>0</span>;\n<span class=\"lineNumber\">15</span>  <span>// 存储最长子串的长度</span>\n<span class=\"lineNumber\">16</span>  <span>let</span> max = <span>0</span>;\n<span class=\"lineNumber\">17</span> \n<span class=\"lineNumber\">18</span>  <span>for</span> (<span>let</span> i = <span>0</span>; i &#x3C; s.length; i++) {\n<span class=\"lineNumber\">19</span>    <span>let</span> j = <span>0</span>;\n<span class=\"lineNumber\">20</span>    <span>while</span> (j &#x3C;= i) {\n<span class=\"lineNumber\">21</span>      <span>// 如果 i-j &#x3C;= 1 时，说明i位置和j位置要么是重合的，要么是相邻的，即为最后一次查找</span>\n<span class=\"lineNumber\">22</span>      <span>// 否则继续查询[j + 1]到[i - 1]是否为回文</span>\n<span class=\"lineNumber\">23</span>      <span>if</span> (s[j] == s[i] &#x26;&#x26; (i - j &#x3C;= <span>1</span> || arr[j + <span>1</span>][i - <span>1</span>])) {\n<span class=\"lineNumber\">24</span>        <span>// 如果符合上述条件，说明j到i是回文</span>\n<span class=\"lineNumber\">25</span>        arr[j][i] = <span>1</span>;\n<span class=\"lineNumber\">26</span>        <span>if</span> (i - j + <span>1</span> > max) {\n<span class=\"lineNumber\">27</span>          <span>// 如果当前子串大于存储的子串长度，则替换之</span>\n<span class=\"lineNumber\">28</span>          begin = j;\n<span class=\"lineNumber\">29</span>          <span>// 注意+1，比如从3到5的长度为3 = 5 - 3 + 1</span>\n<span class=\"lineNumber\">30</span>          max = i - j + <span>1</span>;\n<span class=\"lineNumber\">31</span>        }\n<span class=\"lineNumber\">32</span>      }\n<span class=\"lineNumber\">33</span>      j++;\n<span class=\"lineNumber\">34</span>    }\n<span class=\"lineNumber\">35</span>  }\n<span class=\"lineNumber\">36</span>  <span>return</span> s.substr(begin, max);\n<span class=\"lineNumber\">37</span>};</code></pre> \n\n<h3>总结</h3>\n<p>其实，算法对笔者这类非天才开发者来说，需要在日常中多思考和积累，临时抱佛脚是不现实的。</p>\n","title":"动态规划浅解","date":"2021/12/11","tags":["算法"],"mainImg":"https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=400","intro":"动态规划到底是什么玩意?"}},"__N_SSG":true}
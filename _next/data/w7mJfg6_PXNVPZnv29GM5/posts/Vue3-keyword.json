{"pageProps":{"post":{"slug":"Vue3-keyword","content":"\n工作需要，从`React`转主力`Vue`开发，因此再看一遍`vue`的文档，故在此总结。\n\n### Base\n\n#### 实例和增强型功能\n\n> 可以同时创建多实例\n\n通过`createApp`函数接收一个根组件`App`来创建`App`实例，再通过实例方法`use()`集成插件功能，例如`pinia`和`vue-router`等，最后使用`mount()`方法并传入一个节点或者`CSS`选择器，最终挂载在一个实际的`DOM`节点上。\n\n```js\nconst app = createApp(App)\napp.use(router).use(createPinia()).mount('#root')\n```\n\n\n\n#### 全局错误监听\n\n```js\napp.config.errorHandle = (err) => {\n  // 处理应用级别的错误，捕获所有子组件未处理的错误\n \t// 发生错误时，记录信息，重定向到统一的错误页面\n}\n```\n\n#### 全局资源注册\n\n注册全局可用的组件：\n\n> 可以全局注册一些自定义的组件，后续不用重复写导入语句\n\n```js\napp.component('CustomButton', CustomButton);\n```\n\n比如`element-plus`可以在这里全局注册所有的`icon`，当然也可以按需引入。\n\n#### 模板语法\n\n```vue\n<template>\n\t<!-- 插值 -->\n  <span>Message: {{ msg }}</span>\n\n\t<!-- 字符串和字符串原始标签渲染 -->\n\t<p>Using text interpolation: {{ rawHtml }}</p>\n\t<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n\t\n\t<!-- v-xx 指令，绑定标签的 id 属性和值，如下的值是表达式 -->\n\t<div v-bind:id=\"dynamicId\"></div>\n\t<!-- 指令简写 -->\n\t<div :id=\"dynamicId\"></div>\n\t<!-- 动态参数，灵活设置属性 -->\n\t<a :[attributeName]=\"url\"> ... </a>\n\t<!-- 动态参数 + 函数表达式作为值，值为函数则会调用取返回值 -->\n\t<a :[attributeName]=\"generateUrlFunction\"> ... </a>\n\t\n\t<!-- 布尔值的属性，根据表达式转布尔值的结果决定最终是否添加此属性 -->\n\t<button :disabled=\"isButtonDisabled\">Button</button>\n\n\t<!-- 动态绑定多值 objectOfAttrs 为 {id: 'id', class: 'class'} -->\n\t<div v-bind=\"objectOfAttrs\"></div>\n\t<!-- 简写 -->\n\t<div :=\"objectOfAttrs\"></div>\n\n\t<!-- 表达式 -->\n\t{{ number + 1 }}\n  {{ ok ? 'YES' : 'NO' }}\n  {{ message.split('').reverse().join('') }}\n  <div :id=\"`list-${id}`\"></div>\n\t\n\t<!-- 新指令 v-on 和简写，监听事件 -->\n  <a v-on:click=\"doSomething\"> ... </a>\n  <a @click=\"doSomething\"> ... </a>\n\t<!-- 动态事件名，动态参数需要避免空格和引号这些不合法的HTML属性名 -->\n\t<a @[eventName]=\"doSomething\">\n  \n  <!-- 修饰符后缀，简化事件处理函数的内部优化逻辑 -->\n  <form @submit.prevent=\"onSubmit\">...</form>\n  \n  <!-- 条件渲染，甚至可以在 template 上设置条件 v-if -->\n  <h1 v-if=\"awesome\">Vue is awesome!</h1>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n\t<h1 v-else>Oh no 😢</h1>\n  <!-- 低切换成本 -->\n  <h1 v-show=\"ok\">Hello!</h1>\n   \n  <!-- 循环渲染，支持在 template 上设置，确保 key -->\n  <li v-for=\"item in items\" :key=\"item.id\">\n    {{ item.message }}\n  </li>\n  <!-- 1..n 好吧，挺好的 -->  \n  <span v-for=\"n in 10\">{{ n }}</span>\n\n</template>\n```\n\n\n\n在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中\n\n绑定在表达式中的方法每次更新都会执行，因此不应该产生渲染、数据改变、触发异步事件，**不要将副作用方法放在组件表达式中**。\n\n> 模板表达式访问的全局对象是一个白名单，列于此：[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3)\n\n修饰符图示：\n\n![](mdImgs/directive.69c37117.png)\n\n#### 响应式基础\n\n一律使用`声明式API`。\n\n> 在 Vue 中，状态都是默认深层响应式的。依靠深层响应性，响应式对象内的嵌套对象依然是代理。\n\n`vue3` 数据响应式基于`Proxy`，这就意味着在某个阶段创建的对象赋值给组件之后，此对象和组件上的代理对象是不相等的。\n\n重用的组件内部函数可能会共享状态，多个实例同时访问将会导致状态不可预测，要保持组件实例某些状态独立性，可以在`created`生命周期中创建某些限制。\n\n```vue\n<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n\nfunction increment() {\n  state.count++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ state.count }}\n  </button>\n</template>\n```\n\n>[nextTick()](https://staging-cn.vuejs.org/api/general.html#nexttick)：控制更新时机，此方法将内部传入的函数执行时机设置在下一个 DOM 更新完成之后，类似于`React.useEffectLayout`\n\n##### reactive 的局限性\n\n1. 仅对对象类型有效（对象、数组和 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#使用键的集合对象)），而对 `string`、`number` 和 `boolean` 这样的 [原始类型](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive) 无效。\n2. 因为 Vue 的响应式系统是通过 property 访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。\n\n也就是说将响应式对象的 property 赋值或解构至本地变量时，或是将该 property 传入一个函数时，我们会失去响应性。\n\n解决其局限性的替代品：`ref()`\n\n```react\nimport { ref } from 'vue'\n\nconst count = ref(0)\n```\n\n> `ref`包装了一个带 `.value`属性的值（未来可能增加优化体验的语法糖）\n\n`ref`还有几个特征：\n\n- 在模板中的顶层属性插值使用`ref`是能自动解包，不必使用`.value`取值，如果`ref`是某个对象的属性值，则依然需要`.value`\n- 将`ref`作为`reactive`对象的属性值时也会自动解包，这里需要关注其深层和浅层`reactive`([浅层响应式对象](https://staging-cn.vuejs.org/api/reactivity-advanced.html#shallowreactive))\n- Array 和 Map 不会解包\n\n\n\n#### 计算属性\n\n计算属性(`computed`)用于`描述依赖响应式状态的复杂逻辑`，避免在`template`中写复杂的表达式。\n\n> 计算属性严格保持无副作用，避免直接修改计算属性值，尤其是无意识的数组sort()/reverse()等操作\n\n使用`computed()`缓存基于响应式数据依赖的计算结果，例如：\n\n```vue\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// 一个计算属性 ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>\n```\n\n#### 类与样式绑定\n\n> 类似 React 中的第三方库 classnames\n\n切换动态`class`的示例：\n\n基于`isActive`的真假来设置以`key`为类名的方案，并且和原有`class`进行合并。\n\n```vue\n<div\n  class=\"static\"\n  :class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n\n> 在复杂情况下可以将内联的绑定对象单独抽出来。\n\n```vue\n<script setup>\n\tconst isActive = ref(true)\n  const error = ref(null)\n\n  const classObject = computed(() => ({\n    active: isActive.value && !error.value,\n    'text-danger': error.value && error.value.type === 'fatal'\n  }))\n</script>\n<template>\n\t<div :class=\"classObject\"></div>\n</template>\n```\n\n> 也可以传入数组，数组将会转化表达式为其值，另外需要注意组件属性透传合并到子组件的根元素`class`属性上，需要制定合并位置则需要单独设置`$attrs`表达式。\n\n样式方面需要注意的是`:style`支持驼峰命名法和短横线命名的实际`CSS`名称作为`key`值，为复杂样式绑定样式对象或者计算属性能提高可读性，如果绑定数组则会合并数组元素的样式对象。\n\n> Vue 支持在运行时自动为`:style`设置的样式添加浏览器前缀。\n\n样式支持多值：\n\n```html\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\n浏览器渲染支持的最后一个值。\n\n#### 事件处理\n\n事件处理器的值分为：\n\n- 内联事件处理器：内联JavaScript语句\n- 方法事件处理器：组件的方法访问\n\n前者在场景简单时使用，后者更常用，也很容易获取到事件上的`DOM`元素（通过`event.target.tagName`）。\n\n有一个特殊的内联场景，需要访问原生的`DOM`：\n\n```vue\n<template>\n\t<!-- 使用特殊的 $event 变量 -->\n  <button @click=\"warn('Form cannot be submitted yet.', $event)\">\n    Submit\n  </button>\n\n  <!-- 使用内联箭头函数 -->\n  <button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n    Submit\n  </button>\n</template>\n```\n\n即可活动`DOM`。\n\n常用的事件修饰符：\n\n- `.stop`\n- `.prevent`\n- `.self`\n- `.capture`\n- `.once`\n- `.passive`\n\n作用如下：\n\n```html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n\n<!-- 添加事件监听器时，使用 `capture` 捕获模式 -->\n<!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- 点击事件最多被触发一次 -->\n<a @click.once=\"doThis\"></a>\n\n<!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->\n<!-- 以防其中包含 `event.preventDefault()` -->\n<div @scroll.passive=\"onScroll\">...</div>\n\n<!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 仅当没有按下任何系统按键时触发 -->\n<button @click.exact=\"onClick\">A</button>\n\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + 点击 -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n`.passive` 修饰符一般用于触摸事件的监听器，可以用来[改善移动端设备的滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#使用_passive_改善的滚屏性能)。\n\n还有非常有用的按键修饰符：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获“Delete”和“Backspace”两个按键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n和鼠标修饰符：\n\n- `.left`\n- `.right`\n- `.middle`\n\n\n\n#### 表单输入绑定\n\n`react`需要为`input`设置值和`onChange`监听以改变值，`vue`做了优化：\n\n```vue\n<template>\n\t<input v-model=\"text\" />\n</template>\n```\n\n以下元素都兼容：\n\n- input\n- Textarea\n- select\n\n`textarea`不支持插值，务必使用`v-model`，如下复选框需要注意值：\n\n```vue\n<template>\n\t<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />\n</template>\n```\n\n单选框：\n\n```html\n<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />\n```\n\n选择器：\n\n```html\n<select v-model=\"selected\">\n  <!-- 内联对象字面量 -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n##### 修饰符 \n\n非常有用的修饰符：\n\n- .trim\n- .lazy\n- .number\n\n表单输入有两个标准事件：\n\n- oninput\n- onchange\n\n`vue`很酷，按照规范区分了两个事件，我们可以按需要监听。\n\n`oninput`即在输入变化时调用监听函数，`onchange`在按下`enter`或者脱离输入框之后调用监听函数，`.lazy`修饰符可以优化渲染次数。\n\n> React 的`onChange`事件却调用了原生的`oninput`事件，一个无法再弥补的错误。\n\n\n\n#### 生命周期浅解\n\n生命周期函数设置在某些时间段、某些状态过程节点执行。\n\n组件的生命周期如下图所示：\n\n![](mdImgs/lifecycle.16e4c08e.png)\n\n#### 侦听器\n\n`watch`制定的响应式数据（变化的状态），执行制定的函数，类似`react useEffect`。\n\n示例：\n\n```js\nconst x = ref(0)\nconst y = ref(0)\n\n// 单个 ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 多个来源组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n侦听的目标将会传入侦听处理函数，需要注意不能侦听`reactive的property`。\n\n> watch 支持强制深度侦听，添加第三个参数即可\n>\n> ```js\n> {\n>   deep: true\n> }\n> ```\n\n`watch`是懒执行的，也就是说第一次不会执行，只有源变化了才执行。\n\n如果需要在首次执行，则使用`watchEffect`代替。\n\n> watchEffect 可以自动分析副作用发生期间的源并且追踪依赖\n\n```js\nwatchEffect(async () => {\n  const response = await fetch(url.value)\n  data.value = await response.json()\n})\n```\n\n默认情况下，侦听回调都会在组件更新之前调用，因此可能会出现侦听器回调中访问的`DOM`是更新之前的状态，如果想确保其访问的`DOM`最新，则需要在最后一个`option`对象`param`指明`flush: 'post'`选项，这种行为称为`watchPostEffect`刷新（可以导入此函数直接使用）。\n\n> 同步创建的侦听器会再组件卸载时自动停止，异步创建的侦听器则需要调用创建函数返回的函数（姑且称为`unwatch`)主动停止侦听器。\n\n#### 模板 Ref\n\n`template`中元素可以通过`ref`属性获取到`DOM`。\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n亦或是多个`DOM`，挂载后自动填充：\n\n> ref 可以是函数，ref 可以给组件属性赋值，此时可以取得组件实例（不推荐使用此方法实现父子组件的交互），并且`<secript setup>`语法糖的组件默认不支持此特性，使用此语法糖将默认设置组件为私有状态，除非子组件通过`defineExpose`这主动暴露自己的数据。\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst list = ref([\n  /* ... */\n])\n\nconst itemRefs = ref([])\n\nonMounted(() => console.log(itemRefs.value))\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n> 应该注意的是，ref 数组**不能**保证与源数组相同的顺序。\n\n#### 组件基础\n\n将`vue`组件单独定义在一个`.vue`文件中，我们称之为`single file component`（单文件组件）。\n\n在`setup`语法糖中，使用`defineProps`函数定义`props`类型。\n\n> setup 语法糖中 defineProps/defineEmits 都是全局宏定义，不需要显式引入\n\n组件可以通过自定义事件监听来实现父组件交互。\n\n```vue\n// 父组件\n<template>\n\t<BlogPost\n  ...\n  @enlarge-text=\"postFontSize += 0.1\"\n />\n</template>\n\n// 子组件\n<!-- BlogPost.vue, 省略了 <script> -->\n<template>\n  <div class=\"blog-post\">\n    <h4>{{ title }}</h4>\n    <button @click=\"$emit('enlarge-text')\">Enlarge text</button>\n  </div>\n</template>\n```\n\n父组件传递自定义事件`enlarge-text`，子组件监听点击事件，监听函数显示地调用了`$emit('enlarge-text')`来引用父组件传递来的自定义事件。\n\n`$emit`是内置的方法，这些事件也可以显示地声明，在`setup`语法糖中，使用`defineEmits`来声明。\n\n```vue\n<script setup>\n\tconst emit = defineEmits(['enlarge-text'])\n</script>\n<template>\n\t<button @click=\"emit('enlarge-text')\">\n    change\n  </button>\n</template>\n```\n\n##### 插槽\n\n组件中可以传递 HTML 内容或其他组件：\n\n```html\n<AlertBox>\n  Something bad happened.\n</AlertBox>\n```\n\n传入的内容在组件内何处显示，取决于组件内`slot`元素的位置。\n\n`HTML`只允许少数的特殊元素省略其关闭标签，最常见的是`input`和`img`，其他的元素最佳实践就是主动保持闭合标签。\n\n\n\n### 深入\n\n\n\n#### 组件注册\n\n全局注册之前说过，它的缺陷在于构建系统无法移除未使用的组件（tree-shaking），在大型项目中依赖关系将会因此变得模糊，全局变量的数量骤增。\n\n而在单文件组件中使用`setup`语法糖，导入的组件可以直接在`template`中使用，即使组件名是大驼峰格式，也可以在使用时直接用短横线命名调用。\n\n\n\n#### Props\n\n区分组件透传和组件本身的参数依赖于`props`声明，使用`setup`语法糖时需要用`defineProps`显式声明。\n\n`props`名字建议使用小驼峰格式，同时可以避免在其作为属性`key`时必须带引号。在子组件传递`props`时，会自动转为短横线命名。\n\n静态和动态传值的区别在于是否使用`v-bind`或者缩写格式，任何类型的值都可以作为`props`传递。\n\n> 类型也可以是自定义的类或者构造函数\n\n通常显式的类型如下：\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Date`\n- `Function`\n- `Symbol`\n\n- Object(传递对象时，不要在子组件修改对象内部的数据)\n\n`Props`的传递遵循`单项数据流`的原则，保持了数据流的清晰度，降低复杂数据流的心智负担。\n\n如果子组件仅仅需要父组件传一个初始值，则子组件应该在本地创建一个局部属性保存初始值，亦或是定义一个基于`props`的计算属性。\n\n\n\n所有的类型例子：\n\n```js\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // Number 类型的默认值\n  propD: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propE: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  propF: {\n    validator(value) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propG: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n通常我们只需要用到最简单的几个类型，如果过于复杂，或许可以想想有没有什么可以优化的。\n\n","title":"Vue3 keyword","date":"2022/6/16","tags":["Vue"],"mainImg":"https://images.unsplash.com/photo-1518818608552-195ed130cdf4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NTUzNDc3OTI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1518818608552-195ed130cdf4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NTUzNDc3OTI&ixlib=rb-1.2.1&q=80&w=400","intro":"Vue3 文档关键内容总结"}},"__N_SSG":true}
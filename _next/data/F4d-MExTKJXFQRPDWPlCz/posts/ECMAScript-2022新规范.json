{"pageProps":{"post":{"slug":"ECMAScript-2022新规范","content":"\n\n\n## 前言\n\n`ECMAScript` 是标准化的 `JavaScript` 语言，于 1997 年发布了第一版，现已发展成为世界上使用最广泛的通用编程语言之一。\n\n`ECMAScript 2022 Language`是 ECMAScript 语言规范的第 13 版，因此我们也可以称之为`ES13`!\n\n那么，今年新增了哪些内容呢？\n\n\n\n### 类增强\n\n简单来说有以下三点：\n\n- 属性可以通过以下方式创建\n  - 公共的实例字段\n  - 静态的公共字段\n- 新增私属性插槽（井号）\n  - 私有字段（私有实例字段和私有静态字段）\n  - 私有方法和访问器（非静态）\n- 静态的初始化块\n\n直接看代码：\n\n```js\nclass MyClass {\n  instancePublicField = 1; // 公共实例字段\n  static staticPublicField = 2; // 静态公共字段\n\n  #instancePrivateField = 3; // 私有实例字段\n  static #staticPrivateField = 4; // 静态私有字段\n\n  #nonStaticPrivateMethod() {}\n  get #nonStaticPrivateAccessor() {} // 非静态私有访问器\n  set #nonStaticPrivateAccessor(value) {}\n\n  static #staticPrivateMethod() {} // 私有静态方法\n  static get #staticPrivateAccessor() {} // 静态访问器\n  static set #staticPrivateAccessor(value) {}\n\n  static {\n    // 静态的初始化块\n  }\n\n\tconstructor(value) {\n    this.property = value; // 公共实例字段\n  }\n}\n```\n\n\n\n举一个静态初始化块的例子：\n\n```js\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static { // (A)\n    for (const [english, german] of Object.entries(this.translations)) {\n      this.englishWords.push(english);\n      this.germanWords.push(german);\n    }\n  }\n}\n```\n\n通过使用静态初始化块，我们可以将所有类相关的代码放在类的内部。\n\n上述例子中，可以将初始化两个`word`数组的过程优化到静态初始化块内部，从而实现我们需要的效果，如果需要还可以访问私有插槽属性。\n\n需要注意的是：\n\n- 一个类可以有多个静态初始化块\n- 静态初始化块和静态属性可以交错初始化\n- 超类（superclass）的静态初始化块在子类的静态初始化块之前执行\n\n此外，类的私有化属性插槽可以通过`in`操作符检查，举个例子：\n\n```js\nclass ClassWithPrivateSlot {\n  #privateSlot = true;\n  static hasPrivateSlot(obj) {\n    return #privateSlot in obj;\n  }\n}\n\nconst obj1 = new ClassWithPrivateSlot();\nassert.equal(\n  ClassWithPrivateSlot.hasPrivateSlot(obj1), true\n);\n\nconst obj2 = {};\nassert.equal(\n  ClassWithPrivateSlot.hasPrivateSlot(obj2), false\n);\n```\n\n\n\n### 顶层 await\n\n规范新增顶层`await`支持，现在我们可以直接在模块内使用顶层`await`，而不必再额外进入异步函数内再使用`await`。\n\n\n\n看实例：\n\n```js\nconst res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\").then(\n  (response) => response.json()\n);\n\nconsole.log(\"res is:\", res);\n```\n\n保存上述内容为文件`index.mjs`，使用`node v17.5`以上版本或`bunjs`直接运行：\n\n`node index.mjs`即可直接获取到输出。\n\n那么，我们可以在什么地方使用这个特性呢？举个例子：\n\n```js\n// first.mjs\nconst response = await fetch('http://example.com/first.txt');\nexport const first = await response.text();\n\n// main.mjs\nimport {first} from './first.mjs';\nimport {second} from './second.mjs';\nassert.equal(first, 'First!'); // true\nassert.equal(second, 'Second!'); // true\n```\n\n有了顶层`await`，我们可以像使用同步导出那样直接导出异步的值。\n\n大致等同于以下代码：\n\n`first.mjs`:\n\n```\nexport let first;\nexport const promise = (async () => { // (A)\n  const response = await fetch('http://example.com/first.txt');\n  first = await response.text();\n})();\n```\n\n`main.mjs`:\n\n```\nimport {promise as firstPromise, first} from './first.mjs';\nimport {promise as secondPromise, second} from './second.mjs';\nexport const promise = (async () => { // (B)\n  await Promise.all([firstPromise, secondPromise]); // (C)\n  assert.equal(first, 'First content!');\n  assert.equal(second, 'Second content!');\n})();\n```\n\n方便了不少，不是吗？\n\n### error.cause\n\n为`Error`及其子类添加`cause`属性，更方便地传递错误原因，增强传递错误信息的能力。\n\n```js\nfunction readFiles(filePaths) {\n  return filePaths.map(\n    (filePath) => {\n      try {\n        // ···\n      } catch (error) {\n        throw new Error(\n          `While processing ${filePath}`,\n          {cause: error}\n        );\n      }\n    });\n}\n```\n\n现在，可以访问错误对象的`cause`属性获取更多详情。\n\n### .at()\n\n就像使用`python`一样使用`JavaScript`，通过下标访问数组变得容易，具有显式的函数支持，此外跟直接使用`[]`访问不一样的是，`.at()`支持传负数参数进行逆序取值。\n\n### 正则表达式Flag：/d\n\n看例子：\n\n```js\nconst matchObj = /(a+)(b+)/d.exec('aaaabb');\n\nassert.equal(\n  matchObj[1], 'aaaa'\n);\nassert.deepEqual(\n  matchObj.indices[1], [0, 4] // (A)\n);\n\nassert.equal(\n  matchObj[2], 'bb'\n);\nassert.deepEqual(\n  matchObj.indices[2], [4, 6] // (B)\n);\n```\n\n通过`d`执行的正则表达式匹配，可以得到匹配的元素的起始下标。\n\n\n\n### Object.hasOwn(obj, propKey)\n\n`Object.hasOwn(obj, propKey)`提供了一种安全的方式通过属性`key`检查对象是否含有非继承的目标属性。\n\n```js\nconst proto = {\n  protoProp: 'protoProp',\n};\nconst obj = {\n  __proto__: proto,\n  objProp: 'objProp',\n}\n\nassert.equal('protoProp' in obj, true); // (A)\n\nassert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B)\nassert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)\n```\n\n\n\n## 最后\n\n众所周知：\n\n`JavaScript`和`ECMAScript`的区别在于，前者是一个不同平台实现的编程语言，后者是这门语言的标准规范，平台基于此规范实现这门语言。\n\n`ECMAScript`由`TC39`标准委员会设计，其成员来自各大科技公司和其他平台等等，每年都会在年中发布最新的规范。\n\n不同的提案经过四个阶段，最终才会进入规范，在进入规范之前不建议使用，因为其始终是不稳定的，关注每年的新增内容即可。\n\n\n\n\n\n","title":"ECMAScript 2022新规范","date":"2022/7/10","tags":["JavaScript","规范","ECMAScript"],"mainImg":"https://images.unsplash.com/photo-1451187580459-43490279c0fa?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NTc0NTMyODg&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1451187580459-43490279c0fa?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NTc0NTMyODg&ixlib=rb-1.2.1&q=80&w=400","intro":"一年一度的ECMAScript规范发布，看看今年有什么新内容！"}},"__N_SSG":true}
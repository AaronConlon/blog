{"pageProps":{"post":{"slug":"创建一个支持commonjs和esm的混合npm包","contentHtml":"<p>我们如何能轻松地创建一个同时支持<code>ESM</code>和<code>Commonjs</code>规范进行引入的<code>NPM package</code>?</p>\n<p>最好不需要创建两份源码,不需要使用诸如<code>webpack</code>之类的工具.</p>\n<h2>起始</h2>\n<p>这个问题由来已久,寻找一个使用单份源码创建一个轻松同时支持<code>Commonjs</code>和<code>ES Modules</code>的<code>NPM package</code>的解决方案可能会让人很迷惑.</p>\n<blockquote>\n<p>同时支持<code>ESM</code>和<code>Commonjs</code>的<code>NPM Package</code>有时被开发者们称之为<code>Hybird package</code>,使用者可以轻松通过<code>import</code>或者<code>require</code>语法引入目标<code>package</code>.</p>\n</blockquote>\n<p>对于这个话题,开发者们众说纷纭,我们可以在网上轻松找到众多相关话题和<code>\"有效的解决方案\"</code>,但是在许多场景下存在一定的缺陷.</p>\n<p>许多方案需要使用<code>Webpack</code>或者<code>Rollup</code>等工具,甚至使用自定义脚本和其他构建工具,亦或是创建和维护使用<code>Commonjs</code>和<code>ES Modules</code>规范编写的双重源码库,然而大多数方案都无法生成高效的纯<code>ESM</code>代码.</p>\n<p>阅读<a href=\"https://nodejs.org/api/\">Node documentation</a>的时候,文档提及我们可以使用<code>.mjs</code>和<code>.cjs</code>扩展名来标识当前文件使用的是<code>ES Modules</code>规范或者<code>Commonjs</code>规范.</p>\n<h3>扩展名方案的问题</h3>\n<p>在说明我们最后的方案之前,让我们先来谈谈一些备受吹捧的解决技巧.</p>\n<blockquote>\n<p>为何不使用<code>.mjs</code>或者<code>.cjs</code>扩展名来表明内部代码规范?</p>\n</blockquote>\n<p><code>Node</code>支持源代码使用扩展名来标识源文件类型,乍一看当前特性合乎逻辑,扩展名的确通常用于标识文件类型.</p>\n<p>但是,这个特性仅仅适用于简单或独立的非混合案例.</p>\n<p>如果你需要编写一个<code>hybird</code>模块,并且使用了<code>.mjs</code>和<code>.cjs</code>扩展名特性,这意味着你需要编写两份针对不同规范的源代码,或者你需要使用第三方工具或者开发自己的工具去复制源码,并更改扩展名以及对不同源码进行适当的调整和修复,来满足使用此模块的开发者的引入方案.</p>\n<p><code>ESM</code>代码需要使用<code>import</code>关键字指明导入文件的路径.如果你从一个路径导入了具有<code>.mjs</code>扩展名的模块,那么则需要对代码进行一些微调才能在<code>.cjs</code>文件中引入此目标模块,反之亦然.</p>\n<p>甚至,许多前端工具链之间都不能很好地支持<code>.mjs</code>文件,一些 web 服务器缺乏对<code>.mjs</code>类型文件的<code>MIME</code>类型定义.也许你喜欢的打包工具目前甚至不能识别这类扩展名文件.所以,你得编写额外的配置或者引入其他插件来管理这些文件.</p>\n<h3>package.json type 属性的问题</h3>\n<blockquote>\n<p>还好,我们还有其他选择,例如设置<code>package.json</code>的<code>type</code>字段定义.</p>\n</blockquote>\n<p>为了解析和判定<code>.js</code>文件是一个<code>ES Module</code>还是一个<code>Commonjs Module</code>,Nodejs 支持在<code>package.json</code>中设置<code>type</code>字段属性,根据此字段的值来约定<code>.js</code>文件依据的规范是什么.</p>\n<p>如果<code>type</code>的值是<code>module</code>,则表明此项目下如若内部不包含其他层级的<code>package.json</code>,则所有的<code>.js</code>文件都遵循<code>ESM</code>规范,都是<code>ES Module</code>.</p>\n<p>如果<code>type</code>的值是<code>commonjs</code>,则表明这些<code>.js</code>代码遵循的是<code>commonjs</code>规范.</p>\n<blockquote>\n<p>通过显示设置<code>.cjs</code>或者<code>.mjs</code>后缀,可以覆盖此字段的声明.</p>\n</blockquote>\n<p>如果你的<code>package</code>源代码始终遵循一种规范,使用此<code>package</code>的开发者只能使用此规范进行引入,则此方案将能够良好运行.</p>\n<p>问题是当你想要开发一个<code>hybird</code>包,提供给开发者多种引入方案的选项,同时支持<code>ESM</code>和<code>Commonjs</code>规范的时候,这种方案并不不能简单满足我们的需求.</p>\n<p>为了使用<code>type</code>特性来实现<code>hybird</code>包的开发,需要引入更多额外的工具,让整个开发过程更加的复杂.</p>\n<h3>package.json 条件导出的问题</h3>\n<p>在<code>package.json</code>中使用<code>exports</code>条件导出可以定义一组入口点声明.</p>\n<p>我们的目标是创建<code>hybird</code>包,则需要为<code>require</code>和<code>import</code>两种方案定义不同的入口点.</p>\n<h5 style=\"text-align: left;color: darkblue\">package.json</h5>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span>{\n<span class=\"lineNumber\">2</span>    <span class=\"hljs-attr\">\"exports\"</span>: {\n<span class=\"lineNumber\">3</span>        <span class=\"hljs-attr\">\"import\"</span>: <span class=\"hljs-string\">\"./dist/mjs/index.js\"</span>,\n<span class=\"lineNumber\">4</span>        <span class=\"hljs-attr\">\"require\"</span>: <span class=\"hljs-string\">\"./dist/cjs/index.js\"</span>\n<span class=\"lineNumber\">5</span>    }\n<span class=\"lineNumber\">6</span>}</code></pre> \n\n<p>使用构建或者编译工具,我们使用一份源代码生成了两份打包文件来支持<code>ESM</code>和<code>Commonjs</code>引入.</p>\n<p>上述的<code>exports</code>属性指定了不同规范的加载入口点.</p>\n","title":"创建一个支持commonjs和esm的混合npm包","date":"2021/2/24","tags":["npm"],"mainImg":"https://images.unsplash.com/photo-1613764225051-a4b7649e938c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1613764225051-a4b7649e938c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"如何创建一个同时支持 esm 和 commonjs 两种规范的混合包?"}},"__N_SSG":true}
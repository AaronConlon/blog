{"pageProps":{"post":{"slug":"JavaScript-上下文和作用域","content":"\n### 前言\n\n`JavaScript` 中的`执行上下文`和`作用域`是每一个 `JavaScript` 开发者都必须了然于胸的知识点！\n\n### 执行上下文 \n\n> Execution context(`EC`)\n\n\n\n执行上下文可以被简称为`上下文`，红宝书上有所提及：“变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。”\n\n\n\n每一个上下文都有一个关联的`variable object`，这个上下文中定义的变量和函数都保存在这个变量对象上。\n\n\n\n上下文分为全局上下文和函数上下文（以及较少提及的 eval 函数上下文），`全局上下文`保存了所有非函数内的变量和函数，一个程序只会有一个全局上下文。\n\n\n\n我们通常称全局上下文对象为`globalThis`对象，这抹平了浏览器和 Node 端的变量名差异，当然在浏览器端，`window`即`globalThis`。\n\n\n\n> 使用`var`定义的顶级声明会自动成为`globalThis`的属性和方法，使用`let`、`const`则不会，我们之所以能访问到顶级`let/const`定义的变量并不是因为其作为`globalThis`的属性或方法，不要混为一谈。\n\n\n\n当函数被`调用`的时候，解释器都会为其创建一个`函数执行上下文`，每一个函数都有自己的执行上下文，再次强调：每一次`调用`都会创建新的执行上下文，并且在非箭头函数被调用时，默认在函数上下文的变量对象中初始化`arguments`和`this`的值。\n\n\n\n伴随着函数的执行，还需要记住`执行上下文栈`的概念，每一个函数上下文都按函数调用的生命周期压入栈中，全局上下文则在栈底。\n\n当当前执行的函数结束，则将其函数上下文出栈，接着执行下一个函数或代码块。\n\n举个例子：\n\n```js\nconst a = 10;\nfunction foo() {\n  console.log('Start func foo!')\n  function bar() {\n    console.log('Start func bar!')\n  }\n  bar();\n}\nfoo();\nconsole.log('GlobalContext');\n```\n\n这段简短的代码块在执行的时候，先将全局上下文存入上下文栈的栈底，然后调用函数`foo`，于是将`foo`函数的函数上下文压入执行上下文栈，在`foo`函数执行的时候，又调用了内部函数`bar`，于是继续将`bar`的函数上下文压入执行栈中。\n\n\n\n### 作用域\n\n作用域跟变量是对应关系，每一个变量都有自己的作用域。\n\n亦有人称作用域即源代码中定义变量的区域，作用域规定了如何查找变量，并且确定当前执行代码对变量的访问权限，在 JavaScript 中采用`lexical scoping`词法作用域，也被称为静态作用域。\n\n\n\n在`ES6`之前，作用域分为全局作用域和函数作用域，`ES6`新增了`块级作用域`的概念，用以隔离变量，划分作用域以防止同名变量冲突。\n\n来看一张能提现作用域分层的代码图示，取自 FunDebug 博客：\n\n![](https://image.fundebug.com/2019-03-15-WechatIMG465.png)\n\n执行函数时，内部变量取值要从其作用域中先查找值，然后逐级从定义函数的位置往上查找上级作用域中是否有此变量，直到查至全局作用域，如若查不到此变量则报错变量不存在。\n\n\n\n### 作用域和上下文\n\n作用域不等于上下文。\n\nJavaScript 作为解释型语言，其程序运行分为`解释`和`执行`两个阶段。\n\n解释阶段负责：\n\n- 词法分析\n- 语法分析\n- 作用域规则确定\n\n执行阶段负责：\n\n- 创建上下文\n- 执行代码\n- 垃圾回收♻️\n\n在解释阶段，作用域便确定了，因此在函数执行时我们要注意变量取值的来源，以免造成误解。\n\n上下文则是在函数执行之前创建，最明显的是`this`的指向是在这个时候确定的，跟解释阶段无关。\n\n引用`funDebug`一句话：\n\n> `执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。`\n\n不同的调用会产生不同的上下文，因此取得不同的变量值便顺理成章了。\n\n\n\n### 参考\n\n- [深入理解 JavaScript 作用域和作用域链 | Fundebug博客](https://blog.fundebug.com/2019/03/15/understand-javascript-scope/)\n- [JavaScript Execution Context - DEV Community 👩‍💻👨‍💻](https://dev.to/luigircruz/javascript-execution-context-38cn)\n- [Execution context, Scope chain and JavaScript internals | by Rupesh Mishra | Medium](https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c)\n\n","title":"JavaScript 上下文和作用域","date":"2022/1/9","tags":["JavaScript","面试题"],"mainImg":"https://images.unsplash.com/photo-1592424002053-21f369ad7fdb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDE3MjgwMzg&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1592424002053-21f369ad7fdb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDE3MjgwMzg&ixlib=rb-1.2.1&q=80&w=400","intro":"JavaScript 中的执行上下文、作用域和闭包机制是每一个 JavaScript 开发者都必须了然于胸的知识点！"}},"__N_SSG":true}
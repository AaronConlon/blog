{"pageProps":{"post":{"slug":"Javascript,I-promise","contentHtml":"<p>虽然此前我已经接触过一些异步编程的概念,并且有过一定的实际运用.但是自我感觉,我对<code>JavaScript</code>异步编程的了解依然十分浅显,因此我打算再次对<code>JavaScript</code>中的异步编程进行学习和总结,然后分享出来.</p>\n<h1>1. 前文</h1>\n<p>在对<code>Promise</code>知识进行总结之前,我将回顾一部分<code>JavaScript</code>与异步编程相关的知识.</p>\n<h2>1.1 浅述 JavaScript 调用栈</h2>\n<p>当函数之间发生内嵌调用,将产生<code>函数调用栈</code>.</p>\n<blockquote>\n<p><code>函数调用栈</code>是解释器追踪函数执行流的一种机制,函数入栈的同事也保存了其上下文环境.</p>\n</blockquote>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">h</span>(<span class=\"hljs-params\">z</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>().stack)\n<span class=\"lineNumber\">3</span>}\n<span class=\"lineNumber\">4</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">g</span>(<span class=\"hljs-params\">y</span>) </span>{\n<span class=\"lineNumber\">5</span>  h(y + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">6</span>}\n<span class=\"lineNumber\">7</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">x</span>) </span>{\n<span class=\"lineNumber\">8</span>  g(x + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span>f(<span class=\"hljs-number\">1</span>)</code></pre> \n\n<p>如上述,随着调用函数<code>f(1)</code>,调用栈内开始存储函数<code>f(1)</code>,内部调用了<code>g(2)</code>也被存入调用栈,最后将<code>h(3)</code>存入调用栈,当前函数执行结束即将之从调用栈定移除,接着执行可能存在的剩余代码,最终调用栈被清空,执行流程回到全局作用域,最终打印如下:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-built_in\">Error</span>\n<span class=\"lineNumber\">2</span>    at h (REPL3:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">3</span>    at g (REPL6:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">4</span>    at f (REPL9:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">5</span>    at REPL10:<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">1</span>\n<span class=\"lineNumber\">6</span>    at Script.runInThisContext (node:vm:<span class=\"hljs-number\">133</span>:<span class=\"hljs-number\">18</span>)\n<span class=\"lineNumber\">7</span>    at REPLServer.defaultEval (node:repl:<span class=\"hljs-number\">474</span>:<span class=\"hljs-number\">29</span>)\n<span class=\"lineNumber\">8</span>    at bound (node:domain:<span class=\"hljs-number\">416</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">9</span>    at REPLServer.runBound [<span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">eval</span>] (node:domain:<span class=\"hljs-number\">427</span>:<span class=\"hljs-number\">12</span>)\n<span class=\"lineNumber\">10</span>    at REPLServer.onLine (node:repl:<span class=\"hljs-number\">793</span>:<span class=\"hljs-number\">10</span>)\n<span class=\"lineNumber\">11</span>    at REPLServer.emit (node:events:<span class=\"hljs-number\">388</span>:<span class=\"hljs-number\">22</span>)</code></pre> \n\n<p>栈是有限度的,不同环境的栈空间大小不等,分配的栈空间被占满之后,将会引发栈溢出错误.</p>\n<h2>1.2 浅述浏览器事件循环</h2>\n<p><code>JavaScript</code>具有一个基于<code>事件循环(event loop)</code>的并发模型.</p>\n<p>我们可以简单的认为每个浏览器<code>tab</code>运行于一个简单的<code>事件循环</code>进程来实现<code>非阻塞</code>,浏览器中的诸多单一任务,例如:</p>\n<ul>\n<li>解析 HTML</li>\n<li>执行脚本中的 JavaScript 代码</li>\n<li>响应用户交互</li>\n<li>异步网络请求</li>\n<li>等等</li>\n</ul>\n<p>这些任务形成了独立于主线程的<code>任务队列(task queue)</code>,所有任务只能逐一通知主线程进行处理.由于<code>JavaScript</code>的单线程限制,即使<code>Web Worker标准</code>允许<code>JavaScript</code>脚本创建多个线程,但是子线程由主线程控制,且不可操作<code>DOM</code>,可以说<code>JavaScript</code>的本质依然是<code>单线程</code>.</p>\n<p>如下是<code>Philip Roberts</code>演讲的时候使用的示意图:</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png\" alt=\"\"></p>\n<p>当主线程执行栈上的同步任务执行完毕之后,就去读取<code>task queue</code>,按队列先进先出的属性,依次获取任务进行处理,然后重复检查主线程执行栈,通常我们为异步事件编写的<code>回调函数</code>,就进入了任务队列.</p>\n<p>如果再细分任务队列中的任务,依然可以分为:</p>\n<ul>\n<li>微任务(micro task)</li>\n<li>宏任务(macro task)</li>\n</ul>\n<p>像<code>setTimeout</code>和<code>setInterval</code>则是宏任务.</p>\n<blockquote>\n<p><strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>\n</blockquote>\n<h2>1.3 定时器简析</h2>\n<p><code>setTimeout(callback, ms)</code>函数创建了一个定时器等待若干毫秒, 然后将<code>callback</code>放入<code>task queue</code>,并且在等待计时器的其间脱离了主线程,这也就意味着如果主线程执行了耗时的同步任务,则任务队列被读取的时间就将被延迟了,因此可能不会在<code>ms</code>毫秒后执行<code>callback</code>回调函数.</p>\n<p>实际延时还有其他的影响因素.</p>\n<ul>\n<li>不同浏览器具有自己的<code>DOM_MIN_TIMEOUT_VALUE</code>,最小延时值.</li>\n<li>为了优化后台 tab 的加载损耗(以及降低耗电量),在未被激活的 tab 中定时器的最小延时限制为<code>1S</code>.</li>\n<li>追踪型脚本延时在后台 tabs 中,这个最小延时限制是 <code>10S</code>,这个限制会在文档第一次加载后的<code>30s</code>后生效.</li>\n</ul>\n<h2>1.4 显示 DOM 变化</h2>\n<p>对于大多数<code>DOM</code>元素的变化来说,它们的改动数据并不是实时更新的,<code>DOM</code>和<code>布局</code>的改动也与<code>事件循环</code>机制有关.如果需要频繁更新<code>DOM</code>,可以考虑<code>requestAnimationFrame()</code>函数.</p>\n<blockquote>\n<p><strong><code>window.requestAnimationFrame()</code></strong> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>\n</blockquote>\n<h2>1.5 event loop 阻塞和消除</h2>\n<p>来看看一个阻塞事件循环的例子🌰 From <code>Dr. Axel Rauschmayer</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>&#x3C;p>\n<span class=\"lineNumber\">2</span>  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"block\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"\"</span>></span>Block for 5 seconds<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span></span>\n<span class=\"lineNumber\">3</span>&#x3C;p>\n<span class=\"lineNumber\">4</span>    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"btn\"</span>></span>This is a button<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span>\n<span class=\"lineNumber\">5</span><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"statusMessage\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n<span class=\"lineNumber\">6</span><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"lineNumber\">7</span><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'block'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, onClick);\n<span class=\"lineNumber\">8</span><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'btn'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, onClickBtn);\n<span class=\"lineNumber\">9</span> \n<span class=\"lineNumber\">10</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClickBtn</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">11</span>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"click the btn\"</span>)\n<span class=\"lineNumber\">12</span>}\n<span class=\"lineNumber\">13</span> \n<span class=\"lineNumber\">14</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onClick</span>(<span class=\"hljs-params\">event</span>) </span>{\n<span class=\"lineNumber\">15</span>  event.preventDefault();\n<span class=\"lineNumber\">16</span> \n<span class=\"lineNumber\">17</span>  setStatusMessage(<span class=\"hljs-string\">'Blocking...'</span>);\n<span class=\"lineNumber\">18</span> \n<span class=\"lineNumber\">19</span>  <span class=\"hljs-comment\">// Call setTimeout(), so that browser has time to display</span>\n<span class=\"lineNumber\">20</span>  <span class=\"hljs-comment\">// status message</span>\n<span class=\"lineNumber\">21</span>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">22</span>    sleep(<span class=\"hljs-number\">5000</span>);\n<span class=\"lineNumber\">23</span>    setStatusMessage(<span class=\"hljs-string\">'Done'</span>);\n<span class=\"lineNumber\">24</span>  }, <span class=\"hljs-number\">0</span>);\n<span class=\"lineNumber\">25</span>}\n<span class=\"lineNumber\">26</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setStatusMessage</span>(<span class=\"hljs-params\">msg</span>) </span>{\n<span class=\"lineNumber\">27</span>  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'statusMessage'</span>).textContent = msg;\n<span class=\"lineNumber\">28</span>}\n<span class=\"lineNumber\">29</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sleep</span>(<span class=\"hljs-params\">milliseconds</span>) </span>{\n<span class=\"lineNumber\">30</span>  <span class=\"hljs-keyword\">var</span> start = <span class=\"hljs-built_in\">Date</span>.now();\n<span class=\"lineNumber\">31</span>  <span class=\"hljs-keyword\">while</span> ((<span class=\"hljs-built_in\">Date</span>.now() - start) &#x3C; milliseconds);\n<span class=\"lineNumber\">32</span>}\n<span class=\"lineNumber\">33</span></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span></code></pre> \n\n<p>我给<code>button</code>加了点击监听,如上所示,当你点击链接触发监听函数的时候再点击<code>button</code>,事件循环被阻塞5秒.这个期间点击<code>button</code>的监听函数无法如<code>\"预期\"</code>马上执行其逻辑,阻塞状态结束之后,点击函数的监听效果才会出现.</p>\n<p>我们有两种方法消除事件循环的阻塞,其一便是将耗时的任务转移到<code>Worker API</code>中去,让另一个线程去处理.其二便是不使用同步的长时间等待逻辑,而是选择使用异步的方式去改写耗时的同步代码.例如上述的<code>sleep</code>函数便可以使用<code>setTimeout</code>来让我们达到异步的效果.</p>\n<h2>1.6 异步接收结果</h2>\n<p>首先,让我们来看看如何通过<code>事件处理机制</code>来异步获取结果,来看看一个<code>XMLHttpRequest</code>的例子:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">const</span> req = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();\n<span class=\"lineNumber\">2</span>req.open(<span class=\"hljs-string\">'GET'</span>, url);\n<span class=\"lineNumber\">3</span><span class=\"hljs-comment\">// req.send();</span>\n<span class=\"lineNumber\">4</span>req.onload = <span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">5</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">req.status === <span class=\"hljs-number\">200</span></span>)</span> {\n<span class=\"lineNumber\">6</span>    <span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">7</span>  } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">8</span>  \t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Error: <span class=\"hljs-subst\">${req.statusText}</span>`</span>) \n<span class=\"lineNumber\">9</span>  } \n<span class=\"lineNumber\">10</span>}\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span>req.onerror = <span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">13</span>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Error...'</span>)\n<span class=\"lineNumber\">14</span>}\n<span class=\"lineNumber\">15</span> \n<span class=\"lineNumber\">16</span>req.send();</code></pre> \n\n<p><code>req.send()</code>执行的时候只是将之添加到<code>任务队列</code>中,而非立刻执行此请求.因此,我们也可以将之写在设置<code>onload</code>和<code>onerror</code>事件的代码之前.</p>\n<p>类似<code>Vue</code>和<code>Angular</code>中我们有时候会看到如下代码:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// Vue</span>\n<span class=\"lineNumber\">2</span>&#x3C;button v-on:click=<span class=\"hljs-string\">\"fb\"</span>>\n<span class=\"lineNumber\">3</span>  Add <span class=\"hljs-number\">1</span>\n<span class=\"lineNumber\">4</span>&#x3C;/button>\n<span class=\"lineNumber\">5</span><span class=\"hljs-comment\">// Angular</span>\n<span class=\"lineNumber\">6</span><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">\"fb()\"</span>></span>\n<span class=\"lineNumber\">7</span>  some thing\n<span class=\"lineNumber\">8</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span></code></pre> \n\n<p>上述代码<code>并不是行内属性</code>,我们可以很灵活的利用<code>JavaScript</code>和框架的特性灵活编写代码,为<code>DOM</code>添加事件监听.</p>\n<blockquote>\n<p>上述示例代码风格只能给相应的属性设置一个值,后续的<code>onload</code>值将会覆盖前者.</p>\n</blockquote>\n<p>在<code>IE9</code>之后,更常见的事件处理机制的使用方案也许是<code>addEventListener</code>(IE8 则可以使用<code>attachEvent</code>进行 hack),这种方案能够更大限度的设置事件监听的范围,例如设置多个同类型的事件处理函数,删除某个监听函数等等.</p>\n<p>接着,我们来看看通过<code>callback</code>回调函数获取异步结果的示例:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// Node.js</span>\n<span class=\"lineNumber\">2</span>fs.readFile(<span class=\"hljs-string\">'file.txt'</span>, { <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">'utf8'</span>}, <span class=\"hljs-function\">(<span class=\"hljs-params\">error, text</span>) =></span> {\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">error</span>)</span> {\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span>  <span class=\"hljs-comment\">// 无错误</span>\n<span class=\"lineNumber\">7</span>  <span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">8</span>})</code></pre> \n\n<p>如上所示,如果读取文件内容顺利,将会执行回调函数.回调函数约定接收两个参数,一个是<code>错误</code>对象,另一个便是<code>预期数据</code>,如果我们不按约定编写回调函数,也不会报错.</p>\n<p>如上这种异步编程风格被称为<code>continuation-passing style(CPS)</code>,开发者总是使用一个回调函数作为参数去调用,显示的将<code>控制流</code>作为参数进行传递,开发者可以看到程序内部隐式的控制流跳转.</p>\n<p><code>CPS</code>挺有趣的,我们来看一个简单例子.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// 省略部分代码</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-keyword\">const</span> a = foo(x)\n<span class=\"lineNumber\">3</span><span class=\"hljs-keyword\">const</span> b = someFunction(a)</code></pre> \n\n<p>如果我们按<code>CPS</code>风格来写:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">const</span> b = foo(x, someFunction)</code></pre> \n\n<p>由此可见,我们可以在例如<code>惰性求值/异步/流程控制</code>等场景下编写上述风格的代码,<code>\"也许\"</code>是一种更好的选择(仁者见仁智者见智).</p>\n<p>来看另一个例子:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">input, callback</span>) </span>{\n<span class=\"lineNumber\">2</span>\t<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">3</span>    callback(input)\n<span class=\"lineNumber\">4</span>  }, <span class=\"hljs-number\">0</span>)\n<span class=\"lineNumber\">5</span>}\n<span class=\"lineNumber\">6</span><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'a'</span>)\n<span class=\"lineNumber\">7</span>foo(<span class=\"hljs-string\">'b'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">step2</span>(<span class=\"hljs-params\">param</span>) </span>{\n<span class=\"lineNumber\">8</span>\t<span class=\"hljs-built_in\">console</span>.log(param)\n<span class=\"lineNumber\">9</span>  foo(<span class=\"hljs-string\">'c'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">step3</span>(<span class=\"hljs-params\">param</span>) </span>{\n<span class=\"lineNumber\">10</span>  \t<span class=\"hljs-built_in\">console</span>.log(param)\n<span class=\"lineNumber\">11</span>  })\n<span class=\"lineNumber\">12</span> \t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'d'</span>)\n<span class=\"lineNumber\">13</span>})\n<span class=\"lineNumber\">14</span><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'e'</span>)</code></pre> \n\n<p>输出结果:<code> a e b d c</code>.</p>\n<p>回调和控制流相互嵌套,常常让我们写出<code>\"回调地狱\"</code>代码.</p>\n<p>在<code>Promise</code>出现之前,开发者们编写着各种回调函数,为了避免隐式<code>BUG</code>而孜孜不倦地检查异常处理逻辑,重复地为每一个回调函数编写冗长的<code>if error</code>错误监听.</p>\n<h1>2. Promise 异步</h1>\n<p><code>TC39</code>依据<code>Promise/A+</code>制定了<code>ES6 Promise</code>规范,自此<code>JavaScript</code>异步编程向前迈进了一大步,开发者们可以更好的编写异步代码以应对复杂的场景和需求.</p>\n<h2>2.1 promise 实例和状态转换</h2>\n<p><code>Promise</code>实例具有三种状态:</p>\n<ul>\n<li><code>pending</code>: 初始化</li>\n<li><code>fulfilled</code>: 成功</li>\n<li><code>rejected</code>: 失败</li>\n</ul>\n<blockquote>\n<p>fulfilled 和 rejected 统称<code>settled</code>.</p>\n</blockquote>\n<p>通过<code>Promise</code>构造器实例化一个<code>promise</code>的时候,其状态为<code>pending</code>.在实例化的时候传入一个函数<code>(execotor)</code>去处理状态转换逻辑.</p>\n<blockquote>\n<p>本文不会对<code>promise</code>做面面俱到的介绍,推荐阅读官方文档.</p>\n</blockquote>\n<p>首先,我们来创建一个<code>promise</code>实例:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">...</span>)</span> {\n<span class=\"lineNumber\">4</span>    resolve(value) <span class=\"hljs-comment\">// success</span>\n<span class=\"lineNumber\">5</span>  } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">6</span>  \treject(reason) <span class=\"hljs-comment\">// failure</span>\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>})\n<span class=\"lineNumber\">9</span>promise\n<span class=\"lineNumber\">10</span>  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">11</span>\t\t<span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">12</span>  })\n<span class=\"lineNumber\">13</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">14</span>\t\t<span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">15</span>  })\n<span class=\"lineNumber\">16</span>\t.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">reason</span> =></span> {\n<span class=\"lineNumber\">17</span>  \t<span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">18</span>  })</code></pre> \n\n<p>传入的函数内部,可以显示按逻辑指定下一个状态.下图是<code>MDN</code>提供的<code>Promise</code>状态转移图.</p>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"\"></p>\n<blockquote>\n<p><code>then</code>函数可以接收不同形参的函数以实现不同的状态处理逻辑,但是我们推荐使用单参数和使用 catch 处理错误的代码风格.</p>\n</blockquote>\n<p>需要注意的是,<code>promise</code>实例的状态转换是单向的,一旦<code>settled</code>则不可逆转.</p>\n<p><code>promise</code>支持链式调用,每个<code>then</code>函数内部最后将返回一个新的<code>promise</code>实例,默认返回一个值为<code>undefined</code>,状态为<code>fulfilled</code>的<code>promise</code>实例.</p>\n<p><strong><code>Promise</code>出现之前,编写可以一次性监听所有回调函数的错误处理逻辑是困难的,<code>Promise实例</code>的实例方法<code>catch</code>能应对链式调用之前所有的<code>then</code>函数错误和显示的<code>reject</code>行为</strong>.</p>\n<p>我们可以显示地使用<code>return value</code>指定返回的<code>promise</code>对象的值.举个例子:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>asyncFunc()\n<span class=\"lineNumber\">2</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v1</span>) </span>{\n<span class=\"lineNumber\">3</span>  \t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n<span class=\"lineNumber\">4</span>  \t<span class=\"hljs-comment\">// return Promise.resolve(1)  \t</span>\n<span class=\"lineNumber\">5</span>})\n<span class=\"lineNumber\">6</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v2</span>) </span>{\n<span class=\"lineNumber\">7</span>  \t<span class=\"hljs-built_in\">console</span>.log(v2); <span class=\"hljs-comment\">// 1</span>\n<span class=\"lineNumber\">8</span>})</code></pre> \n\n<p>除了<code>return</code>一个显示的值,在一些<code>Promise</code>相关的库源码中我们可能还会看到某些场景下返回一个<code>thenable</code>对象.</p>\n<blockquote>\n<p><code>thenable对象</code>: 任意具有<code>then</code>方法的对象.</p>\n</blockquote>\n<p>返回<code>thenable对象</code>的时候将执行其<code>then</code>方法,<code>Promise</code>实例对象也是<code>thenable对象</code>,因此在某些嵌套<code>Promise</code>的场景下,可以返回一个<code>异步函数调用</code>,就像这样:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>asyncFunc1()\n<span class=\"lineNumber\">2</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v1</span> =></span> {\n<span class=\"lineNumber\">3</span>  \tasyncFunc2()\n<span class=\"lineNumber\">4</span>  \t\t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v2</span> =></span> {\n<span class=\"lineNumber\">5</span>      \t<span class=\"hljs-comment\">//balabala</span>\n<span class=\"lineNumber\">6</span>    })\n<span class=\"lineNumber\">7</span>})\n<span class=\"lineNumber\">8</span> \n<span class=\"lineNumber\">9</span><span class=\"hljs-comment\">// 扁平化</span>\n<span class=\"lineNumber\">10</span>asyncFunc1()\n<span class=\"lineNumber\">11</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v1</span> =></span> asyncFunc2())\n<span class=\"lineNumber\">12</span>\t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">v2</span> =></span> {\n<span class=\"lineNumber\">13</span>  \t<span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">14</span>})</code></pre> \n\n<h2>2.2 Promise 静态方法</h2>\n<p><code>Promise</code>类具有两个能创建一个新的实例的静态方法:</p>\n<ul>\n<li>Promise.resolve(param)</li>\n<li>Promise.reject(param)</li>\n</ul>\n<p>二者区别在于返回的<code>promise</code>实例的状态,前者为<code>fulfilled</code>,后者为<code>rejected</code>.</p>\n<p>此外,<code>Promise</code>类还有如下几个静态方法:</p>\n<ul>\n<li><code>Promise.all(iterable)</code></li>\n<li><code>Promise.race(iterable)</code></li>\n<li><code>Promise.any(iterable)</code></li>\n<li><code>Promise.allSettled(iterable)</code></li>\n</ul>\n<p>这几个静态方法各有其应用场景.</p>\n<h3>2.2.1 all</h3>\n<p>首先,<code>Promise.all(iterable)</code>方法接收一个<code>iterable</code>对象作为参数,最终返回一个<code>promise 实例</code>.</p>\n<p>首先,如果<code>iterable</code>对象是空的,则返回的结果是空数组.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span></code></pre> \n\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a></li>\n<li><a href=\"https://notes.forkai.com/2017/11/06/javascript%E8%BF%9B%E9%98%B601%EF%BC%9A%E5%BC%82%E6%AD%A51-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/\">JavaScript进阶01：异步1-事件监听和回调函数 | forkai's Notes</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2069763/difference-between-event-handlers-and-callbacks\">architecture - Difference between event handlers and callbacks - Stack Overflow</a></li>\n<li><a href=\"https://stackoverflow.com/questions/6348494/addeventlistener-vs-onclick\">javascript - addEventListener vs onclick - Stack Overflow</a></li>\n<li></li>\n</ul>\n","title":"Javascript,I promise - 异步编程","date":"2021/4/9","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=400","intro":"Promise, JavaScript 世界中的异步处理对象.我阅读了 Dr.Axel 前辈的电子书,充满感激."}},"__N_SSG":true}
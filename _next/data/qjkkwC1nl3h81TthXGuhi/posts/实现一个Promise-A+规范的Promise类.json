{"pageProps":{"post":{"slug":"实现一个Promise-A+规范的Promise类","contentHtml":"<p>我之所以做这件事是因为我想更深入理解 <code>Promise</code> 的设计理念和设计原理，我看了一些文章和介绍，搜索了一些知识，也学习了其他人的 <code>Promise</code>实现源码。</p>\n<p>这真的很令我振奋，通过实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>类，我对<code>Promise</code>的理解有了不错的进步，那就废话少说，开始吧。</p>\n<h3>从规范到实现</h3>\n<p>在开始写代码之前，我们先阅读一下<a href=\"https://promisesaplus.com/\">Promises/A+</a>的官方文档。</p>\n<h4>几个术语</h4>\n<p>言而简之，官方文档上提及了五个术语，如下所示：</p>\n<ul>\n<li>Promise</li>\n<li>thenable</li>\n<li>value</li>\n<li>exception</li>\n<li>reason</li>\n</ul>\n<p><code>Promise</code>是一个具有<code>then</code>方法的对象或函数，并且此对象或者函数遵循<code>Promise/A+</code>规范。</p>\n<p><code>thenable</code>指的是一个对象或函数具有一个<code>then</code>方法</p>\n<p><code>value</code>是一个合法的<code>Javascript</code>值。</p>\n<p><code>exception</code>是一个使用<code>throw</code>语句抛出的值。</p>\n<p><code>reason</code>则是<code>Promise</code>状态转为<code>Rejected</code>的原因。</p>\n<h4>规范简述</h4>\n<p>阅读规范有助于我们编写代码，整理思路，最终写出一个能通过所有<code>Promise/A+</code>测试用例的<code>Promise</code>实现版本。</p>\n<h5>Promise State</h5>\n<ul>\n<li>\n<p>2.1.1 一个<code>Promise</code>的状态只有如下三种：</p>\n</li>\n<li>\n<p>pending 初始化状态</p>\n<ul>\n<li>2.1.1.1 可以显式转换状态至<code>fulfilled</code>或<code>rejected</code></li>\n</ul>\n</li>\n<li>\n<p>fulfilled 成功</p>\n<ul>\n<li>2.1.2.1 状态不可再转换</li>\n<li>2.1.2.2 具有一个不可改变的<code>value</code></li>\n</ul>\n</li>\n<li>\n<p>rejected 失败</p>\n<ul>\n<li>2.1.3.1 状态不可再转换</li>\n<li>2.1.3.2 具有一个不可改变的<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>不可改变意味着可以使用<code>===</code>进行比较，并且始终为<code>true</code>，并非完全的深层属性不可变。</p>\n</blockquote>\n<p>除此之外，使用<code>new</code>实例化的时候，我们需要为构造函数提供一个<code>executor</code>函数参数。</p>\n<h5>思考🤔</h5>\n<p>现在我们从最简单的状态需求开始，假设我们处于一个密闭空间，触手可及的只有手头的键盘。</p>\n<p>思考一下如何实现上述<code>Promise State</code>，用少量词汇组织将要写的代码的内容，例如：</p>\n<ul>\n<li>我的 Promise 实现命名为<code>Yo</code></li>\n<li><code>Yo</code>初始化的时候设置初始值和初始状态，状态可以转变为<code>fulfilled</code>或者<code>rejected</code>。</li>\n<li><code>Yi</code>具备两个静态方法来显式转换其状态：<code>fulfill</code>和<code>Reject</code>，当状态为<code>pending</code>时才执行逻辑，这样一来一旦状态改变后续再执行此方法就无碍了。</li>\n</ul>\n<blockquote>\n<p>注释里写明对应的规范信息条目</p>\n</blockquote>\n<p>很快，我们的实现如下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// 将一些常用到的变量保存起来，</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">'pending'</span>\n<span class=\"lineNumber\">3</span><span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">'fulfilled'</span>\n<span class=\"lineNumber\">4</span><span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">'rejected'</span>\n<span class=\"lineNumber\">5</span><span class=\"hljs-keyword\">const</span> nop = <span class=\"hljs-function\">() =></span> {}\n<span class=\"lineNumber\">6</span><span class=\"hljs-keyword\">const</span> $undefined = <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">7</span><span class=\"hljs-keyword\">const</span> $function = <span class=\"hljs-string\">\"function\"</span>\n<span class=\"lineNumber\">8</span><span class=\"hljs-comment\">// 使用 Symbol 为 Promise 的属性提供保护</span>\n<span class=\"lineNumber\">9</span><span class=\"hljs-keyword\">const</span> promiseState = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"promiseState\"</span>)\n<span class=\"lineNumber\">10</span><span class=\"hljs-keyword\">const</span> promiseValue = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"promiseValue\"</span>)\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Yo</span> </span>{\n<span class=\"lineNumber\">13</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">executor</span>)</span> {\n<span class=\"lineNumber\">14</span>    <span class=\"hljs-comment\">// executor 提前检查，如果有异常则不创建额外的内部变量和属性方法，直接抛出异常</span>\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">executor === $<span class=\"hljs-literal\">undefined</span></span>)</span> {\n<span class=\"lineNumber\">16</span>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"You have to give a executor param.\"</span>)\n<span class=\"lineNumber\">17</span>    }\n<span class=\"lineNumber\">18</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> executor !== $<span class=\"hljs-keyword\">function</span></span>)</span> {\n<span class=\"lineNumber\">19</span>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Executor must be a function.\"</span>)\n<span class=\"lineNumber\">20</span>    }\n<span class=\"lineNumber\">21</span>    <span class=\"hljs-built_in\">this</span>[promiseState] = PENDING <span class=\"hljs-comment\">// 2.1.1</span>\n<span class=\"lineNumber\">22</span>    <span class=\"hljs-built_in\">this</span>[promiseValue] = $undefined\n<span class=\"lineNumber\">23</span>    <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">24</span>      executor(<span class=\"hljs-built_in\">this</span>.$resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.$reject.bind(<span class=\"hljs-built_in\">this</span>))\n<span class=\"lineNumber\">25</span>    } <span class=\"hljs-keyword\">catch</span> (e) {\n<span class=\"lineNumber\">26</span>      <span class=\"hljs-built_in\">this</span>.$reject.bind(<span class=\"hljs-built_in\">this</span>)(e)\n<span class=\"lineNumber\">27</span>    }\n<span class=\"lineNumber\">28</span>  }\n<span class=\"lineNumber\">29</span> \n<span class=\"lineNumber\">30</span>  $resolve(value) {\n<span class=\"lineNumber\">31</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>[promiseState] !== PENDING) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">32</span>    <span class=\"hljs-built_in\">this</span>[promiseState] = FULFILLED <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">33</span>    <span class=\"hljs-built_in\">this</span>[promiseValue] = value <span class=\"hljs-comment\">// 2.1.2.2</span>\n<span class=\"lineNumber\">34</span>  }\n<span class=\"lineNumber\">35</span> \n<span class=\"lineNumber\">36</span>  $reject(reason) {\n<span class=\"lineNumber\">37</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>[promiseState] !== PENDING) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">38</span>    <span class=\"hljs-built_in\">this</span>[promiseState] = REJECTED <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">39</span>    <span class=\"hljs-built_in\">this</span>[promiseValue] = reason <span class=\"hljs-comment\">// 2.1.3.2</span>\n<span class=\"lineNumber\">40</span>  }\n<span class=\"lineNumber\">41</span>}</code></pre> \n\n<h5><code>then</code>方法</h5>\n<blockquote>\n<p><code>then</code>方法是<code>Promise/A+</code>规范的核心部分。</p>\n</blockquote>\n<p>一个<code>Promise</code>必须提供一个<code>then</code>方法以访问其<code>value</code>或<code>reason</code>,此方法需要接受两个可选参数：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>promise.then(onFulfilled, onRejected)</code></pre> \n\n<p>其规范如下：</p>\n<ul>\n<li>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选的\n<ul>\n<li>2.2.1.1 如果<code>onFulfilled</code>不是一个函数，则忽略此参数</li>\n<li>2.2.1.2 如果<code>onRejected</code>不是一个函数，则忽略此参数</li>\n</ul>\n</li>\n<li>2.2.2 如果<code>onFulfilled</code>是一个函数\n<ul>\n<li>2.2.2.1 此函数在<code>promise</code>状态为<code>fulfilled</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.2.2 此函数不可在<code>promise</code>状态为<code>fullfilled</code>之前被调用</li>\n<li>2.2.2.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.3 如果<code>onRejected</code>是一个函数\n<ul>\n<li>2.2.3.1 此函数在<code>promise</code>状态为<code>rejected</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.3.2 此函数不可在<code>promise</code>状态为<code>rejected</code>之前被调用</li>\n<li>2.2.3.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.4 <code>onFulfilled</code>和<code>onRejected</code>将被异步调用（在当前执行栈清空之前无法被调用）</li>\n<li>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为一个函数被调用（内部不应使用<code>this</code>值，原因在于严格模式和非严格模式的<code>this</code>值不一致）</li>\n<li>2.2.6 <code>then</code>可以在同一个<code>promise</code>实例上被多次调用，因此我们可以在不同的地方使用某个<code>promise.then</code>f方法\n<ul>\n<li>2.2.6.1 当<code>promise</code>状态为<code>fulfilled</code>时，所有的<code>then</code>上传入的<code>onFulfilled</code>函数将会按调用的次序依次执行</li>\n<li>2.2.6.2 当<code>promise</code>状态为<code>rejected</code>时，所有的<code>then</code>上传入的<code>onRejected</code>函数将会按调用的次序依次执行</li>\n</ul>\n</li>\n<li>2.2.7 <code>then</code>方法最终将返回一个新的<code>promise</code>实例: <code>promise2 = promise1.then(onFulfilled, onRejected)</code>\n<ul>\n<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个值<code>x</code>，执行<code>Promise</code>的解析步骤： <code>[[Resolve]](promise2, x)</code></li>\n<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>抛出一个异常<code>e</code>，则<code>promise2</code>直接<code>reject(e)</code></li>\n<li>2.2.7.3 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>fulfilled</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和值。</li>\n<li>2.2.7.4 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>rejected</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<h5>完善 ✍️</h5>\n<p>按规范的定义，在上述代码的基础下，我们来完善<code>then</code>方法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Yo</span> </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">executor</span>)</span> {\n<span class=\"lineNumber\">3</span>    ...\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-built_in\">this</span>[promiseConsumers] = []\n<span class=\"lineNumber\">5</span>    <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">6</span>      executor(<span class=\"hljs-built_in\">this</span>.$resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.$reject.bind(<span class=\"hljs-built_in\">this</span>))\n<span class=\"lineNumber\">7</span>    } <span class=\"hljs-keyword\">catch</span> (e) {\n<span class=\"lineNumber\">8</span>      <span class=\"hljs-built_in\">this</span>.$reject.bind(<span class=\"hljs-built_in\">this</span>)(e)\n<span class=\"lineNumber\">9</span>    }\n<span class=\"lineNumber\">10</span>  }\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span>  $resolve(value) {\n<span class=\"lineNumber\">13</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>[promiseState] !== PENDING) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">14</span>    <span class=\"hljs-built_in\">this</span>[promiseState] = FULFILLED <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-built_in\">this</span>[promiseValue] = value <span class=\"hljs-comment\">// 2.1.2.2</span>\n<span class=\"lineNumber\">16</span>    <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span> \n<span class=\"lineNumber\">19</span>  $reject(reason) {\n<span class=\"lineNumber\">20</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>[promiseState] !== PENDING) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.2.1, 2.1.3.1</span>\n<span class=\"lineNumber\">21</span>    <span class=\"hljs-built_in\">this</span>[promiseState] = REJECTED <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">22</span>    <span class=\"hljs-built_in\">this</span>[promiseValue] = reason <span class=\"hljs-comment\">// 2.1.3.2</span>\n<span class=\"lineNumber\">23</span>    <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">24</span>  }\n<span class=\"lineNumber\">25</span> \n<span class=\"lineNumber\">26</span>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> {\n<span class=\"lineNumber\">27</span>    <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> Yo(nop) <span class=\"hljs-comment\">// then 方法返回的新实例</span>\n<span class=\"lineNumber\">28</span>    <span class=\"hljs-comment\">// 2.2.1.1</span>\n<span class=\"lineNumber\">29</span>    promise.onFulfilled = <span class=\"hljs-keyword\">typeof</span> onFulfilled === $function ? onFulfilled : $undefined;\n<span class=\"lineNumber\">30</span>    <span class=\"hljs-comment\">// 2.2.1.2</span>\n<span class=\"lineNumber\">31</span>    promise.onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === $function ? onRejected : $undefined;\n<span class=\"lineNumber\">32</span>    <span class=\"hljs-comment\">// 2.2.6.1, 2.2.6.2</span>\n<span class=\"lineNumber\">33</span>    <span class=\"hljs-built_in\">this</span>[promiseConsumers].push(promise)\n<span class=\"lineNumber\">34</span>    <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">35</span>    <span class=\"hljs-comment\">// 2.2.7</span>\n<span class=\"lineNumber\">36</span>    <span class=\"hljs-keyword\">return</span> promise\n<span class=\"lineNumber\">37</span>  }\n<span class=\"lineNumber\">38</span> \n<span class=\"lineNumber\">39</span>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">broadcast</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"lineNumber\">40</span>    <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">41</span>    <span class=\"hljs-comment\">// 2.2.2.1, .2.2.2.2, 2.2.3.1, 2.2.3.2</span>\n<span class=\"lineNumber\">42</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>[promiseState] === PENDING) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">43</span>    <span class=\"hljs-comment\">// 2.2.6.1, 2.2.6.2, 2.2.2.3, 2.2.3.3</span>\n<span class=\"lineNumber\">44</span>    <span class=\"hljs-keyword\">const</span> callbackName = promise[promiseState] === FULFILLED ? <span class=\"hljs-string\">\"onFulfilled\"</span> : <span class=\"hljs-string\">\"onRejected\"</span>\n<span class=\"lineNumber\">45</span>    <span class=\"hljs-keyword\">const</span> resolver = promise[promiseState] === FULFILLED ? <span class=\"hljs-string\">\"$resolve\"</span> : <span class=\"hljs-string\">\"$reject\"</span>\n<span class=\"lineNumber\">46</span>    soon(\n<span class=\"lineNumber\">47</span>      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">48</span>        <span class=\"hljs-comment\">// 2.2.6.1, 2.2.6.2, 2.2.2.3, 2.2.3.3</span>\n<span class=\"lineNumber\">49</span>        <span class=\"hljs-keyword\">const</span> consumers = promise[promiseConsumers].splice(<span class=\"hljs-number\">0</span>)\n<span class=\"lineNumber\">50</span>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &#x3C; consumers.length; index++) {\n<span class=\"lineNumber\">51</span>          <span class=\"hljs-keyword\">const</span> consumer = consumers[index];\n<span class=\"lineNumber\">52</span>          <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">53</span>            <span class=\"hljs-keyword\">const</span> callback = consumer[callbackName] <span class=\"hljs-comment\">// 获取 then 方法执行的时候传入的函数</span>\n<span class=\"lineNumber\">54</span>            <span class=\"hljs-keyword\">const</span> value = promise[promiseValue]\n<span class=\"lineNumber\">55</span>            <span class=\"hljs-comment\">// 2.2.1.1, 2.2.1.2, 2.2.5 without context</span>\n<span class=\"lineNumber\">56</span>            <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">callback</span>)</span> {\n<span class=\"lineNumber\">57</span>              consumer[<span class=\"hljs-string\">'$resolve'</span>](callback(value))\n<span class=\"lineNumber\">58</span>            } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">59</span>              <span class=\"hljs-comment\">// onFulfilled / onRejected 不是函数</span>\n<span class=\"lineNumber\">60</span>              <span class=\"hljs-comment\">// 2.2.7.3, 2.2.7.4</span>\n<span class=\"lineNumber\">61</span>              consumer[resolver](value)\n<span class=\"lineNumber\">62</span>            }\n<span class=\"lineNumber\">63</span>          } <span class=\"hljs-keyword\">catch</span> (e) {\n<span class=\"lineNumber\">64</span>            <span class=\"hljs-comment\">// 异常则设为 rejected</span>\n<span class=\"lineNumber\">65</span>            consumer[<span class=\"hljs-string\">'$reject'</span>](e)\n<span class=\"lineNumber\">66</span>          }\n<span class=\"lineNumber\">67</span>        }\n<span class=\"lineNumber\">68</span>      }\n<span class=\"lineNumber\">69</span>    )\n<span class=\"lineNumber\">70</span>  }\n<span class=\"lineNumber\">71</span>}\n<span class=\"lineNumber\">72</span> \n<span class=\"lineNumber\">73</span><span class=\"hljs-comment\">// soon function come from Zousan.js</span>\n<span class=\"lineNumber\">74</span><span class=\"hljs-keyword\">const</span> soon = (<span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">75</span>  <span class=\"hljs-keyword\">const</span> fq = [],  <span class=\"hljs-comment\">// function queue</span>\n<span class=\"lineNumber\">76</span>    <span class=\"hljs-comment\">// avoid using shift() by maintaining a start pointer</span>\n<span class=\"lineNumber\">77</span>    <span class=\"hljs-comment\">// and remove items in chunks of 1024 (bufferSize)</span>\n<span class=\"lineNumber\">78</span>    bufferSize = <span class=\"hljs-number\">1024</span>\n<span class=\"lineNumber\">79</span>  <span class=\"hljs-keyword\">let</span> fqStart = <span class=\"hljs-number\">0</span>\n<span class=\"lineNumber\">80</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callQueue</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">81</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">while</span>(<span class=\"hljs-params\">fq.length - fqStart</span>)</span> {\n<span class=\"lineNumber\">82</span>      <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">83</span>        fq[fqStart]()\n<span class=\"lineNumber\">84</span>      } <span class=\"hljs-keyword\">catch</span> (err) {\n<span class=\"lineNumber\">85</span>        <span class=\"hljs-built_in\">console</span>.log(err)\n<span class=\"lineNumber\">86</span>      }\n<span class=\"lineNumber\">87</span>      fq[fqStart++] = <span class=\"hljs-literal\">undefined</span> <span class=\"hljs-comment\">// increase start pointer and dereference function just called</span>\n<span class=\"lineNumber\">88</span>      <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">fqStart === bufferSize</span>)</span> {\n<span class=\"lineNumber\">89</span>        fq.splice(<span class=\"hljs-number\">0</span>, bufferSize)\n<span class=\"lineNumber\">90</span>        fqStart = <span class=\"hljs-number\">0</span>\n<span class=\"lineNumber\">91</span>      }\n<span class=\"lineNumber\">92</span>    }\n<span class=\"lineNumber\">93</span>  }\n<span class=\"lineNumber\">94</span>  <span class=\"hljs-comment\">// run the callQueue function asyncrhonously as fast as possible</span>\n<span class=\"lineNumber\">95</span>  <span class=\"hljs-comment\">// 执行此函数，返回的函数赋值给 cqYield</span>\n<span class=\"lineNumber\">96</span>  <span class=\"hljs-keyword\">const</span> cqYield = (<span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">97</span>    <span class=\"hljs-comment\">// 返回一个函数并且执行</span>\n<span class=\"lineNumber\">98</span>    <span class=\"hljs-comment\">// This is the fastest way browsers have to yield processing</span>\n<span class=\"lineNumber\">99</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> MutationObserver !== <span class=\"hljs-string\">'undefined'</span></span>)</span>\n<span class=\"lineNumber\">100</span>    {\n<span class=\"lineNumber\">101</span>      <span class=\"hljs-comment\">// first, create a div not attached to DOM to \"observe\"</span>\n<span class=\"lineNumber\">102</span>      <span class=\"hljs-keyword\">const</span> dd = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">\"div\"</span>)\n<span class=\"lineNumber\">103</span>      <span class=\"hljs-keyword\">const</span> mo = <span class=\"hljs-keyword\">new</span> MutationObserver(callQueue)\n<span class=\"lineNumber\">104</span>      mo.observe(dd, { <span class=\"hljs-attr\">attributes</span>: <span class=\"hljs-literal\">true</span> })\n<span class=\"lineNumber\">105</span> \n<span class=\"lineNumber\">106</span>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ dd.setAttribute(<span class=\"hljs-string\">\"a\"</span>,<span class=\"hljs-number\">0</span>) } <span class=\"hljs-comment\">// trigger callback to</span>\n<span class=\"lineNumber\">107</span>    }\n<span class=\"lineNumber\">108</span> \n<span class=\"lineNumber\">109</span>    <span class=\"hljs-comment\">// if No MutationObserver - this is the next best thing for Node</span>\n<span class=\"lineNumber\">110</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> process !== <span class=\"hljs-string\">'undefined'</span> &#x26;&#x26; <span class=\"hljs-keyword\">typeof</span> process.nextTick === <span class=\"hljs-string\">\"function\"</span>)\n<span class=\"lineNumber\">111</span>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ process.nextTick(callQueue) }\n<span class=\"lineNumber\">112</span> \n<span class=\"lineNumber\">113</span>    <span class=\"hljs-comment\">// if No MutationObserver - this is the next best thing for MSIE</span>\n<span class=\"lineNumber\">114</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> setImmediate !== _undefinedString)\n<span class=\"lineNumber\">115</span>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ setImmediate(callQueue) }\n<span class=\"lineNumber\">116</span> \n<span class=\"lineNumber\">117</span>    <span class=\"hljs-comment\">// final fallback - shouldn't be used for much except very old browsers</span>\n<span class=\"lineNumber\">118</span>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-built_in\">setTimeout</span>(callQueue,<span class=\"hljs-number\">0</span>) }\n<span class=\"lineNumber\">119</span>  })()\n<span class=\"lineNumber\">120</span>  <span class=\"hljs-comment\">// this is the function that will be assigned to soon</span>\n<span class=\"lineNumber\">121</span>  <span class=\"hljs-comment\">// it take the function to call and examines all arguments</span>\n<span class=\"lineNumber\">122</span>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =></span> {\n<span class=\"lineNumber\">123</span>    fq.push(fn) <span class=\"hljs-comment\">// push the function and any remaining arguments along with context</span>\n<span class=\"lineNumber\">124</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">(fq.length - fqStart) === <span class=\"hljs-number\">1</span></span>)</span> { <span class=\"hljs-comment\">// upon addubg our first entry, keck off the callback</span>\n<span class=\"lineNumber\">125</span>      cqYield()\n<span class=\"lineNumber\">126</span>    }\n<span class=\"lineNumber\">127</span>  }\n<span class=\"lineNumber\">128</span>})()</code></pre> \n\n<p>网上对于状态转换后异步调用<code>onFulfilled</code>或者<code>onRejected</code>的逻辑实现众说纷纭，我最喜欢的实现来源于<code>@trincot</code>大神在 Stack Overflow 上的解答，感兴趣可以查看文末参考链接。</p>\n<p>对于在状态变更后异步调用之前注册的回调函数的解法如下：</p>\n<ul>\n<li>使用<code>consumers</code>数组存放<code>then</code>方法返回的<code>promise</code></li>\n<li>在<code>then</code>方法中，为每个将要返回的<code>promise</code>添加其传入的同名参数<code>onFulfilled</code>和<code>onRejected</code>作为<code>Promise</code>上的属性。</li>\n<li>对于某些已经转换过状态的<code>Promise</code>实例，需要在<code>then</code>方法中调用一次<code>broadcast</code>方法。</li>\n</ul>\n<blockquote>\n<p><code>broadcast</code> 方法非常关键，在<code>resolve</code>、<code>reject</code>、<code>then</code>方法中都会调用一次。</p>\n</blockquote>\n<p>我们使用<code>broadcast</code>方法来做一个“广播”的功能，当<code>Promise</code>状态转换之后就视其状态创建微任务，异步调用<code>consumers</code>数组中所有的<code>Promise</code>上的属性方法<code>onFulfilled</code>或者<code>onRejected</code>。</p>\n<p>另外，如何创建微任务以异步执行相关函数也是实现<code>Promise</code>类的关键，这里我学习了<code>@bluejava</code>前辈的<code>Promise</code>实现方案：<code>Zousan.js</code> ，文末有其<code>github</code>仓库地址。</p>\n<p>在<code>zousan.js</code>中，作者特地创建了一个<code>soon</code>函数，将传入的函数参数尽可能快速地创建微任务以执行。</p>\n<p>其核心便是如果是浏览器环境并且支持<code>MutationObserver</code>，则创建文档节点使用此<code>API</code>创建微任务最终执行目标函数，如若不支持则检查<code>process.nextTick</code>和<code>setImmediate</code>是否可用，最后用<code>setTimeout</code>兜底创建宏任务以达到异步调用目标函数的目的。</p>\n<p>至此，我们的<code>Yo</code>类几近完成，最后就是规范第三点：<code>The Promise Resolution Procedure</code>。</p>\n<h5>The Promise Resolution Procedure</h5>\n<blockquote>\n<p>Promise Resolution procedure 表示为<code>[[Resolve]](promise, x)</code>,为什么我们需要实现此规范？</p>\n</blockquote>\n<p>当我们在<code>executor</code>函数中使用<code>resolve</code>或者<code>reject</code>方法的时候，传入的参数可以是任意有效的<code>Javascript</code>值。某些场景下，这个值可能是一个原始类型的数据，也可能是一个<code>thenables</code>对象，亦或是一个其他<code>Promise</code>实现方案创建的<code>Promise</code>实例。</p>\n<p><strong>我们需要处理这个问题，让不同的传参都有一个确切的处理方案。</strong></p>\n<p>那么，就让我们继续看规范是如何定义的。</p>\n<p>执行<code>[[Resolve]](promise, x)</code>的步骤如下：</p>\n<ul>\n<li>2.3.1 如果<code>promise</code>和<code>x</code>引用的是同一个对象，则<code>reject</code>一个<code>TypeError</code>异常作为<code>reason</code>。</li>\n<li>2.3.2 如果<code>x</code>是一个<code>Promise</code>，则采纳其状态。\n<ul>\n<li>2.3.2.1 如果<code>x</code>是<code>pending</code>的，则<code>promise</code>保持<code>pending</code>直到<code>x</code>状态改变。</li>\n<li>2.3.2.2 、2.3.2.3 <code>x</code>状态稳定后，直接沿用其<code>value</code>或<code>reason</code>。</li>\n</ul>\n</li>\n<li>2.3.3 如若其不是<code>Promise</code>而是一个普通<code>thenable</code>对象\n<ul>\n<li>2.3.3.1 设<code>then</code>等于<code>x.then</code></li>\n<li>2.3.3.2 如果执行<code>then</code>方法却抛出异常，则<code>reject</code>此<code>promise</code>，并且将异常作为<code>reason</code>。</li>\n<li>2.3.3.3</li>\n</ul>\n</li>\n</ul>\n<p>对于一个<code>Promise</code>的实现来说，我们还需要添加一个<code>catch</code>方法，这个方法可以看成<code>then</code>方法的语法糖。</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Yo</span></span>{\n<span class=\"lineNumber\">2</span>  ...\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">catch</span>(<span class=\"hljs-params\">onRejected</span>)</span> {\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.then($undefined, onRejected)\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span>  ...\n<span class=\"lineNumber\">7</span>}</code></pre> \n\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt/23785244\">Basic Javascript promise implementation attempt - Stack Overflow</a></li>\n<li><a href=\"https://github.com/bluejava/zousan\">bluejava/zousan: A Lightning Fast, Yet Very Small Promise A+ Compliant Implementation</a></li>\n</ul>\n<h2>致谢</h2>\n<p>再次感谢 @bluejava 回复我的咨询邮件，并且耐心地与我蹩脚的英语沟通，即使他也许不会注意到这里。</p>\n","title":"实现一个Promise-A+规范的Promise类","date":"2021/5/12","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=400","intro":"为了学习 Promise 的原理，加深对异步 Promise 的理解，我们很有必要学习如何实现一个符合 Promise/A+ 规范的 Promise 类"}},"__N_SSG":true}
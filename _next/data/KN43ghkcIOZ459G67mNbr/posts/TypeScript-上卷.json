{"pageProps":{"post":{"slug":"TypeScript-上卷","content":"\n### *.d.ts*\n\n#### 总领\n\nTypeScript Declaration File: 用于存放类型声明，便于编辑器的智能提示。\n\n> 类型声明具有一个原则：`不冲突即合法`\n\n不同的声明文件有所区别，诸如`Jquery`之类的库可以通过`global`的方式引用，也可以通过模块的方式引用。\n\n不同的场景，可以将类库声明分为以下几类：\n\n- global 暴露为全局变量的类库\n- module 通过加载机制引用的类库\n- plugin 会影响其他类库功能的插件\n\n基于这些场景，最佳实践是将声明文件分为以下几种并统一归类：\n\n- global.d.ts: 全局类库声明\n- module-function.d.ts: 暴露为函数的 module 类库声明\n- module-class.d.ts: 暴露出一个 class 的类库声明\n- module.d.ts: 一般的类库（暴露的内容既不是函数也不是 class）\n- module-plugin.d.ts: 模块插件类库声明\n- global-plugin.d.ts: 全局插件\n- global-modifying-module.d.ts: 适用于 module 形式的全局插件类库\n\n为不同功能或类型的类库按以上分类方式进行分类声明，有利于编写整洁的代码和提升可读性。\n\n##### 语法格式\n\n接下来看一下各种类型声明的语法格式：\n\n首先是全局变量声明：\n\n```typescript\ndeclare var foo: number;\n```\n\n如此便声明了一个全局变量`foo`，编译器就会在遇到这个变量的时候得到其类型声明，就不会出现错误提示提及此变量未定义。\n\n> 当然也可以用`declare let`或`delare fconst`来声明只读和块级作用域\n\n其次，来看看全局函数声明和全局对象声明：\n\n```typescript\n// 函数声明\ndeclare function greet(name: string): void;\n// 对象声明\ndeclare namespace myLib {\n  function makeGreeting(s: string): string;\n  const age: number;\n}\n```\n\n函数声明还很好理解，全局对象声明这里有一个`namespace`命名空间关键字，在`TypeScript Handbook`里是这么形容的：\n\n> 命名空间是位于全局命名空间下的一个普通的带有名字的JavaScript对象。\n\n在声明过后，就可以在全局直接使用`myLib.age`。\n\n##### 实践规范\n\n除了语法格式，还应该遵守规范约束：\n\n- 用基础类型而非包装类型（string 而非 String）\n- 不要使用未出现的泛型参数\n- 无返回值的函数返回声明不应该用`any`，而应该用`void`\n- 善用可选参数、组合类型而少用函数重载\n\n##### 类型、值和命名空间\n\n`TypeScript`的类型系统的基本构成即：\n\n- 类型\n- 值\n- 命名空间\n\n类型的声明，可以有以下几种方式：\n\n```typescript\n// 别名\ntype options = number | string;\n\n// 接口\ninterface I {\n  x: number\n}\n\n// 类\nclass C {}\n\n// 枚举\nenum Direction {Left, Right, Top, Bottom}\n\n// 类型引用\nimport * as m from 'someModule';\n```\n\n值的声明，则如下：\n\n```typescript\n// 变量\nlet\nconst\nvar\n\n// 模块\nnamespace\nmodule\n\n// 枚举\nenum\n\n// 类\nclass\n\n// 引用\nimport\n\n// 函数\nfunction\n```\n\n而命名空间，则通常用于组织类型，例如：`const x : A.B.C`则表示`x`的类型来自于`A.B`命名空间下的`C`\n\n`class/enum/import`既可以声明值也可以提供类型，当在同一个命名空间下存在多个不同类型却名字相同的值时，不冲突即为合法，并且最终进行合并。举个例子：\n\n```typescript\n// 类型与类型的结合\ninterface Foo {\n  x: number;\n}\nclass Foo {\n  y: number;\n}\n// ... elsewhere ...\ninterface Foo {\n  z: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y + a.z); // OK\n```\n\n\n\n##### 自动生成\n\n`tsc`可以为扩展名改变的`js`文件自动创建类型声明文件，并且可以识别`jsdoc`。\n\n当我们的`js`代码提供了良好的`jsdoc`文档时，`tsc`自动生成的`d.ts`文件有时可以满足我们的需求。\n\n\n\n##### 发布\n\n在编写`TypeScript`库的时候将`.d.ts`文件放在根目录一同发布出去即可让用户自动获取良好的类型声明支持。\n\n在日常工作中，有些模块库的声明需要手动下载安装，例如之前一个版本的`lodash`:\n\n`npm i -D @types/lodash`\n\n\n\n### 基本类型\n\n#### 基础\n\n`JavaScript`七种类型，在`TypeScript`中一一对应如下：\n\n```typescript\nconst isDone: boolean = false; // 布尔值\n\nconst decimal: number = 1; // 数字\n\nconst color: string = 'red'; // 字符串\n\nconst n: null = null; // null\n\nconst udf: undefined = undefined; // undefined\n\nconst obj: object = {}; // Object\n\nconst s: symbol = Symbol(); // Symbol\n```\n\n此外，还有以下几种基础类型：\n\n```typescript\nconst list: number[] = [1, 2]; // 数组\n\nconst x: [string, number] = ['ok', 1]; // 元组\n\nenum Direction { left, right, bottom, top }; // 枚举\n\nconst anything: any = 1; // 任意类型\nconst list: any[] = ['a', 'b', 1]; // 任意数组\n\nfunction foo(): void {}; // 空类型\n\nfunction neverReturn(): never {throw 'error'}; // 不存在返回值\n\nlet value: unknown; // 未知类型，更安全更严格的 any，但却不可以赋值给其他已知类型\n```\n\n#### 关注点\n\n- Array 具有两种声明格式\n  - elemType[]\n  - Array<elemType>\n- Tuple 越界时，值为所有定义的混合类型\n- void 的意义约束了返回值只能是`null/undefined`\n- `null/undefined/never`是其他类型的子类型，因此可以赋值给任何其他类型的变量\n- 其他任何类型都不可以赋值给`never`(any 也不行)\n- `never`可以用做类型保护，例如声明`declare const name: never`可以避免隐式访问`window.name`\n\n> 开启`--strictNullChecks`时，`null/undefined`只可以赋值给`void`和各自对应的类型\n\n#### 类型断言\n\n类型断言可以理解成编译时的强制类型转换，意在告诉编译器：“我你比懂类型，这就是个`type`”。\n\n类型断言具有两种类型：\n\n- `variable as type`: 通用\n- `<type>variable`: jsx 中有语法冲突，故一般用前者\n\n#### Interface\n\n`TypeScript`中的接口不必显示实现，而只表示一种类型的约束。\n\n```typescript\ninterface Demo {\n  // 索引签名，适用于无法确定属性名的场合\n  [x: string]: string\n  // 只读属性\n  readonly x: number;\n  // 只读数组\n  list: ReadonlyArray<number>;\n  // 只读索引签名\n  readonly [propName: string]: string\n}\n```\n\n接口还可以用来表示函数类型：\n\n```typescript\ninterface SearchFc {\n  (source: string, subStr: string): string;\n}\nlet mySearchFc = (source: string, subStr: string) => {\n  let res = source.search(subStr);\n  return res.toString();\n}\n```\n\n> 函数参数检查会按顺序检查，但是不必严格限制参数名\n\n此外，接口和类之间还有`implements`的关系：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n  setTime: (d: Date) => void\n}\nclass Clock implements ClockInterface {\n  currentTime: Date;\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\n> 接口即协议，接口即契约\n\n接口可以`继承`：\n\n```typescript\n// 单继承\ninterface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\n// 多继承\ninterface PenStroke {\n  penWidth: number;\n}\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n```\n\n#### 类\n\n> ES3 不支持 getter/setter\n>\n> 只有`getter`，没有`setter`则推断为`readonly`\n\n示例：\n\n```typescript\nclass Employee {\n  // 公有属性，默认\n  public like: string;\n  // 私有属性\n  private _fullName: string;\n  // 静态属性\n  static ok: boolean;\n  // 访问器\n  get fullName(): string {\n    return this._fullName;\n  }\n  set fullName(name: string) {\n    this._fullName = name;\n  }\n}\n// 接口继承类\ninterface More extends Employee {\n  age: number;\n}\n// 继承\nclass B {\n  // 抽象方法，子类继承则必须实现\n  abstract makeSound(): void;\n}\nclass A extends B {\n  makeSound() {}\n}\n```\n\n#### 函数\n\n函数类型的组成：\n\n- 参数\n- 返回值\n\n示例：\n\n```typescript\n// 具名函数\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n// 匿名函数\nconst add = function(x:number,y:number):number {\n  return x + y;\n}\n```\n\n有时候，我们想复用特定函数的类型，可以使用类型描述：\n\n`(x: number, y: number) => number`即函数类型描述\n\n```typescript\nconst add: (x: number, y: number) => number = function(x: number, y: number): number {\n  return x + y;\n}\n```\n\n> 箭头（`=>`）左侧是参数及其类型，右侧是返回值类型\n\n参数有些是可选的，可选参数只需要在参数名后加`?`号，可选参数必须在必选参数之后，默认参数则不必在乎顺序，但是在调用时需要传`undefined`作为值。\n\n### 泛型\n\n#### 基础\n\n场景如下：\n\n```typescript\nfunction demo(arg) {\n  return arg;\n}\n```\n\n泛型相当于具名`any`!\n\n```typescript\nfunction demo<T>(arg: T): T {\n  return arg;\n}\n```\n\n用尖括号声明泛型，在函数参数和返回值的地方就可以用此泛型参数。\n\n上述示例表达了函数传值和返回值类型的关系：`T => T`。\n\n> 变量分为普通变量和类型变量，普通变量代表值，传递值。\n>\n> 类型变量则`搬运`类型信息。\n\n#### 类型描述\n\n泛型函数的类型描述和普通类型类似：\n\n```typescript\n// 普通函数\nconst demo: (arg: string) => string = function(arg: string): string {\n  return arg;\n}\n\n// 泛型函数\nconst demo: <T>(arg: T) => T = function<T>(arg: T): T {\n  return arg;\n}\n```\n\n> 在实际开发中，依靠类型推断即可，不必要写如此多的显示类型声明\n\n此外，还可以写成对象字面量的形式去声明类型（不够简洁）\n\n```typescript\n// 泛型函数\nlet myIdentity: { <T>(arg: T): T };\n// 普通函数\nlet myIdentity: { (arg: string): string };\n```\n\n#### 泛型接口\n\n带类型参数的接口即泛型接口。\n\n```typescript\ninterface GenericIdentityFn<T> {\n  isArr(...args: T[]): T[];\n  id(arg: T): T;interface GenericIdentity<T> {\n  id(arg: T): T;\n  idArray(...args: T[]): T[];\n}\nlet id: GenericIdentity<string> = {\n    id: (s: string) => s,\n    // 报错 Types of parameters 's' and 'args' are incompatible.\n    idArray: (...s: number[]) => s,\n  };\n}\n```\n\n#### 泛型类\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T;\n  add:(x: T, y: T): T;\n}\n```\n\n`静态成员无法使用泛型！`\n\n```typescript\nclass GenericNumber<T> {\n  // 报错 Static members cannot reference class type parameters.\n  static zeroValue: T;\n}\n```\n\n#### 泛型的约束\n\n泛型需要约束，泛型的约束也有很多方式。\n\n较为常见的是通过`extends`继承接口去限制泛型。\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\nfunction logginIdentity<T extends Lengthwise>(arg: T):T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n另外，还可以在泛型约束中使用类型参数，即用一个类型参数的特征去约束另一个类型参数。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, \"a\"); // okay\ngetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.\n```\n\n> 泛型能作用于一系列类型，是具体类型之上的`抽象`\n\n### 枚举\n\n常用枚举可以按值的类型分为三种：\n\n- 数值枚举\n- 字符串枚举\n- 异构枚举\n\n> 此外还有特殊的联合枚举、常量枚举、环境枚举\n\n#### 数值枚举\n\n示例如下：\n\n> initializer 机制适合在不关心值的情况下\n\n```typescript\nenum Direction {\n  up, // default is 0\n  down,\n  left,\n  right,\n}\n// 指定开始值然后自动递增\nenum Direction {\n  up = 1, // default is 1\n  down,\n  left,\n  right, // 4\n}\n```\n\n此时，可以通过反向映射机制取到常量名：\n\n> 反向映射仅限于数值枚举\n\n```typescript\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n// 正向 按名取值\nconsole.log(Direction.Down);  // 1\n// 反向 按值取名\nconsole.log(Direction[1]);    // 'Down'\n```\n\n#### 字符串枚举\n\n字符串枚举必须要求成员具有显式的初始化值，并且不支持反向映射，其优势在于保留了值的含义。\n\n```typescript\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n```\n\n#### 异构枚举\n\n枚举值中同时包含数值和字符串，但我们很少这样做。\n\n```typescript\nenum mixEnum {\n  S = 'S',\n  A = 1,\n  B,\n  C = 'C'\n}\n```\n\n其他几种枚举，工作中接触不多而网上说明也足够，故不再赘述。\n\n### 类型推断\n\n#### 赋值推断\n\n编译器提供了强大的类型推断支持，帮了我们大忙。编译器可以根据目标值来确定类型，具体如下：\n\n- 变量或成员初始值\n- 参数默认值\n- 函数返回值\n\n还有以下一些隐式的类型推断示例：\n\n```typescript\nlet x = [1, null];\n```\n\n数组元素中包含`number`和`null`，而`null/undefined/never`是其他任何类型的子类型，可以赋值给其他类型变量。\n\n因此，`x`被推断为`number[]`。\n\n> 要确定数组类型的话，先要确定每个元素的类型，再考虑其兼容关系，最终确定一个最“宽”的类型（包容数组中所有其它类型，称为best common type）作为数组类型\n>\n> ------黯羽轻扬\n\n#### 上下文推断\n\n根据已知的类型，推断变量的类型。\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {}\n```\n\n右侧匿名函数作为`mousedown`事件处理器，其参数类型按`DOM API`的规范来推断即可得出类型，如果脱离了事件处理器上下文，则参数是`any`类型。\n\n还有一些场景会根据上下文进行类型推断：\n\n- 类型断言\n- return 语句\n- 对象成员和数组字面量\n\n> 补充一下子类型兼容性图\n\n![](mdImgs/ts-subtype-1024x438.jpg)\n\n如上所示：\n\n- `any`兼容所有类型。\n\n- `never`不兼容任何类型。\n- `void`兼容`undefined`和`null`\n\n> 我们说的兼容，指的是被兼容的类型可以赋值给兼容者类型的变量。\n\n```typescript\nlet x: any;\nlet y: number;\nlet z: null;\n\n// Any兼容Number\nx = y;\n// Number兼容Null\ny = z;\n// Null不兼容Number\n// 错误 Type 'number' is not assignable to type 'null'.\nz = y;\n```\n\n但是，有些时候类型推断并不如人意。\n\n```typescript\nenum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet s = Status.Ready;\n// Type 'Color.Green' is not assignable to type 'Status'.\ns = Color.Green;  // Error 不同枚举类型的枚举值不兼容\n```\n\n但是，如果你认为数值枚举和数字类型不兼容，那就错了。\n\n而字符串枚举却又不兼容字符串类型。\n\n我们致力于写清晰的代码，因此不推荐过渡依赖于类型上下文推断。\n\n","title":"TypeScript-上卷","date":"2022/2/26","tags":[null],"mainImg":"https://images.unsplash.com/photo-1592609931095-54a2168ae893?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDU4NzEzMDI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1592609931095-54a2168ae893?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDU4NzEzMDI&ixlib=rb-1.2.1&q=80&w=400","intro":"工作中日常用到 TypeScript，故在此学习并记录备忘。此为上卷，亦有中下两卷。"}},"__N_SSG":true}
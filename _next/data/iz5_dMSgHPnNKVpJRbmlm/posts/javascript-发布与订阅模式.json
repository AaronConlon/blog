{"pageProps":{"post":{"slug":"javascript-发布与订阅模式","contentHtml":"<p><code>发布/订阅</code>模式又称为<code>PubSub</code>模式.理解和熟练使用<code>PubSub</code>模式在某种程度上可以让我们的应用易于扩展,因为发布者和订阅者之间耦合性低,应用的可维护性更高,我们可以很方便的添加额外的功能.</p>\n<p>今天,让我们来简单学习一下<code>PubSub</code>模式,了解一下<code>Nodejs</code>下广泛使用的<code>EventEmitter</code>对象,以及简单实现一个<code>PubSub</code>类 💪.</p>\n<h2>PubSub 模式</h2>\n<p>早期的<code>JavaScript</code>在浏览器端对于<code>DOM</code>元素附加事件处理器是非常粗浅的,也许会出现如下代码片段:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// 添加一个事件监听</span>\n<span class=\"lineNumber\">2</span>div.onclick = clickHandler;\n<span class=\"lineNumber\">3</span><span class=\"hljs-comment\">// 添加多个</span>\n<span class=\"lineNumber\">4</span>div.onclick = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">5</span>  clickHandler1.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>)\n<span class=\"lineNumber\">6</span>  clickHandler2.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);\n<span class=\"lineNumber\">7</span>}</code></pre> \n\n<p>一次只能设置一个事件监听,后续再次设置将会覆盖前者.如果想要添加多个事件处理器,则需要额外的封装.</p>\n<p>幸运的是, 2000 年 DOM 规范增加了<code>addEventListener</code>方法,解决了这一问题.</p>\n<p>另外,<code>Nodejs</code>的<code>EventEmitter</code>对象在<code>Nodejs</code>很多方面也得到了广泛的应用.</p>\n<h3>EventEmitter 对象</h3>\n<p><code>NodeJs</code>内含<code>EventEmitter</code>类,其他对象都可以继承它,想给<code>EventEmitter</code>实例添加事件处理器,只需要<code>事件类型</code>和<code>事件处理器函数</code>作为参数调用<code>on</code>方法即可.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>emitter.on(<span class=\"hljs-string\">'who'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =></span> {\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-comment\">// balabala</span>\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-built_in\">console</span>.log(name)\n<span class=\"lineNumber\">4</span>})\n<span class=\"lineNumber\">5</span> \n<span class=\"lineNumber\">6</span><span class=\"hljs-comment\">// 触发</span>\n<span class=\"lineNumber\">7</span>emitter.emit(<span class=\"hljs-string\">'who'</span>, <span class=\"hljs-string\">'Aaron'</span>)</code></pre> \n\n<p><code>emit</code>意味着触发,负责调用给定事件类型的所有处理器,并且传递其参数,处理器命名惯例约定为<code>小驼峰</code>.</p>\n<blockquote>\n<p><code>EventEmitter</code>对象所有方法为公有方法,一般约定只能从对象内部触发事件,不推荐从对象外其他地方进行调用.</p>\n</blockquote>\n<h3>PubSub 类</h3>\n<p>我们来创建一个简单<code>PubSub</code>类,并且实现一下几个功能:</p>\n<ul>\n<li>on 方法: 给实例添加一个事件处理器,并且可选择是否只执行一次</li>\n<li>emit 方法: 调用给定事件类型的所有处理器,并且可以传一些参数.</li>\n<li>off 方法: 移除指定的事件处理器]</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PubSub</span> </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span class=\"hljs-built_in\">this</span>.handlers = {};\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span class=\"hljs-comment\">// 指定事件类型,处理器,以及是否为一次性处理器</span>\n<span class=\"lineNumber\">6</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">on</span>(<span class=\"hljs-params\">eventType, handler, option = {once: <span class=\"hljs-literal\">false</span>}</span>)</span> {\n<span class=\"lineNumber\">7</span>    <span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">8</span>    <span class=\"hljs-keyword\">const</span> once = option.once;\n<span class=\"lineNumber\">9</span>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">!(eventType <span class=\"hljs-keyword\">in</span> self.handlers)</span>)</span> {\n<span class=\"lineNumber\">10</span>      self.handlers[eventType] = [];\n<span class=\"lineNumber\">11</span>    }\n<span class=\"lineNumber\">12</span>    <span class=\"hljs-comment\">// 已存在同种类型的事件和相同的处理器则直接返回,这里忽略了是否为一次性处理器</span>\n<span class=\"lineNumber\">13</span>    <span class=\"hljs-keyword\">if</span>(self.handlers[eventType].some(<span class=\"hljs-function\"><span class=\"hljs-params\">handlerItem</span> =></span> handlerItem.handler === handler)) <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">14</span>    self.handlers[eventType].push({handler, once});\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">16</span>  }\n<span class=\"lineNumber\">17</span>  <span class=\"hljs-comment\">// 指定事件类型和传参</span>\n<span class=\"lineNumber\">18</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">emit</span>(<span class=\"hljs-params\">eventType, data</span>)</span> {\n<span class=\"lineNumber\">19</span>    <span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">20</span>    <span class=\"hljs-keyword\">if</span>(!self.handlers[eventType]) <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">21</span>    <span class=\"hljs-comment\">// 执行指定事件类型的每一个处理器</span>\n<span class=\"lineNumber\">22</span>    self.handlers[eventType].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">handlerItem</span> =></span> {\n<span class=\"lineNumber\">23</span>      <span class=\"hljs-keyword\">const</span> {handler, once} = handlerItem;\n<span class=\"lineNumber\">24</span>      handler(data);\n<span class=\"lineNumber\">25</span>      <span class=\"hljs-comment\">// 如果是一次性处理器,则执行后自动删除</span>\n<span class=\"lineNumber\">26</span>      once &#x26;&#x26; self.off(eventType, handler)\n<span class=\"lineNumber\">27</span>    })\n<span class=\"lineNumber\">28</span>    <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">29</span>  }\n<span class=\"lineNumber\">30</span>  <span class=\"hljs-comment\">// 删除指定的事件的处理器</span>\n<span class=\"lineNumber\">31</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">off</span>(<span class=\"hljs-params\">eventType, handler</span>)</span> {\n<span class=\"lineNumber\">32</span>    <span class=\"hljs-keyword\">const</span> self = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">33</span>    <span class=\"hljs-keyword\">if</span>(!self.handlers[eventType]) <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">34</span>    <span class=\"hljs-comment\">// 更新数据存储对象,删除指定事件类型的特定处理器</span>\n<span class=\"lineNumber\">35</span>    self.handlers[eventType] = self.handlers[eventType].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">handlerItem</span> =></span> handlerItem.handler !== handler);\n<span class=\"lineNumber\">36</span>    <span class=\"hljs-keyword\">return</span> self;\n<span class=\"lineNumber\">37</span>  }\n<span class=\"lineNumber\">38</span>  <span class=\"hljs-comment\">// 额外的重置功能</span>\n<span class=\"lineNumber\">39</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">reset</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"lineNumber\">40</span>    <span class=\"hljs-built_in\">this</span>.handlers = {};\n<span class=\"lineNumber\">41</span>  }\n<span class=\"lineNumber\">42</span>}</code></pre> \n\n<p><code>on</code>方法注册一些事件类型和处理器,并且默认提供一个<code>option</code>对象,设置是否为<code>once</code>一次性事件.</p>\n<p>每一种<code>事件类型</code>对应着一个数组保存着具有是否为一次性处理器标志的处理器对象.</p>\n<p>如果是首次注册则初始化一个数组保存处理器,并且跳过重复的事件与处理器组合.</p>\n<p><code>emit</code>方法则对某些事件类型的所有处理器传入<code>data</code>参数作为处理器的参数.如果是一次性处理器,则调用之后删除此处理器.</p>\n<p><code>off</code>方法用于删除指定事件类型的处理器.</p>\n<p><code>PubSub</code>模式具有<code>同步性</code>,开发者可以灵活地写出<code>bug</code>😂,例如这段<code>JQuery</code>代码:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>$(<span class=\"hljs-string\">'input[type=submit]'</span>)\n<span class=\"lineNumber\">2</span>.on(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"lineNumber\">3</span>  $(<span class=\"hljs-built_in\">this</span>).trigger(<span class=\"hljs-string\">'click'</span>)\n<span class=\"lineNumber\">4</span>})</code></pre> \n\n<p>在添加处理器的时候显式<code>trigger</code>,这种同步性代码显然会引起栈溢出.(正经人谁会写出这种代码?你会吗?)</p>\n<blockquote>\n<p>我们常将带有<code>PubSub</code>接口的对象称之为<code>事件化对象</code></p>\n</blockquote>\n<p>如果我们没有主动订阅事件,<code>PubSub</code>将是完全隐形的.不应该为某事件添加过多的事件处理器,否则可能会因为执行处理器逻辑而引起浏览器主线程阻塞,界面无响应.</p>\n<p>为了解决这个问题,我们可以对这些无需时刻发生的事件维持一个队列,设置一些异步执行逻辑或者延时任务,例如下面的粗浅想法:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">const</span> tasks = [];\n<span class=\"lineNumber\">2</span><span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-keyword\">let</span> nextTask;\n<span class=\"lineNumber\">4</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">nextTask = tasks.shift()</span>)</span> {\n<span class=\"lineNumber\">5</span>    nextTask();\n<span class=\"lineNumber\">6</span>  }\n<span class=\"lineNumber\">7</span>}, <span class=\"hljs-number\">0</span>)</code></pre> \n\n<p>也许我们需要一个更好的方案来解决这个问题,我们可以使用<code>Promise</code>来异步处理这些处理器的回调.</p>\n<p>今天的分享就到这里,<code>PubSub</code>模式简化了事件的命名和分发,比较著名的轮子有<code>EventEmitter2</code>,也许我们可以在日常的工作中使用这种模式进行开发.</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://medium.com/globant/the-js-bifrost-publish-subscribe-pattern-in-javascript-df796b7a4c12#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImRlOTU1NmFkNDY4MDMxMmMxMTdhZmFlZjI5MjBmNWY5OWE0Yzc5ZmQiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MTg3OTQ1NzUsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExNzcxOTY4NDAzMTc0MDk3MTcyNiIsImVtYWlsIjoicml2ZW5xaW55eUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiMjE2Mjk2MDM1ODM0LWsxazZxZTA2MHMydHAyYTJqYW00bGpkY21zMDBzdHRnLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6IkFhcm9uIERaIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hLS9BT2gxNEdpSV9QZzhRNjJVT2ZJLVNoWm11RGdjSU1DbGRjV29fQ0JWR3d3MjNnPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6IkFhcm9uIiwiZmFtaWx5X25hbWUiOiJEWiIsImlhdCI6MTYxODc5NDg3NSwiZXhwIjoxNjE4Nzk4NDc1LCJqdGkiOiI4YjYyN2U4YWMwZThhZmRkZGQ4ZjFhMjg4MzI3YjlkZTA4Y2E2MzUyIn0.xKrcAwCsE0o73lBAac3wbJvTxd03a1XJIXnhSwHTHf-CrjB-OWcm-RYJmAKZI0Hctv7gxcy6GYWpqFuZ8CteNALbSN23E551bcc7TTWxqvv0EUc9zCtkg1uWIBuaDYsU8FC9tVbx-Jg5YkCiStMyecjNmTrrvws8aLPHNmaNlh98M4ugydRYn9i8oWXbmNidFsQ0DDsRGu-xORT_9jwgJpVjEo9ZS29hkk1lP_DsM74-lmYEtAgDOZ08OHGVeJl6PA1Q_ERAcueZxrEPTLQ8MHI2GonfsLulvOCGL_lXuT2l_ENh6TM75nCNkXOgCRzRbii2uB39RBeziYWghXSmkA\">The JS Bifrost —Pub-Sub way to code | by Rishikesh Andhale | Globant | Medium</a></li>\n<li><a href=\"https://github.com/EventEmitter2/EventEmitter2\">EventEmitter2/EventEmitter2: A nodejs event emitter implementation with namespaces, wildcards, TTL, works in the browser</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B00JVLEYY2/ref=sr_1_16?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&#x26;dchild=1&#x26;keywords=javascript%E5%BC%82%E6%AD%A5&#x26;qid=1618792066&#x26;s=digital-text&#x26;sr=1-16\">JavaScript异步编程:设计快速响应的网络应用 (图灵程序设计丛书 27)-Kindle商店-亚马逊中国</a></li>\n</ul>\n","title":"javascript-发布与订阅模式","date":"2021/4/19","tags":["JavaScript","设计模式"],"mainImg":"https://images.unsplash.com/photo-1503901680383-b1d31b841841?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTg3ODI5NzQ&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1503901680383-b1d31b841841?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTg3ODI5NzQ&ixlib=rb-1.2.1&q=80&w=400","intro":"我之前有听过发布/订阅模式,但是今天才看到 JavaScript 异步编程,书上有相关的介绍,于是记下学习心得."}},"__N_SSG":true}
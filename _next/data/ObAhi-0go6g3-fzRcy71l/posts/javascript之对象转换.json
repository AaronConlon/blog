{"pageProps":{"post":{"slug":"javascript之对象转换","contentHtml":"<p>在机缘巧合之下,我看到了国外大神<code>Dr.Axel Rauschmayer</code>的博客:<a href=\"https://2ality.com/index.html\">2ality – JavaScript and more</a>,其中一篇文章针对<code>类型转换</code>这个问题作了分享,本着求知的想法我静下心阅读了此文,所得所想记录于此.</p>\n<p><strong>2021年03月22日18:52:54</strong></p>\n<h2>1. 起始</h2>\n<p><code>JavaScript</code> 是优秀的动态语言,数据类型的转换在日常编程开发中十分常见.本文将结合一些实际问题和个人疑惑对<code>类型转换</code>进行学习和解析,尽量从<code>ECMAScript规范</code>出发,学习类型转换的设计理念和实现逻辑.</p>\n<blockquote>\n<p>如果喜欢,不妨亲自阅读 <a href=\"https://tc39.es/ecma262/multipage/\">ECMAScript® 2022 Language Specification</a></p>\n</blockquote>\n<h2>2. 何为类型转换?</h2>\n<p>首先我们要明确<code>JavaScript</code>数据分为:</p>\n<ul>\n<li>原始数据类型(primitive)\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>string</li>\n<li>number</li>\n<li>biginit</li>\n<li>boolean</li>\n<li>symbol</li>\n</ul>\n</li>\n<li>对象</li>\n</ul>\n<p>看看这一行代码:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'3'</span>) * <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'2'</span>)</code></pre> \n\n<p>两个数字之间使用乘法操作符相乘,数字类型是明确的从字符串通过<code>Number()</code>函数<code>显式</code>转过来的.</p>\n<p>字符串之间<code>\"不能\"</code>直接执行乘法.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'a'</span> * <span class=\"hljs-string\">'b'</span> <span class=\"hljs-comment\">// NaN</span></code></pre> \n\n<p>也许你会举出如下可行的例子:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'1'</span> * <span class=\"hljs-string\">'2'</span> <span class=\"hljs-comment\">// 2</span></code></pre> \n\n<p>此时,字符串之间的乘法得出了我们想要的结果.究其实质是因为解释器对字符串进行了<code>隐式类型转换(coercion)</code>.</p>\n<p>JavaScript 语言初期并没有设计异常捕获(<code>exceptions</code>),这也是为什么你会看到现今解释器对如下代码的解释.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 1</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// Infinity , 很明显, 0 作为分母是错误的,但是解释器最后的值是 Infinity</span>\n<span class=\"lineNumber\">3</span><span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'a'</span>) <span class=\"hljs-comment\">// NaN </span></code></pre> \n\n<p>为了实现兼容,<code>ECMAScript</code>不得不\"允许\"这部分错误的设计继续存在.但是,对于一些相对较新的特性来说,修复了这个错误的设计.</p>\n<p>例如:</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"lineNumber\">1</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-built_in\">Symbol</span>() <span class=\"hljs-comment\">// except error: can not cover a symbol value to a number</span>\n<span class=\"lineNumber\">2</span> \n<span class=\"lineNumber\">3</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2n</span> <span class=\"hljs-comment\">// except error: can not mix BigInt and other types,use explicit conversions</span>\n<span class=\"lineNumber\">4</span> \n<span class=\"lineNumber\">5</span><span class=\"hljs-number\">1</span>() <span class=\"hljs-comment\">// except error: 1 is not a function</span>\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// except error: 1 is not a constructor</span>\n<span class=\"lineNumber\">8</span> \n<span class=\"lineNumber\">9</span><span class=\"hljs-string\">'ab'</span>.length = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 只读属性不可改</span></code></pre> \n\n<h2>3. ECMAScript 规范是如何定义类型转换的?</h2>\n<p>先来看看如下一个使用<code>Typescript</code>编写的函数:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">multiply</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-comment\">// ...</span>\n<span class=\"lineNumber\">3</span>}</code></pre> \n\n<p>如上所示,此函数的两个参数的类型都是<code>number</code>,在转译为<code>JavaScript</code>的过程中,转译器做了什么?</p>\n<p>为了在转译后保证参数类型正确,其过程简述为如下代码:</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">multiply</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">let</span> _a = ToNumberic(a);\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-keyword\">let</span> _b = ToNumberic(b);\n<span class=\"lineNumber\">4</span>  <span class=\"hljs-comment\">/// ...</span>\n<span class=\"lineNumber\">5</span>}</code></pre> \n\n<h3>3.1 转换为原始数据类型或对象</h3>\n<p>当语句需要执行隐式转换的时候,如下<code>抽象操作</code>函数将目标数据转换为预期的原始数据类型或者<code>Object</code>:</p>\n<ul>\n<li>ToBoolean()</li>\n<li>ToNumber()</li>\n<li>ToBumeric(), 兼顾 number 和 BigInt</li>\n<li>ToBigInt()</li>\n<li>ToString()</li>\n<li>ToObject()</li>\n</ul>\n<blockquote>\n<p><a href=\"https://tc39.es/ecma262/#sec-abstract-operations\">抽象操作</a>是在ECMAScript规范中定义的函数,它们的定义是为了简洁地编写规范.JavaScript引擎不必将它们作为单独的函数在引擎中实现.不能直接从JavaScript调用它们.但是引擎实现了类似<code>Number()</code>这样的显示转换函数.</p>\n</blockquote>\n<h3>3.2 转换为数字类型</h3>\n<p>对于需要被隐式转化为<code>numeric</code>类型数据的值来说,将会用到<code>ToNumeric</code>抽象操作.转换的结果可能是<code>number</code>类型或者<code>BigInt</code>类型.</p>\n<p>如若需要将<code>x</code>转换为整形,则使用抽象操作<code>ToInteger</code>.在使用<code>位操作</code>的时候执行的隐式转换则视情形使用抽象操作<code>ToInt32</code>或者<code>ToUint32</code>.</p>\n<p>例如:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'1'</span> >> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 使用 ToInt32 抽象方法转为 32 位整数</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-number\">2</span> >> <span class=\"hljs-string\">'1'</span> <span class=\"hljs-comment\">// 使用 ToUint32 抽象方法转为无符号 32 位整数</span>\n<span class=\"lineNumber\">3</span>-<span class=\"hljs-number\">2</span> >>> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// -2 的二进制表示属于有符号数,因此需要 ToUint32 转换,最后结果是 4294967294</span></code></pre> \n\n<p>更多细则如下表所示:</p>\n<p>| operand        | left operand | right operand | result   |\n| :------------- | :----------- | :------------ | :------- |\n| <code>&#x3C;&#x3C;</code>           | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| signed <code>>></code>    | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| unsigned <code>>>></code> | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Uint32</code> |\n| <code>&#x26;</code>, <code>^</code>, <code>|</code>  | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| <code>~</code>            | —            | <code>ToInt32()</code>   | <code>Int32</code>  |</p>\n<h3>3.3 转换为属性<code>keys</code>属性</h3>\n<p>抽象操作<code>ToPropertyKey</code>返回一个字符串或者<code>Symbol</code>,常用于:</p>\n<ul>\n<li>括号操作</li>\n<li>对象字面量的计算属性</li>\n<li>in 操作符的<code>left-hand side</code>,用于判定<code>in</code> 的结果</li>\n<li>Object 的几个需要访问<code>value</code>和遍历<code>key</code>相关的函数\n<ul>\n<li>Object.fromEntries</li>\n<li>Object.defineProperty</li>\n<li>Object.getOwnPropertyDescriptor</li>\n<li>Object.prototype.hasOwnProperty</li>\n<li>Object.prototype.propertyIsEnumerable</li>\n</ul>\n</li>\n<li>Reflect 对象的相关方法</li>\n</ul>\n<h3>3.4 转换为数组索引(Array indices)</h3>\n<ul>\n<li><code>ToLength()</code> 主要用于字符串索引计算\n<ul>\n<li>此抽象方法是<code>ToIndex</code>抽象方法的辅助方法</li>\n<li>其值范围是0 ≤ ? ≤ Math.MAX_SAVE_INTEGER</li>\n</ul>\n</li>\n<li><code>ToIndex()</code> 主要用于类数组索引计算\n<ul>\n<li>与 ToLength 主要区别在于,此抽象方法在索引越界的时候抛出异常</li>\n<li>其值范围是0 ≤ ? ≤ Math.MAX_SAVE_INTEGER</li>\n</ul>\n</li>\n<li><code>ToUint32()</code> 用于数组索引计算\n<ul>\n<li>其值范围是0 ≤ ? &#x3C; 2^32-1</li>\n</ul>\n</li>\n</ul>\n<h3>3.5 转换为类数组对象的元素</h3>\n<p>如果你要为<code>类数组</code>对象的某个元素设置值,将可能使用如下的抽象方法:</p>\n<ul>\n<li><code>ToInt8()</code></li>\n<li><code>ToUint8()</code></li>\n<li><code>ToUint8Clamp()</code></li>\n<li><code>ToInt16()</code></li>\n<li><code>ToUint16()</code></li>\n<li><code>ToInt32()</code></li>\n<li><code>ToUint32()</code></li>\n<li><code>ToBigInt64()</code></li>\n<li><code>ToBigUint64()</code></li>\n</ul>\n<p>例如:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">let</span> uint16 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>;\n<span class=\"lineNumber\">2</span>uint16 = <span class=\"hljs-built_in\">Int16Array</span>.from(<span class=\"hljs-string\">'12345'</span>);\n<span class=\"lineNumber\">3</span> \n<span class=\"lineNumber\">4</span><span class=\"hljs-built_in\">console</span>.log(uint16);\n<span class=\"lineNumber\">5</span><span class=\"hljs-comment\">// expected output: Int16Array [1, 2, 3, 4, 5]</span></code></pre> \n\n<p>此处的字符串<code>12345</code>在 <code>from</code>函数内部进行迭代,并且进行隐式的类型转换,最终为<code>Int16Array</code>对象设置了 5 个元素值.</p>\n<h2>4. ECMAScript 规范示例解读</h2>\n<p><code>ECMAScript</code>规范明确提供了<code>JavaScript</code>的所有实现算法详细设计.大多数的<code>抽象方法</code>并没有在<code>JavaScript </code>引擎中实现,但是依然有少数抽象方法可以近乎理解为<code>JavaScript</code>引擎中对应的部分函数实现.举个例子,如下内容是<code>ECMAScript</code>规范的一部分:</p>\n<ul>\n<li>Spec: If Type(value) is String\n<ul>\n<li>JavaScript: <code>if (TypeOf(value) === 'string')</code> (very loose translation, defined below)</li>\n</ul>\n</li>\n<li>Spec: If IsCallable(method) is true\n<ul>\n<li>JavaScript: <code>if (IsCallable(method))</code> (defined below)</li>\n</ul>\n</li>\n<li>Spec: Let numValue be ToNumber(value)\n<ul>\n<li>JavaScript: <code>let numValue = Number(value)</code></li>\n</ul>\n</li>\n<li>Spec: Let isArray be IsArray(O)\n<ul>\n<li>JavaScript: <code>let isArray = Array.isArray(O)</code></li>\n</ul>\n</li>\n<li>Spec: If O has a [[NumberData]] internal slot\n<ul>\n<li>JavaScript: <code>if ('__NumberData__' in O)</code></li>\n</ul>\n</li>\n<li>Spec: Let tag be Get(O, @@toStringTag)\n<ul>\n<li>JavaScript: <code>let tag = O[Symbol.toStringTag]</code></li>\n</ul>\n</li>\n<li>Spec: Return the string-concatenation of \"[object \", tag, and \"]\".\n<ul>\n<li>JavaScript: <code>return '[object ' + tag + ']';</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>一开始阅读规范文档令人感觉很痛苦,但是慢慢坚持下来便有渐入佳境的感觉.</p>\n</blockquote>\n<h2>references</h2>\n<ul>\n<li><a href=\"https://2ality.com/2019/10/type-coercion.html\">Type coercion in JavaScript</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019240609\">怎样阅读 ECMAScript 规范？ - SegmentFault 思否</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/11/ecmascript-specification.html\">读懂 ECMAScript 规格 - 阮一峰的网络日志</a></li>\n</ul>\n","title":"javascript语言中的类型转换","date":"2021/3/22","tags":["javascript","tc39"],"mainImg":"https://images.unsplash.com/photo-1472437774355-71ab6752b434?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTY0MTAxMzQ&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1472437774355-71ab6752b434?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTY0MTAxMzQ&ixlib=rb-1.2.1&q=80&w=400","intro":"你好,TC39.请问 JavaScript 世界中的对象转换是如何实现的呢?"}},"__N_SSG":true}
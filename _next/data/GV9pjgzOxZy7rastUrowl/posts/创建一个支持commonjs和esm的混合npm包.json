{"pageProps":{"post":{"slug":"创建一个支持commonjs和esm的混合npm包","contentHtml":"<p>我们如何能轻松地创建一个同时支持<code>ESM</code>和<code>Commonjs</code>规范进行引入的<code>NPM package</code>?</p>\n<p>最好不需要创建两份源码,不需要使用诸如<code>webpack</code>之类的工具.</p>\n<h2>起始</h2>\n<p>这个问题由来已久,寻找一个使用单份源码创建一个轻松同时支持<code>Commonjs</code>和<code>ES Modules</code>的<code>NPM package</code>的解决方案可能会让人很迷惑.</p>\n<blockquote>\n<p>同时支持<code>ESM</code>和<code>Commonjs</code>的<code>NPM Package</code>有时被开发者们称之为<code>Hybird package</code>,使用者可以轻松通过<code>import</code>或者<code>require</code>语法引入目标<code>package</code>.</p>\n</blockquote>\n<p>对于这个话题,开发者们众说纷纭,我们可以在网上轻松找到众多相关话题和<code>\"有效的解决方案\"</code>,但是在许多场景下存在一定的缺陷.</p>\n<p>许多方案需要使用<code>Webpack</code>或者<code>Rollup</code>等工具,甚至使用自定义脚本和其他构建工具,亦或是创建和维护使用<code>Commonjs</code>和<code>ES Modules</code>规范编写的双重源码库,然而大多数方案都无法生成高效的纯<code>ESM</code>代码.</p>\n<p>阅读<a href=\"https://nodejs.org/api/\">Node documentation</a>的时候,文档提及我们可以使用<code>.mjs</code>和<code>.cjs</code>扩展名来标识当前文件使用的是<code>ES Modules</code>规范或者<code>Commonjs</code>规范.</p>\n<h3>扩展名方案的问题</h3>\n<p>在说明我们最后的方案之前,让我们先来谈谈一些备受吹捧的解决技巧.</p>\n<blockquote>\n<p>为何不使用<code>.mjs</code>或者<code>.cjs</code>扩展名来表明内部代码规范?</p>\n</blockquote>\n<p><code>Node</code>支持源代码使用扩展名来标识源文件类型,乍一看当前特性合乎逻辑,扩展名的确通常用于标识文件类型.</p>\n<p>但是,这个特性仅仅适用于简单或独立的非混合案例.</p>\n<p>如果你需要编写一个<code>hybird</code>模块,并且使用了<code>.mjs</code>和<code>.cjs</code>扩展名特性,这意味着你需要编写两份针对不同规范的源代码,或者你需要使用第三方工具或者开发自己的工具去复制源码,并更改扩展名以及对不同源码进行适当的调整和修复,来满足使用此模块的开发者的引入方案.</p>\n<p><code>ESM</code>代码需要使用<code>import</code>关键字指明导入文件的路径.如果你从一个路径导入了具有<code>.mjs</code>扩展名的模块,那么则需要对代码进行一些微调才能在<code>.cjs</code>文件中引入此目标模块,反之亦然.</p>\n<p>甚至,许多前端工具链之间都不能很好地支持<code>.mjs</code>文件,一些 web 服务器缺乏对<code>.mjs</code>类型文件的<code>MIME</code>类型定义.也许你喜欢的打包工具目前甚至不能识别这类扩展名文件.所以,你得编写额外的配置或者引入其他插件来管理这些文件.</p>\n<h3>package.json type 属性的问题</h3>\n<blockquote>\n<p>还好,我们还有其他选择,例如设置<code>package.json</code>的<code>type</code>字段定义.</p>\n</blockquote>\n<p>为了解析和判定<code>.js</code>文件是一个<code>ES Module</code>还是一个<code>Commonjs Module</code>,Nodejs 支持在<code>package.json</code>中设置<code>type</code>字段属性,根据此字段的值来约定<code>.js</code>文件依据的规范是什么.</p>\n<p>如果<code>type</code>的值是<code>module</code>,则表明此项目下如若内部不包含其他层级的<code>package.json</code>,则所有的<code>.js</code>文件都遵循<code>ESM</code>规范,都是<code>ES Module</code>.</p>\n<p>如果<code>type</code>的值是<code>commonjs</code>,则表明这些<code>.js</code>代码遵循的是<code>commonjs</code>规范.</p>\n<blockquote>\n<p>通过显示设置<code>.cjs</code>或者<code>.mjs</code>后缀,可以覆盖此字段的声明.</p>\n</blockquote>\n<p>如果你的<code>package</code>源代码始终遵循一种规范,使用此<code>package</code>的开发者只能使用此规范进行引入,则此方案将能够良好运行.</p>\n<p>问题是当你想要开发一个<code>hybird</code>包,提供给开发者多种引入方案的选项,同时支持<code>ESM</code>和<code>Commonjs</code>规范的时候,这种方案并不不能简单满足我们的需求.</p>\n<p>为了使用<code>type</code>特性来实现<code>hybird</code>包的开发,需要引入更多额外的工具,让整个开发过程更加的复杂.</p>\n<h3>package.json 条件导出的问题</h3>\n<p>在<code>package.json</code>中使用<code>exports</code>条件导出可以定义一组入口点声明.</p>\n<p>我们的目标是创建<code>hybird</code>包,则需要为<code>require</code>和<code>import</code>两种方案定义不同的入口点.</p>\n<h5 style=\"text-align: left;color: darkblue\">package.json</h5>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span>{\n<span class=\"lineNumber\">2</span>    <span class=\"hljs-attr\">\"exports\"</span>: {\n<span class=\"lineNumber\">3</span>        <span class=\"hljs-attr\">\"import\"</span>: <span class=\"hljs-string\">\"./dist/mjs/index.js\"</span>,\n<span class=\"lineNumber\">4</span>        <span class=\"hljs-attr\">\"require\"</span>: <span class=\"hljs-string\">\"./dist/cjs/index.js\"</span>\n<span class=\"lineNumber\">5</span>    }\n<span class=\"lineNumber\">6</span>}</code></pre> \n\n<p>使用构建或者编译工具,我们使用一份源代码生成了两份打包文件来支持<code>ESM</code>和<code>Commonjs</code>引入.</p>\n<p>上述的<code>exports</code>属性指定了不同规范的加载入口点.</p>\n<p>但是,如果我们在<code>package.json</code>中指定了<code>type</code>的值为<code>module</code>,并且为<code>ESM</code>和<code>Commonjs</code>定义不同的入口点,并且入口点代码中使用了<code>require</code>引入其他的模块,则将会失败,因为子模块是根据<code>type</code>的值来约定文件内部规范的.</p>\n<p>换句话说,如果一个<code>Commonjs</code>包从<code>./dist/cjs/index.js</code>引入了此模块,但是<code>./dist/cjs/index.js</code>却通过<code>require</code>引入其他模块,则下一级测引入内容将根据<code>package.json</code>的<code>type</code>值进行判定模块所遵循的规范是什么.</p>\n<p>显而易见,当前<code>type</code>等于<code>module</code>,则下一层级是无法使用<code>ESM</code>禁止的<code>require</code>字段,最终引起错误.</p>\n<h3>最终方案</h3>\n<p>ok,让我们重新捋一遍目标需求:</p>\n<ul>\n<li>仅使用一份基础源码</li>\n<li>易于构建</li>\n<li>生成原生的 ESM 代码</li>\n<li>在不需要更多额外工具的情况下使用</li>\n<li>生成同时支持<code>ESM</code>和<code>Commonjs</code>规范的<code>hybird</code>包</li>\n</ul>\n<p>👇 下面进行实践演示:</p>\n<p>以下是项目结构:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"lineNumber\">1</span>.\n<span class=\"lineNumber\">2</span>├── clear.js\n<span class=\"lineNumber\">3</span>├── dist\n<span class=\"lineNumber\">4</span>│   ├── cjs\n<span class=\"lineNumber\">5</span>│   └── mjs\n<span class=\"lineNumber\">6</span>├── fixup.js\n<span class=\"lineNumber\">7</span>├── jest.config.js\n<span class=\"lineNumber\">8</span>├── package-lock.json\n<span class=\"lineNumber\">9</span>├── package.json\n<span class=\"lineNumber\">10</span>├── readme.md\n<span class=\"lineNumber\">11</span>├── src\n<span class=\"lineNumber\">12</span>│   └── index.ts\n<span class=\"lineNumber\">13</span>├── <span class=\"hljs-built_in\">test</span>\n<span class=\"lineNumber\">14</span>│   └── example.test.ts\n<span class=\"lineNumber\">15</span>├── tsconfig-base.json\n<span class=\"lineNumber\">16</span>├── tsconfig-cjs.json\n<span class=\"lineNumber\">17</span>└── tsconfig.json</code></pre> \n\n<p>由于源码使用<code>typescript</code>进行编写,这里简述<code>typescript</code>的配置文件:</p>\n<ul>\n<li>tsconfig.json</li>\n<li>tsconfig-base.json</li>\n<li>tsconfig-cjs.json</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// tsconfig.json, 针对 esm 规范</span>\n<span class=\"lineNumber\">2</span>{\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-attr\">\"extends\"</span>: <span class=\"hljs-string\">\"./tsconfig-base.json\"</span>, \n<span class=\"lineNumber\">4</span>  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n<span class=\"lineNumber\">5</span>    <span class=\"hljs-attr\">\"target\"</span>: <span class=\"hljs-string\">\"ESNext\"</span>,\n<span class=\"lineNumber\">6</span>    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"esnext\"</span>,\n<span class=\"lineNumber\">7</span>    <span class=\"hljs-attr\">\"outDir\"</span>: <span class=\"hljs-string\">\"dist/mjs\"</span>\n<span class=\"lineNumber\">8</span>  }\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span><span class=\"hljs-comment\">// tsconfig-cjs.json, 针对 Commonjs</span>\n<span class=\"lineNumber\">11</span>{\n<span class=\"lineNumber\">12</span>  <span class=\"hljs-attr\">\"extends\"</span>: <span class=\"hljs-string\">\"./tsconfig-base.json\"</span>,\n<span class=\"lineNumber\">13</span>  <span class=\"hljs-attr\">\"compilerOptions\"</span>: {\n<span class=\"lineNumber\">14</span>    <span class=\"hljs-attr\">\"module\"</span>: <span class=\"hljs-string\">\"commonjs\"</span>,\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-attr\">\"outDir\"</span>: <span class=\"hljs-string\">\"dist/cjs\"</span>,\n<span class=\"lineNumber\">16</span>    <span class=\"hljs-attr\">\"target\"</span>: <span class=\"hljs-string\">\"ES6\"</span>\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span>}\n<span class=\"lineNumber\">19</span><span class=\"hljs-comment\">// tsconfig-base.json 共享配置</span>\n<span class=\"lineNumber\">20</span>{\n<span class=\"lineNumber\">21</span>  ...\n<span class=\"lineNumber\">22</span>}</code></pre> \n\n<p><strong>核心代码</strong>为: <code>src/index.ts</code>:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">arrayShuffle</span>(<span class=\"hljs-params\">params: <span class=\"hljs-built_in\">any</span>[]</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">let</span> len = params.length;\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-keyword\">while</span> (len > <span class=\"hljs-number\">1</span>) {\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * len--);\n<span class=\"lineNumber\">5</span>    <span class=\"hljs-comment\">// eslint-disable-next-line no-param-reassign</span>\n<span class=\"lineNumber\">6</span>    [params[len], params[index]] = [params[index], params[len]];\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span class=\"hljs-keyword\">return</span> params;\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span> \n<span class=\"lineNumber\">11</span><span class=\"hljs-keyword\">export</span> { arrayShuffle };</code></pre> \n\n<p>简单导出了一个数组的工具函数,对数组元素进行重新排序.</p>\n<p>对这份源码进行编译构建,一份构建为<code>ESM</code>模块,一份构建为<code>Commonjs</code>模块.以下是<code>package.json</code>中关键的构建<code>scripts</code>:</p>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span>{\n<span class=\"lineNumber\">2</span>    <span class=\"hljs-attr\">\"scripts\"</span>: {\n<span class=\"lineNumber\">3</span>        <span class=\"hljs-attr\">\"build\"</span>: <span class=\"hljs-string\">\"node clear.js &#x26;&#x26; tsc -p tsconfig.json &#x26;&#x26; tsc -p tsconfig-cjs.json &#x26;&#x26; node fixup.js\"</span>\n<span class=\"lineNumber\">4</span>    }\n<span class=\"lineNumber\">5</span>}</code></pre> \n\n<p>为了让<code>windows</code>用户获得一致性体验,这里不使用<code>rm</code>命令对<code>dist</code>进行清理.</p>\n<p>以下是上述内容提及的两个脚本:</p>\n<ul>\n<li>clear.js: 清理<code>dist</code>内部文件</li>\n<li>fixup.js: 为构建好的<code>dist</code>内不同目录下的<code>package.json</code>设置不同的<code>type</code>属性值.</li>\n</ul>\n<p><code>fixup.js</code> 的作用是创建<code>dist/cjs/package.json</code>和<code>dist/mjs/package.json</code>文件,为两种引入方案定义内部<code>type</code>.</p>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// dist/cjs/package.json</span>\n<span class=\"lineNumber\">2</span>{\n<span class=\"lineNumber\">3</span>    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"commonjs\"</span>\n<span class=\"lineNumber\">4</span>}\n<span class=\"lineNumber\">5</span><span class=\"hljs-comment\">// dist/mjs/package.json`</span>\n<span class=\"lineNumber\">6</span>{\n<span class=\"lineNumber\">7</span>    <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"module\"</span>\n<span class=\"lineNumber\">8</span>}</code></pre> \n\n<p>关于<code>package.json</code>文件:</p>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span>{\t\n<span class=\"lineNumber\">2</span>  ...\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-attr\">\"scripts\"</span>: {\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-attr\">\"test\"</span>: <span class=\"hljs-string\">\"jest\"</span>,\n<span class=\"lineNumber\">5</span>    <span class=\"hljs-attr\">\"build\"</span>: <span class=\"hljs-string\">\"node clear.js &#x26;&#x26; tsc -p tsconfig.json &#x26;&#x26; tsc -p tsconfig-cjs.json &#x26;&#x26; node fixup.js\"</span>,\n<span class=\"lineNumber\">6</span>    <span class=\"hljs-attr\">\"lint\"</span>: <span class=\"hljs-string\">\"eslint ./src/*\"</span>\n<span class=\"lineNumber\">7</span>  },\n<span class=\"lineNumber\">8</span> \t...\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-attr\">\"exports\"</span>: {\n<span class=\"lineNumber\">10</span>    <span class=\"hljs-attr\">\".\"</span>: {\n<span class=\"lineNumber\">11</span>      <span class=\"hljs-attr\">\"require\"</span>: <span class=\"hljs-string\">\"./dist/cjs/index.js\"</span>,\n<span class=\"lineNumber\">12</span>      <span class=\"hljs-attr\">\"import\"</span>: <span class=\"hljs-string\">\"./dist/mjs/index.js\"</span>\n<span class=\"lineNumber\">13</span>    }\n<span class=\"lineNumber\">14</span>  }\n<span class=\"lineNumber\">15</span>}\n<span class=\"lineNumber\">16</span></code></pre> \n\n<p>不必添加<code>type</code>属性,在使用<code>fixup</code>脚本的时候,我们将它写入了不同目标规范的子目录内的<code>package.json</code>中了,另外还定义了一个导出映射对象:</p>\n<pre><code class=\"hljs language-json\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">\"exports\"</span>: {\n<span class=\"lineNumber\">2</span>    <span class=\"hljs-attr\">\".\"</span>: {\n<span class=\"lineNumber\">3</span>        <span class=\"hljs-attr\">\"import\"</span>: <span class=\"hljs-string\">\"./dist/mjs/index.js\"</span>,  <span class=\"hljs-comment\">// ESM </span>\n<span class=\"lineNumber\">4</span>        <span class=\"hljs-attr\">\"require\"</span>: <span class=\"hljs-string\">\"./dist/cjs/index.js\"</span>\t<span class=\"hljs-comment\">// Commonjs</span>\n<span class=\"lineNumber\">5</span>    }\n<span class=\"lineNumber\">6</span>}</code></pre> \n\n<h2>总结</h2>\n<p>综上所述,我们最终构建了一个<code>hybird</code>包,同时支持不同开发者的不同引入方案.</p>\n<p>开发者可以选择<code>import</code>或者<code>require</code>两种方案引入我们的包.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-comment\">// ESM</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-keyword\">import</span> { arrayShuffle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'shuffle-my-array'</span>;\n<span class=\"lineNumber\">3</span><span class=\"hljs-comment\">// 或者</span>\n<span class=\"lineNumber\">4</span><span class=\"hljs-comment\">// commonjs</span>\n<span class=\"lineNumber\">5</span><span class=\"hljs-keyword\">const</span> { arrayShuffle } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'shuffle-my-array);</span></code></pre> \n\n<p>参考此方案,你可以轻松使用<code>ESNext</code>或者<code>Typescript</code>进行开发编写一份源码,最终构建特定的<code>hybird package</code>.</p>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://www.sensedeep.com/blog/posts/2021/how-to-create-single-source-npm-module.html\">How to Create a Hybrid NPM Module for ESM and CommonJS. | SenseDeep</a></li>\n<li><a href=\"https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77\">Get Ready For ESM. JavaScript Modules will soon be a… | by Sindre Sorhus | Jan, 2021 | 🦄 Sindre Sorhus’ blog</a></li>\n<li><a href=\"https://2ality.com/2019/10/hybrid-npm-packages.html\">Hybrid npm packages (ESM and CommonJS)</a></li>\n<li>源码: <a href=\"https://github.com/youyiqin/array_shuffle\">youyiqin/array_shuffle: It's a awesome function to help you to reorder your array elements.</a></li>\n</ul>\n","title":"创建一个支持commonjs和esm的混合npm包","date":"2021/2/24","tags":["npm"],"mainImg":"https://images.unsplash.com/photo-1613764225051-a4b7649e938c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1613764225051-a4b7649e938c?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"如何创建一个同时支持 esm 和 commonjs 两种规范的混合包?"}},"__N_SSG":true}
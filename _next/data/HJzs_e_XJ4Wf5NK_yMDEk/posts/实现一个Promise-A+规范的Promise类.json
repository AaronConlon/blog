{"pageProps":{"post":{"slug":"实现一个Promise-A+规范的Promise类","contentHtml":"<p>我之所以做这件事是因为我想更深入理解 <code>Promise</code> 的设计理念和设计原理，我看了一些文章和介绍，搜索了一些知识，也学习了其他人的 <code>Promise</code>实现源码。</p>\n<p>这真的很令我振奋，通过实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>类，我对<code>Promise</code>的理解有了不错的进步，那就废话少说，开始吧。</p>\n<h3>思考🤔</h3>\n<p>在我们开始之前，假设我们处于一个密闭空间，触手可及的只有手头的键盘。</p>\n<p>想想，用少量词汇组织将要写的代码的内容，例如：</p>\n<ul>\n<li>我的 Promise 实现命名为<code>Yi</code></li>\n<li><code>Yi</code>初始值为<code>undefined</code>，初始状态为<code>pending</code>，状态可以转变为<code>fulfilled</code>或者<code>rejected</code>,状态改变后不可逆，状态改变的逻辑只执行一次。</li>\n<li><code>Yi</code>具备两个静态方法：<code>resolve</code>和<code>reject</code>，当状态为<code>pending</code>时才执行逻辑，这样执行一次之后就直接返回，执行这两个方法都会</li>\n</ul>\n<p>很快，我们的实现可能如下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Yi</span>(<span class=\"hljs-params\">executor</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'pending'</span>\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">4</span>  executor(<span class=\"hljs-built_in\">this</span>.resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.reject.bind(<span class=\"hljs-built_in\">this</span>))\n<span class=\"lineNumber\">5</span>}\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span>Yi.prototype.resolve = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">8</span>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'fulfilled'</span>\n<span class=\"lineNumber\">10</span>  <span class=\"hljs-built_in\">this</span>.value = value\n<span class=\"lineNumber\">11</span>}\n<span class=\"lineNumber\">12</span> \n<span class=\"lineNumber\">13</span>Yi.prototype.reject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{\n<span class=\"lineNumber\">14</span>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">15</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'rejected'</span>\n<span class=\"lineNumber\">16</span>  <span class=\"hljs-built_in\">this</span>.value = reason\n<span class=\"lineNumber\">17</span>}</code></pre> \n\n<p>很棒，接着考虑其他功能，<code>Yi</code>应该实现<code>then</code>方法！</p>\n<blockquote>\n<p><code>then</code>方法是<code>Promise/A+</code>规范的核心部分。</p>\n</blockquote>\n<p>那么，<code>then</code>方法必须提供的功能又有哪些才行呢？呃呃😯，想想可能会是：</p>\n<ul>\n<li><code>then</code>接收两个方法：<code>onFulfilled</code>和<code>onRejected</code></li>\n<li>返回一个新的<code>Yi（Promise）</code>实例，这样可以进行链式调用。</li>\n<li>同一个<code>Yi(Promise)</code>实例的<code>then</code>方法可以执行很多次，每次都应该把新的<code>Yi（Promise）</code>实例保存到一个数组中，一个实例对象可能在其不同状态下注册了许多状态变更后的异步，我们将之交给<code>then</code>或者<code>catch</code>方法新生成的<code>Yi(Promise)</code>实例去执行。</li>\n<li><code>Yi</code>应该用一个数组保存<code>then</code>注册的状态变更回调任务，在合适的时候将当前<code>Yi(Promise)</code>实例的下一个状态的回调通过异步<code>Api</code>调用。</li>\n</ul>\n<blockquote>\n<p>构造器接收的函数应该是一个<code>executor</code>函数参数，这个函数被同步执行。</p>\n</blockquote>\n<p>那么，之前的代码应该改一改：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Yi</span>(<span class=\"hljs-params\">executor</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'pending'</span>\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">4</span>  <span class=\"hljs-built_in\">this</span>.consumers = []\n<span class=\"lineNumber\">5</span>  executor(<span class=\"hljs-built_in\">this</span>.resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>.reject.bind(<span class=\"hljs-built_in\">this</span>))\n<span class=\"lineNumber\">6</span>}\n<span class=\"lineNumber\">7</span> \n<span class=\"lineNumber\">8</span>Yi.prototype.resolve = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">10</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'fulfilled'</span>\n<span class=\"lineNumber\">11</span>  <span class=\"hljs-built_in\">this</span>.value = value\n<span class=\"lineNumber\">12</span>  <span class=\"hljs-comment\">// 状态变更则广播给自己的 consumers</span>\n<span class=\"lineNumber\">13</span>  <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">14</span>}\n<span class=\"lineNumber\">15</span> \n<span class=\"lineNumber\">16</span>Yi.prototype.reject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{\n<span class=\"lineNumber\">17</span>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">18</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'rejected'</span>\n<span class=\"lineNumber\">19</span>  <span class=\"hljs-built_in\">this</span>.value = reason\n<span class=\"lineNumber\">20</span>  <span class=\"hljs-comment\">// 状态变更则广播给自己的 consumers</span>\n<span class=\"lineNumber\">21</span>  <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">22</span>}</code></pre> \n\n<p><code>构造器</code>内部用一个<code>consumers</code>数组保存<code>then</code>和<code>catch</code>实例方法中实例化的<code>Yi(promise)</code>对象。</p>\n<p>在<code>then</code>方法中需要实例化一个新的<code>Yi(Promise)</code>对象，并且为之定义<code>settled</code>状态后的属性<code>onFulfilled</code>和<code>onRejected</code>，执行异步任务的逻辑，用一个<code>broadcase</code>函数封装起来：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>Yi.prototype.then = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> Yi(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{})\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-comment\">// 现在，这个返回且被保存到当前 Yi 实例的 consumers 数组中的新实例具有了两个状态稳定后的属性</span>\n<span class=\"lineNumber\">4</span>  promise.onFulfilled = <span class=\"hljs-keyword\">typeof</span> onFulfilled === <span class=\"hljs-string\">'function'</span> ? onFulfilled : <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">5</span>  promise.onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">'function'</span> ? onRejected : <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">6</span>  <span class=\"hljs-built_in\">this</span>.consumers.push(promise)\n<span class=\"lineNumber\">7</span>  <span class=\"hljs-comment\">// 发出广播，当旧的 Yi 实例为 settled 状态下的时候可以直接调用相关属性任务</span>\n<span class=\"lineNumber\">8</span>  <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-keyword\">return</span> promise\n<span class=\"lineNumber\">10</span>}\n<span class=\"lineNumber\">11</span> \n<span class=\"lineNumber\">12</span>Yi.prototype.broadcast = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">13</span>  <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">14</span>  <span class=\"hljs-comment\">// called after promise is resolved</span>\n<span class=\"lineNumber\">15</span>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state === <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>\n<span class=\"lineNumber\">16</span> \n<span class=\"lineNumber\">17</span>  <span class=\"hljs-keyword\">const</span> callbackType = <span class=\"hljs-built_in\">this</span>.state === <span class=\"hljs-string\">'fulfilled'</span> ? <span class=\"hljs-string\">'onFulfilled'</span> : <span class=\"hljs-string\">'onRejected'</span>\n<span class=\"lineNumber\">18</span>  <span class=\"hljs-keyword\">const</span> toSettled = <span class=\"hljs-built_in\">this</span>.state === <span class=\"hljs-string\">'fulfilled'</span> ? <span class=\"hljs-string\">'resolve'</span> : <span class=\"hljs-string\">'reject'</span>\n<span class=\"lineNumber\">19</span> \n<span class=\"lineNumber\">20</span>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n<span class=\"lineNumber\">21</span>    <span class=\"hljs-comment\">// 当状态改变后将此前 then 保存的 consumers 内的 promise 全部广播一遍状态变更的消息，并且清空此数组</span>\n<span class=\"lineNumber\">22</span>    promise.consumers.splice(<span class=\"hljs-number\">0</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">consumer</span> =></span> {\n<span class=\"lineNumber\">23</span>      <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">24</span>        <span class=\"hljs-keyword\">const</span> callback = consumer[callbackType]\n<span class=\"lineNumber\">25</span>        <span class=\"hljs-comment\">// 如果 promise 具有 onFulfilled 或者 onRejected 方法，在 then 方法执行的时候添加的</span>\n<span class=\"lineNumber\">26</span>        <span class=\"hljs-comment\">// 在 then 的时候判定是否为函数，不是函数则 callback 为 undefined</span>\n<span class=\"lineNumber\">27</span>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">callback</span>)</span> {\n<span class=\"lineNumber\">28</span>          consumer.resolve(callback(promise.value))\n<span class=\"lineNumber\">29</span>        } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">30</span>          <span class=\"hljs-comment\">// callback 不是函数，那就默认按状态改变值</span>\n<span class=\"lineNumber\">31</span>          <span class=\"hljs-comment\">// 状态转为 settled</span>\n<span class=\"lineNumber\">32</span>          consumer[toSettled](promise.value)\n<span class=\"lineNumber\">33</span>        }\n<span class=\"lineNumber\">34</span>      } <span class=\"hljs-keyword\">catch</span> (e) {\n<span class=\"lineNumber\">35</span>        <span class=\"hljs-comment\">// 异常捕获为 Rejected 状态下的 reason</span>\n<span class=\"lineNumber\">36</span>        consumer.reject(e)\n<span class=\"lineNumber\">37</span>      }\n<span class=\"lineNumber\">38</span>    })\n<span class=\"lineNumber\">39</span>  }, <span class=\"hljs-number\">0</span>);\n<span class=\"lineNumber\">40</span>}</code></pre> \n\n<p>对于类似笔者这种功力不足的开发者来说，为了更好地实现<code>Yi</code>，理解<code>Promise</code>的原理，我想可以降低整体的复杂度，先用<code>setTimeout</code>模拟微任务，后续最终版本一定会按平台通过<code>nextTick</code>或者<code>MutationObserver</code>来替换<code>setTimeout</code>。</p>\n<p>话说回来，<code>then</code>方法中我们实例化一个不会在<code>executor</code>中同步让自己进入<code>settled</code>状态的<code>Yi(promise)</code>实例，并且根据当前的实例状态为这个新的实例添加了两个属性方法<code>onFulfilled</code>和<code>onRejected</code>，然后将之放入当前实例的<code>consumers</code>数组中暂存。</p>\n<p>接着，我们调用了一个核心函数：<code>broadcast</code>。</p>\n<p>瞧瞧其实现，如若当前实例在<code>pending</code>状态下调用此方法，我们直接返回。</p>\n<p>只有进入<code>settled</code>状态，我们再根据其状态<code>fulfilled</code>或者<code>rejected</code>来获取我们将要调用的异步任务函数，也就是在<code>then</code>方法的<code>executor</code>函数中为新<code>Yi(Promise)</code>实例创建的属性方法。</p>\n<p>我们为初始化的<code>Yi(Promise)</code>实例通过<code>then</code>传入的状态变更处理函数<code>onFulfilled</code>和<code>onRejected</code>赋值给了内部新实例化，且在<code>then</code>中返回的<code>Yi(Promise)</code>实例。</p>\n<p>在<code>resolve</code>、<code>reject</code>这两个可以变更实例状态的方法中调用了<code>broadcast</code>方法。</p>\n<p>因为而状态变更会让所有的元素都执行<code>then</code>中添加的异步任务，并且我们的实例可以在不同时机多次调用<code>then</code>方法新增<code>consumers</code>的元素，因此需要在适当的时机清空当前实例的<code>consumers</code>数组。</p>\n<p>对于一个<code>Promise</code>的实现来说，我们还需要添加一个<code>catch</code>方法，这个方法可以看成<code>then</code>方法的语法糖。</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>Yi.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onRejected</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.then(<span class=\"hljs-literal\">undefined</span>, onRejected)\n<span class=\"lineNumber\">3</span>}</code></pre> \n\n","title":"实现一个Promise-A+规范的Promise类","date":"2021/5/12","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=400","intro":"为了学习 Promise 的原理，加深对异步 Promise 的理解，我们很有必要学习如何实现一个符合 Promise/A+ 规范的 Promise 类"}},"__N_SSG":true}
{"pageProps":{"post":{"slug":"Javascript,I-promise","contentHtml":"<p>虽然此前我已经接触过一些异步编程的概念,并且有过一定的实际运用.但是自我感觉,我对<code>JavaScript</code>异步编程的了解依然十分浅显,因此我打算再次对<code>JavaScript</code>中的异步编程进行学习和总结,然后分享出来.</p>\n<h1>1. 前文</h1>\n<p>在对<code>Promise</code>知识进行总结之前,我将回顾一部分<code>JavaScript</code>与异步编程相关的知识.</p>\n<h2>1.1 浅述 JavaScript 调用栈</h2>\n<p>当函数之间发生内嵌调用,将产生<code>函数调用栈</code>.</p>\n<blockquote>\n<p><code>函数调用栈</code>是解释器追踪函数执行流的一种机制,函数入栈的同事也保存了其上下文环境.</p>\n</blockquote>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">h</span>(<span class=\"hljs-params\">z</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>().stack)\n<span class=\"lineNumber\">3</span>}\n<span class=\"lineNumber\">4</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">g</span>(<span class=\"hljs-params\">y</span>) </span>{\n<span class=\"lineNumber\">5</span>  h(y + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">6</span>}\n<span class=\"lineNumber\">7</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">x</span>) </span>{\n<span class=\"lineNumber\">8</span>  g(x + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span>f(<span class=\"hljs-number\">1</span>)</code></pre> \n\n<p>如上述,随着调用函数<code>f(1)</code>,调用栈内开始存储函数<code>f(1)</code>,内部调用了<code>g(2)</code>也被存入调用栈,最后将<code>h(3)</code>存入调用栈,当前函数执行结束即将之从调用栈定移除,接着执行可能存在的剩余代码,最终调用栈被清空,执行流程回到全局作用域,最终打印如下:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-built_in\">Error</span>\n<span class=\"lineNumber\">2</span>    at h (REPL3:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">3</span>    at g (REPL6:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">4</span>    at f (REPL9:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">5</span>    at REPL10:<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">1</span>\n<span class=\"lineNumber\">6</span>    at Script.runInThisContext (node:vm:<span class=\"hljs-number\">133</span>:<span class=\"hljs-number\">18</span>)\n<span class=\"lineNumber\">7</span>    at REPLServer.defaultEval (node:repl:<span class=\"hljs-number\">474</span>:<span class=\"hljs-number\">29</span>)\n<span class=\"lineNumber\">8</span>    at bound (node:domain:<span class=\"hljs-number\">416</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">9</span>    at REPLServer.runBound [<span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">eval</span>] (node:domain:<span class=\"hljs-number\">427</span>:<span class=\"hljs-number\">12</span>)\n<span class=\"lineNumber\">10</span>    at REPLServer.onLine (node:repl:<span class=\"hljs-number\">793</span>:<span class=\"hljs-number\">10</span>)\n<span class=\"lineNumber\">11</span>    at REPLServer.emit (node:events:<span class=\"hljs-number\">388</span>:<span class=\"hljs-number\">22</span>)</code></pre> \n\n<p>栈是有限度的,不同环境的栈空间大小不等,分配的栈空间被占满之后,将会引发栈溢出错误.</p>\n<h2>1.2 浅述浏览器事件循环</h2>\n<p>我们可以简单的认为每个浏览器<code>tab</code>运行于一个简单的<code>事件循环</code>进程来实现<code>非阻塞</code>,浏览器中的诸多单一任务,例如:</p>\n<ul>\n<li>解析 HTML</li>\n<li>执行脚本中的 JavaScript 代码</li>\n<li>响应用户交互</li>\n<li>异步网络请求</li>\n<li>等等</li>\n</ul>\n<p>这些任务形成了独立于主线程的<code>任务队列(task queue)</code>,所有任务只能逐一通知主线程进行处理.由于<code>JavaScript</code>的单线程限制,即使<code>Web Worker标准</code>允许<code>JavaScript</code>脚本创建多个线程,但是子线程由主线程控制,且不可操作<code>DOM</code>,可以说<code>JavaScript</code>的本质依然是<code>单线程</code>.</p>\n<p>如下是<code>Philip Roberts</code>演讲的时候使用的示意图:</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png\" alt=\"\"></p>\n<p>当主线程执行栈上的同步任务执行完毕之后,就去读取<code>task queue</code>,按队列先进先出的属性,依次获取任务进行处理,然后重复检查主线程执行栈,通常我们为异步事件编写的<code>回调函数</code>,就进入了任务队列.</p>\n<p>如果再细分任务队列中的任务,依然可以分为:</p>\n<ul>\n<li>微任务(micro task)</li>\n<li>宏任务(macro task)</li>\n</ul>\n<p>像<code>setTimeout</code>和<code>setInterval</code>则是宏任务.</p>\n<blockquote>\n<p><strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行</strong>。</p>\n</blockquote>\n<h2>1.3 定时器简析</h2>\n<p><code>setTimeout(callback, ms)</code>函数创建了一个定时器等待若干毫秒, 然后将<code>callback</code>放入<code>task queue</code>,并且在等待计时器的其间脱离了主线程,这也就意味着如果主线程执行了耗时的同步任务,则任务队列被读取的时间就将被延迟了,因此可能不会在<code>ms</code>毫秒后执行<code>callback</code>回调函数.</p>\n<p>实际延时还有其他的影响因素.</p>\n<ul>\n<li>不同浏览器具有自己的<code>DOM_MIN_TIMEOUT_VALUE</code>,最小延时值.</li>\n<li>为了优化后台 tab 的加载损耗(以及降低耗电量),在未被激活的 tab 中定时器的最小延时限制为<code>1S</code>.</li>\n<li>追踪型脚本延时在后台 tabs 中,这个最小延时限制是 <code>10S</code>,这个限制会在文档第一次加载后的<code>30s</code>后生效.</li>\n</ul>\n<h2>1.4 显示 DOM 变化</h2>\n<p>对于大多数<code>DOM</code>元素的变化来说,它们的改动数据并不是实时更新的,<code>DOM</code>和<code>布局</code>的改动也是通过<code>事件循环</code>机制来实现的.如果需要频繁更新<code>DOM</code>,可以考虑<code>requestAnimationFrame()</code>函数.</p>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a></li>\n</ul>\n","title":"Javascript,I promise - 异步编程","date":"2021/4/9","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=400","intro":"Promise, JavaScript 世界中的异步处理对象.我阅读了 Dr.Axel 前辈的电子书,充满感激."}},"__N_SSG":true}
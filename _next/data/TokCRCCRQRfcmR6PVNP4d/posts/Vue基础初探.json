{"pageProps":{"post":{"slug":"Vue基础初探","contentHtml":"<h1>Vue3</h1>\n<h2>第一天</h2>\n<ul>\n<li>\n<p>defineComponent</p>\n<p>可以省略,也可以加上</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> defineComponent({\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"xx\"</span>,\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-attr\">component</span>: {},\n<span class=\"lineNumber\">4</span>\t<span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"lineNumber\">5</span>    <span class=\"hljs-comment\">// init variables</span>\n<span class=\"lineNumber\">6</span>  }  \n<span class=\"lineNumber\">7</span>})</code></pre> \n\n</li>\n<li>\n<p>setup 生命周期函数</p>\n<p>instead data function and methods function.</p>\n</li>\n<li>\n<p>reactive function</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"lineNumber\">2</span>    <span class=\"hljs-keyword\">const</span> data = reactive({\n<span class=\"lineNumber\">3</span>      <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">\"\"</span>,\n<span class=\"lineNumber\">4</span>      <span class=\"hljs-attr\">d</span>: <span class=\"hljs-function\">() =></span> {}\n<span class=\"lineNumber\">5</span>    });\n<span class=\"lineNumber\">6</span>    <span class=\"hljs-keyword\">return</span> {\n<span class=\"lineNumber\">7</span>      data,\n<span class=\"lineNumber\">8</span>    };\n<span class=\"lineNumber\">9</span>  },</code></pre> \n\n<p>通过<code>reactive</code>函数,创建了变量和方法,但是返回的时候后续再<code>template</code>里使用,都需要从<code>data</code>开始,而<code>vue</code>不支持扩展运算符解构,这会导致数据不再具有<code>响应式</code>能力.</p>\n</li>\n<li>\n<p>toRefs function</p>\n<p>通过使用<code>vue3</code>提供的<code>toRefs</code>函数,包装一次<code>data</code>,就可以使用扩展运算符了.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">return</span> {\n<span class=\"lineNumber\">2</span>  ...toRegs(data)\n<span class=\"lineNumber\">3</span>}</code></pre> \n\n</li>\n</ul>\n<h2>第二天</h2>\n<blockquote>\n<p>生命周期函数,vue2 到 vue3 发生了什么变化?</p>\n</blockquote>\n<p><code>vue3</code>提供了好几个生命周期函数,更加细粒度地控制组件和数据.</p>\n<h3>生命周期函数</h3>\n<ul>\n<li>setup() :开始创建组件之前，在<code>beforeCreate</code>和<code>created</code>之前执行。创建的是<code>data</code>和<code>method</code>.</li>\n<li>onBeforeMount() : 组件挂载到节点上之前执行的函数。</li>\n<li>onMounted() : 组件挂载完成后执行的函数。</li>\n<li>onBeforeUpdate(): 组件更新之前执行的函数。</li>\n<li>onUpdated(): 组件更新完成之后执行的函数。</li>\n<li>onBeforeUnmount(): 组件卸载之前执行的函数。</li>\n<li>onUnmounted(): 组件卸载完成后执行的函数</li>\n<li>onActivated(): 被包含在<code>&#x3C;keep-alive></code>中的组件，会多出两个生命周期钩子函数。被激活时执行。</li>\n<li>onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。</li>\n<li>onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数。</li>\n</ul>\n","title":"Vue基础初探","date":"2020/12/10","tags":[null],"mainImg":"https://images.unsplash.com/photo-1556998914-e5cb6fe38124?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1556998914-e5cb6fe38124?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"粗略看过两边文档,后续就没写过 vue 项目,工作上做了其他方面的内容,这里私下补一下,既可以应对以后的 vue 开发需求,也可以提高自己的开发水平.当前只是记录阅读网络上的他人博客内容的总结.它山之石可以攻玉."}},"__N_SSG":true}
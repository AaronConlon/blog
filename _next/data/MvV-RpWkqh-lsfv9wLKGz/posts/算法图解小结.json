{"pageProps":{"post":{"slug":"算法图解小结","contentHtml":"<p>感谢这本书将算法基础知识讲解得非常有趣且易懂，如果你看到这里，建议买一本~<a href=\"https://item.jd.com/12911513.html\">《算法图解（图灵出品）》- 京东图书</a>!</p>\n<h3>算法简介</h3>\n<ul>\n<li>二分查找的速度远超简单查找</li>\n<li>需要搜索的元素越多，<code>O(log n)</code>远比<code>O(n)</code>快</li>\n<li>算法运行时间并不是以<code>秒</code>为单位，而是从其增速的角度考量的，并且用<code>大 O 表示法</code>来表示</li>\n</ul>\n<h3>选择排序</h3>\n<ul>\n<li>计算机内存如一大堆<code>抽屉</code></li>\n<li>需要存储多个元素时，可以使用数组或链表</li>\n<li>数组的元素都在一起</li>\n<li>链表的元素都是分开的，其中每一个元素都存储了下一个元素的地址</li>\n<li>数组的读取速度快</li>\n<li>链表的插入和删除的速度快</li>\n<li>同一个数组中，所有元素的类型都必须相同</li>\n</ul>\n<h3>递归</h3>\n<ul>\n<li>递归指的是调用自己的函数</li>\n<li>递归的两个必要条件：\n<ul>\n<li>基线条件，何时终止</li>\n<li>递归条件，如何继续</li>\n</ul>\n</li>\n<li>栈的两个操作：压入和弹出</li>\n<li>所有函数调用都进入调用栈</li>\n<li>调用栈太长将会占用更多内存</li>\n</ul>\n<h3>快速排序</h3>\n<ul>\n<li>D&#x26;C（分治算法）将问题逐步分解，使用此算法处理数组时，基线条件常常是空数组或只包含一个元素的数组</li>\n<li>实现快速排序时，随机的选择用做基准值的元素，快速排序的平均运行时间是<code>O(nlog n)</code></li>\n<li>大 O 表示法中的常量有时候事关重大，这就是快速排序比合并排序快的最重要原因</li>\n<li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，<code>O(log n)</code>远远快于<code>O(n)</code></li>\n</ul>\n<h3>散列表</h3>\n<ul>\n<li>你可以结合散列函数和数组来创建散列表</li>\n<li>冲突很糟糕，选择更好的散列函数有助于减少冲突</li>\n<li>散列表的查找、插入、删除的速度非常快</li>\n<li>散列表适合用于模拟映射关系</li>\n<li>一旦填装因子大于 0.7，就应该调整散列表长度</li>\n<li>散列表可以用于缓存数据</li>\n<li>散列表适合防止重复</li>\n</ul>\n<h3>广度优先搜索</h3>\n<ul>\n<li>广度优先搜索适用于检查是否有从<code>A</code>到<code>B</code>的路径，并且在存在的情况下检查出最短路径</li>\n<li>面临寻找最短路径的问题时，可以<code>建立图模型</code>，再利用广度优先搜索来解决问题</li>\n<li>有向图中的箭头指代方向和双边关系</li>\n<li>无向图中不带箭头，双边关系是双向的</li>\n<li>队列先入先出</li>\n<li>栈先入后出</li>\n<li>广度优先搜索列表必须是队列，否则找到的就不是最短路径</li>\n<li>检查过的则无序再次检查，否则可能存在闭环</li>\n</ul>\n<h3>狄克斯特拉算法</h3>\n<ul>\n<li>广度优先搜索用于在<code>非加权图</code>中查找最短路径</li>\n<li>狄克斯特拉算法用于在<code>加权图</code>中查找最短路径</li>\n<li>仅当权重为<code>正</code>时，狄克斯特拉算法才有效</li>\n<li>图中包含负权重，则使用<code>贝尔曼-福德</code>算法</li>\n</ul>\n<h3>贪婪算法</h3>\n<blockquote>\n<p>每一步都采取局部最优解，最终产生全局最优解，有时候<code>完美</code>是<code>优秀</code>的敌人。</p>\n</blockquote>\n<ul>\n<li>\n<p>贪婪算法寻求局部最优解，企图以这种方式获得全局最优解</p>\n</li>\n<li>\n<p>对于 NP 完全问题，还没有找到快速解决方案</p>\n</li>\n<li>\n<p>面临完全 NP 问题时，最佳做法是使用近似算法</p>\n</li>\n<li>\n<p>贪婪算法易于实现，速度快，是不错的近似算法</p>\n</li>\n</ul>\n<h3>动态规划</h3>\n<blockquote>\n<p>仅当每一个子问题都是离散的，不依赖其他子问题时，动态规划才有效</p>\n</blockquote>\n<ul>\n<li>需要在给定约束条件下优化某种指标时，动态规划很有用</li>\n<li>问题可以分解为离散子问题时，可以使用动态规划来解决</li>\n<li>每种动态规划解决方案都涉及<code>网格</code></li>\n<li>单元格中的值通常是你需要优化的值</li>\n<li>每一个单元格都是一个子问题，因此需要考虑如何将问题拆分成子问题</li>\n<li>没有通用的<code>动态规划公式</code></li>\n</ul>\n<h3>K 最近邻算法</h3>\n<ul>\n<li>KNN 用于分类和回归，需要考虑最近的邻居</li>\n<li>分类就是编组，回归就是预测结果</li>\n<li>特征抽取意味着将物品转换为一系列可以比较的数字</li>\n<li>能否挑选合适的特征事关 KNN 算法的成败</li>\n</ul>\n<h3>傅里叶变换</h3>\n<blockquote>\n<p>如果你对数据库或高级数据结构感兴趣，去了解：B 树、红黑树、伸展树、堆。如果你对搜索引擎感兴趣，从反向索引入手是一个很好的选择。如果你对加密感兴趣，先着手研究 Diffie-Hellman 算法是不错的选择。如果你对最优化感兴趣，就研究研究线性规划吧！</p>\n</blockquote>\n","title":"算法图解小结和代码分析(摘抄)","date":"12/2/2021","tags":["算法"],"mainImg":"https://images.unsplash.com/photo-1589149098258-3e9102cd63d3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2Mzg0MzE5NjI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1589149098258-3e9102cd63d3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2Mzg0MzE5NjI&ixlib=rb-1.2.1&q=80&w=400","intro":"读了算法图解这本书📚，摘抄其总结，并且增加每一个主题的代码示例，便于以后回顾。"}},"__N_SSG":true}
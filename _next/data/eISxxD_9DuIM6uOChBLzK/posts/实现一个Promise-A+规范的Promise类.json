{"pageProps":{"post":{"slug":"实现一个Promise-A+规范的Promise类","contentHtml":"<p>我之所以做这件事是因为我想更深入理解 <code>Promise</code> 的设计理念和设计原理，我看了一些文章和介绍，搜索了一些知识，也学习了其他人的 <code>Promise</code>实现源码。</p>\n<p>这真的很令我振奋，通过实现一个符合<code>Promise/A+</code>规范的<code>Promise</code>类，我对<code>Promise</code>的理解有了不错的进步，那就废话少说，开始吧。</p>\n<h3>从规范到实现</h3>\n<p>在开始写代码之前，我们先阅读一下<a href=\"https://promisesaplus.com/\">Promises/A+</a>的官方文档。</p>\n<h4>几个术语</h4>\n<p>言而简之，官方文档上提及了五个术语，如下所示：</p>\n<ul>\n<li>Promise</li>\n<li>thenable</li>\n<li>value</li>\n<li>exception</li>\n<li>reason</li>\n</ul>\n<p><code>Promise</code>是一个具有<code>then</code>方法的对象或函数，并且此对象或者函数遵循<code>Promise/A+</code>规范。</p>\n<p><code>thenable</code>指的是一个对象或函数具有一个<code>then</code>方法</p>\n<p><code>value</code>是一个合法的<code>Javascript</code>值。</p>\n<p><code>exception</code>是一个使用<code>throw</code>语句抛出的值。</p>\n<p><code>reason</code>则是<code>Promise</code>状态转为<code>Rejected</code>的原因。</p>\n<h4>规范简述</h4>\n<p>阅读规范需求的描述是实现一个能通过测试的实现的关键。</p>\n<h5>Promise State</h5>\n<ul>\n<li>\n<p>2.1.1 一个<code>Promise</code>的状态只有如下三种：</p>\n</li>\n<li>\n<p>pending 初始化状态</p>\n<ul>\n<li>可以显式转换状态至<code>fulfilled</code>或<code>rejected</code></li>\n</ul>\n</li>\n<li>\n<p>fulfilled 成功</p>\n<ul>\n<li>2.1.2.1 状态不可再转换</li>\n<li>2.1.2.2 具有一个不可改变的<code>value</code></li>\n</ul>\n</li>\n<li>\n<p>rejected 失败</p>\n<ul>\n<li>2.1.3.1 状态不可再转换</li>\n<li>2.1.3.2 具有一个不可改变的<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>不可改变意味着可以使用<code>===</code>进行比较，并且始终为<code>true</code>，并非完全的深层属性不可变。</p>\n</blockquote>\n<p>除此之外，使用<code>new</code>实例化的时候，我们需要为构造函数提供一个<code>executor</code>函数参数。</p>\n<h5>思考🤔</h5>\n<p>现在我们从最简单的状态需求开始，假设我们处于一个密闭空间，触手可及的只有手头的键盘。</p>\n<p>思考一下如何实现上述<code>Promise State</code>，用少量词汇组织将要写的代码的内容，例如：</p>\n<ul>\n<li>我的 Promise 实现命名为<code>Yi</code></li>\n<li><code>Yi</code>初始值为<code>undefined</code>，初始状态为<code>pending</code>，状态可以转变为<code>fulfilled</code>或者<code>rejected</code>,状态改变后不可逆，状态改变的逻辑只执行一次。</li>\n<li><code>Yi</code>具备两个静态方法来显式转换其状态：<code>resolve</code>和<code>reject</code>，当状态为<code>pending</code>时才执行逻辑，这样一来一旦状态改变后续再执行此方法就无碍了。</li>\n</ul>\n<p>很快，我们的实现可能如下：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Y</span>(<span class=\"hljs-params\">executor</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-comment\">// 关于 executor</span>\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">executor === <span class=\"hljs-literal\">undefined</span></span>)</span> {\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'You must give a executor function.'</span>)\n<span class=\"lineNumber\">5</span>  }\n<span class=\"lineNumber\">6</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> executor !== <span class=\"hljs-string\">'function'</span></span>)</span> {\n<span class=\"lineNumber\">7</span>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Executor must be a function'</span>)\n<span class=\"lineNumber\">8</span>  }\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'pending'</span>\n<span class=\"lineNumber\">10</span>  <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">11</span>  executor(resolve, reject)\n<span class=\"lineNumber\">12</span> \n<span class=\"lineNumber\">13</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">14</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.1.1, 2.1.3.1</span>\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'fulfilled'</span> <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">16</span>    <span class=\"hljs-built_in\">this</span>.value = value <span class=\"hljs-comment\">// 2.1.2.2</span>\n<span class=\"lineNumber\">17</span>  }\n<span class=\"lineNumber\">18</span> \n<span class=\"lineNumber\">19</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n<span class=\"lineNumber\">20</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.1.1, 2.1.3.1</span>\n<span class=\"lineNumber\">21</span>    <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'rejected'</span> <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">22</span>    <span class=\"hljs-built_in\">this</span>.value = reason <span class=\"hljs-comment\">// 2.1.3.2</span>\n<span class=\"lineNumber\">23</span>  }\n<span class=\"lineNumber\">24</span>}</code></pre> \n\n<h5><code>then</code>方法</h5>\n<blockquote>\n<p><code>then</code>方法是<code>Promise/A+</code>规范的核心部分。</p>\n</blockquote>\n<p>一个<code>Promise</code>必须提供一个<code>then</code>方法以访问其<code>value</code>或<code>reason</code>,此方法需要接受两个可选参数：</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>promise.then(onFulfilled, onRejected)</code></pre> \n\n<p>其规范如下：</p>\n<ul>\n<li>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选的\n<ul>\n<li>2.2.1.1 如果<code>onFulfilled</code>不是一个函数，则忽略此参数</li>\n<li>2.2.1.2 如果<code>onRejected</code>不是一个函数，则忽略此参数</li>\n</ul>\n</li>\n<li>2.2.2 如果<code>onFulfilled</code>是一个函数\n<ul>\n<li>2.2.2.1 此函数在<code>promise</code>状态为<code>fulfilled</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.2.2 此函数不可在<code>promise</code>状态为<code>fullfilled</code>之前被调用</li>\n<li>2.2.2.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.3 如果<code>onRejected</code>是一个函数\n<ul>\n<li>2.2.3.1 此函数在<code>promise</code>状态为<code>rejected</code>的时候被异步调用，并且使用其<code>value</code>值作为第一个参数</li>\n<li>2.2.3.2 此函数不可在<code>promise</code>状态为<code>rejected</code>之前被调用</li>\n<li>2.2.3.3 在一个<code>promise</code>实例上只能被调用一次</li>\n</ul>\n</li>\n<li>2.2.4 <code>onFulfilled</code>和<code>onRejected</code>将被异步调用（在当前执行栈清空之前无法被调用）</li>\n<li>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须作为一个函数被调用（内部不应使用<code>this</code>值，原因在于严格模式和非严格模式的<code>this</code>值不一致）</li>\n<li>2.2.6 <code>then</code>可以在同一个<code>promise</code>实例上被多次调用，因此我们可以在不同的地方使用某个<code>promise.then</code>f方法\n<ul>\n<li>当<code>promise</code>状态为<code>fulfilled</code>时，所有的<code>then</code>上传入的<code>onFulfilled</code>函数将会按调用的次序依次执行</li>\n<li>当<code>promise</code>状态为<code>rejected</code>时，所有的<code>then</code>上传入的<code>onRejected</code>函数将会按调用的次序依次执行</li>\n</ul>\n</li>\n<li>2.2.7 <code>then</code>方法最终将返回一个新的<code>promise</code>实例: <code>promise2 = promise1.then(onFulfilled, onRejected)</code>\n<ul>\n<li>2.2.7.1 如果<code>onFulfilled</code>或<code>onRejected</code>返回一个值<code>x</code>，执行<code>Promise</code>的解析步骤： <code>[[Resolve]](promise2, x)</code></li>\n<li>2.2.7.2 如果<code>onFulfilled</code>或<code>onRejected</code>抛出一个异常<code>e</code>，则<code>promise2</code>直接<code>reject(e)</code></li>\n<li>2.2.7.3 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>fulfilled</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和值。</li>\n<li>2.2.7.4 如果<code>onFulfilled</code>不是一个函数，并且<code>promise1</code>状态为<code>rejected</code>，则<code>promise2</code>沿用<code>promise1</code>的状态和<code>reason</code></li>\n</ul>\n</li>\n</ul>\n<h5>完善 ✍️</h5>\n<p>按规范的定义，我们来完善之前的代码并实现<code>then</code>方法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Y</span>(<span class=\"hljs-params\">executor</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">executor === <span class=\"hljs-literal\">undefined</span></span>)</span> {\n<span class=\"lineNumber\">3</span>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'You must give a executor function.'</span>)\n<span class=\"lineNumber\">4</span>  }\n<span class=\"lineNumber\">5</span>  <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> executor !== <span class=\"hljs-string\">'function'</span></span>)</span> {\n<span class=\"lineNumber\">6</span>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">'Executor must be a function'</span>)\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'pending'</span>\n<span class=\"lineNumber\">9</span>  <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">10</span>  <span class=\"hljs-comment\">// 针对状态变更后需要异步调用的某些函数的规范定义，添加的数组属性</span>\n<span class=\"lineNumber\">11</span>  <span class=\"hljs-built_in\">this</span>.consumers = []\n<span class=\"lineNumber\">12</span>  executor(resolve, reject)\n<span class=\"lineNumber\">13</span> \n<span class=\"lineNumber\">14</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">resolve</span>(<span class=\"hljs-params\">value</span>) </span>{\n<span class=\"lineNumber\">15</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.1.1, 2.1.3.1</span>\n<span class=\"lineNumber\">16</span>    <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'fulfilled'</span> <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">17</span>    <span class=\"hljs-built_in\">this</span>.value = value <span class=\"hljs-comment\">// 2.1.2.2</span>\n<span class=\"lineNumber\">18</span>    <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">19</span>  }\n<span class=\"lineNumber\">20</span> \n<span class=\"lineNumber\">21</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reject</span>(<span class=\"hljs-params\">reason</span>) </span>{\n<span class=\"lineNumber\">22</span>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.state !== <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">// 2.1.1.1, 2.1.3.1</span>\n<span class=\"lineNumber\">23</span>    <span class=\"hljs-built_in\">this</span>.state = <span class=\"hljs-string\">'rejected'</span> <span class=\"hljs-comment\">// 2.1.1.1</span>\n<span class=\"lineNumber\">24</span>    <span class=\"hljs-built_in\">this</span>.value = reason <span class=\"hljs-comment\">// 2.1.3.2</span>\n<span class=\"lineNumber\">25</span>    <span class=\"hljs-built_in\">this</span>.broadcast()\n<span class=\"lineNumber\">26</span>  }\n<span class=\"lineNumber\">27</span> \n<span class=\"lineNumber\">28</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>) </span>{\n<span class=\"lineNumber\">29</span>    <span class=\"hljs-keyword\">const</span> consumer = <span class=\"hljs-keyword\">new</span> Y(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{});\n<span class=\"lineNumber\">30</span>    <span class=\"hljs-comment\">// 2.2.1.1, 2.2.1.2</span>\n<span class=\"lineNumber\">31</span>    consumer.onFulfilled = <span class=\"hljs-keyword\">typeof</span> onFulfilled === <span class=\"hljs-string\">'function'</span> ? onFulfilled : <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">32</span>    consumer.onRejected = <span class=\"hljs-keyword\">typeof</span> onRejected === <span class=\"hljs-string\">'function'</span> ? onRejected : <span class=\"hljs-literal\">undefined</span>\n<span class=\"lineNumber\">33</span>    <span class=\"hljs-built_in\">this</span>.consumers.push(consumer);\n<span class=\"lineNumber\">34</span>    <span class=\"hljs-built_in\">this</span>.broadcast();\n<span class=\"lineNumber\">35</span>    <span class=\"hljs-keyword\">return</span> consumer\n<span class=\"lineNumber\">36</span>  }\n<span class=\"lineNumber\">37</span> \n<span class=\"lineNumber\">38</span>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">broadcast</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">39</span>    <span class=\"hljs-comment\">// 2.2.5</span>\n<span class=\"lineNumber\">40</span>    <span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-built_in\">this</span>;\n<span class=\"lineNumber\">41</span>    <span class=\"hljs-comment\">// 2.2.2.1, 2.2.2.2, 2.2.3.1, 2.2.3.2</span>\n<span class=\"lineNumber\">42</span>    <span class=\"hljs-keyword\">if</span>(promise.state === <span class=\"hljs-string\">'pending'</span>) <span class=\"hljs-keyword\">return</span>;\n<span class=\"lineNumber\">43</span>    <span class=\"hljs-comment\">// 2.2.6.1, 2.2.6.2</span>\n<span class=\"lineNumber\">44</span>    <span class=\"hljs-keyword\">const</span> callbackName = promise.state === <span class=\"hljs-string\">'fulfilled'</span> ? <span class=\"hljs-string\">'onFulfilled'</span> : <span class=\"hljs-string\">'onRejected'</span>\n<span class=\"lineNumber\">45</span>    <span class=\"hljs-keyword\">const</span> resolver = promise.state === <span class=\"hljs-string\">'fulfilled'</span> ? <span class=\"hljs-string\">'resolve'</span> : <span class=\"hljs-string\">'reject'</span>\n<span class=\"lineNumber\">46</span>    <span class=\"hljs-comment\">// 2.2.4</span>\n<span class=\"lineNumber\">47</span>    <span class=\"hljs-built_in\">setTimeout</span>(\n<span class=\"lineNumber\">48</span>      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"lineNumber\">49</span>        <span class=\"hljs-comment\">// 2.2.6.1, 2.2.6.2, 2.2.2.3, 2.2.3.3</span>\n<span class=\"lineNumber\">50</span>        <span class=\"hljs-comment\">// 调用的时候遍历数组，并且清空数组</span>\n<span class=\"lineNumber\">51</span>        <span class=\"hljs-keyword\">const</span> arr = promise.consumers.splice(<span class=\"hljs-number\">0</span>)\n<span class=\"lineNumber\">52</span>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; arr.length; i++) {\n<span class=\"lineNumber\">53</span>          <span class=\"hljs-keyword\">try</span> {\n<span class=\"lineNumber\">54</span>            <span class=\"hljs-keyword\">const</span> consumer = arr[i];\n<span class=\"lineNumber\">55</span>            <span class=\"hljs-keyword\">const</span> callback = consumer[callbackName]\n<span class=\"lineNumber\">56</span>            <span class=\"hljs-comment\">// 2.2.1.1, 2.2.1.2. 2.2.5</span>\n<span class=\"lineNumber\">57</span>            <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">callback</span>)</span> {\n<span class=\"lineNumber\">58</span>              <span class=\"hljs-comment\">// 2.2.7.1 暂时直接处理</span>\n<span class=\"lineNumber\">59</span>              consumer.resolve(callback[promise.value])\n<span class=\"lineNumber\">60</span>            } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">61</span>              <span class=\"hljs-comment\">// 2.2.7.3</span>\n<span class=\"lineNumber\">62</span>              consumer[resolver](promise.value)\n<span class=\"lineNumber\">63</span>            }\n<span class=\"lineNumber\">64</span>          } <span class=\"hljs-keyword\">catch</span> (e) {\n<span class=\"lineNumber\">65</span>            <span class=\"hljs-comment\">// 2.2.7.2</span>\n<span class=\"lineNumber\">66</span>            consumer.reject(e)\n<span class=\"lineNumber\">67</span>          }\n<span class=\"lineNumber\">68</span>        }\n<span class=\"lineNumber\">69</span>      }\n<span class=\"lineNumber\">70</span>    )\n<span class=\"lineNumber\">71</span>  }\n<span class=\"lineNumber\">72</span>}</code></pre> \n\n<p>网上对于状态转换后异步调用<code>onFulfilled</code>或者<code>onRejected</code>的逻辑实现众说纷纭，在对比了多个实现方案后，笔者个人较为推荐上述代码中的方案：</p>\n<ul>\n<li>使用<code>consumers</code>数组存放<code>then</code>方法返回的<code>promise</code></li>\n<li>在<code>then</code>方法中为每个将要返回的<code>promise</code>添加<code>onFulfilled</code>和<code>onRejected</code>属性。</li>\n<li>对于某些<code>promise</code>已经转换过状态的情形，需要在<code>then</code>方法中调用一次<code>broadcast</code>方法。</li>\n</ul>\n<blockquote>\n<p><code>broadcast</code> 方法非常关键，在<code>resolve</code>、<code>reject</code>、<code>then</code>方法中都会调用一次。</p>\n</blockquote>\n<p>我们使用<code>broadcast</code>方法来做一个“广播”的功能，当<code>promise</code>状态转换之后就视情形异步调用<code>onFulfilled</code>或者<code>onRejected</code>。</p>\n<h5>The Promise Resolution Procedure</h5>\n<blockquote>\n<p>Promise Resolution procedure 表示为<code>[[Resolve]](promise, x)</code>,为什么我们需要实现此规范？</p>\n</blockquote>\n<p>当我们使用<code>resolve</code>或者<code>reject</code>方法的时候，传入的参数可以是任意有效的<code>Javascript</code>值。某些场景下，这个值可能是一个原始类型的数据，也可能是一个<code>thenables</code>对象，亦或是一个其他<code>Promise</code>实现方案创建的<code>Promise</code>实例。</p>\n<p>我们需要处理这个问题，让不同的传参都有一个确切的处理方案。</p>\n<p>对于一个<code>Promise</code>的实现来说，我们还需要添加一个<code>catch</code>方法，这个方法可以看成<code>then</code>方法的语法糖。</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span>Yi.prototype.catch = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">onRejected</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.then(<span class=\"hljs-literal\">undefined</span>, onRejected)\n<span class=\"lineNumber\">3</span>}</code></pre> \n\n","title":"实现一个Promise-A+规范的Promise类","date":"2021/5/12","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1616523197635-78aa12a1f36f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MjA3NDk4ODc&ixlib=rb-1.2.1&q=80&w=400","intro":"为了学习 Promise 的原理，加深对异步 Promise 的理解，我们很有必要学习如何实现一个符合 Promise/A+ 规范的 Promise 类"}},"__N_SSG":true}
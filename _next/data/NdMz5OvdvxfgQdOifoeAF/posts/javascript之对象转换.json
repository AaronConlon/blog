{"pageProps":{"post":{"slug":"javascript之对象转换","contentHtml":"<p>在机缘巧合之下,我看到了国外大神<code>Dr.Axel Rauschmayer</code>的博客:<a href=\"https://2ality.com/index.html\">2ality – JavaScript and more</a>,其中一篇文章针对<code>类型转换</code>这个问题作了分享,本着求知的想法我静下心阅读了此文,所得所想记录于此.</p>\n<p><strong>2021年03月22日18:52:54</strong></p>\n<h2>1. 起始</h2>\n<p><code>JavaScript</code> 是优秀的动态语言,数据类型的转换在日常编程开发中十分常见.本文将结合一些实际问题和个人疑惑对<code>类型转换</code>进行学习和解析,尽量从<code>ECMAScript规范</code>出发,学习类型转换的设计理念和实现逻辑.</p>\n<blockquote>\n<p>如果喜欢,不妨亲自阅读 <a href=\"https://tc39.es/ecma262/multipage/\">ECMAScript® 2022 Language Specification</a></p>\n</blockquote>\n<h2>2. 何为类型转换?</h2>\n<p>首先我们要明确<code>JavaScript</code>数据分为:</p>\n<ul>\n<li>原始数据类型(primitive)\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>string</li>\n<li>number</li>\n<li>biginit</li>\n<li>boolean</li>\n<li>symbol</li>\n</ul>\n</li>\n<li>对象</li>\n</ul>\n<p>看看这一行代码:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'3'</span>) * <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'2'</span>)</code></pre> \n\n<p>两个数字之间使用乘法操作符相乘,数字类型是明确的从字符串通过<code>Number()</code>函数<code>显式</code>转过来的.</p>\n<p>字符串之间<code>\"不能\"</code>直接执行乘法.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'a'</span> * <span class=\"hljs-string\">'b'</span> <span class=\"hljs-comment\">// NaN</span></code></pre> \n\n<p>也许你会举出如下可行的例子:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'1'</span> * <span class=\"hljs-string\">'2'</span> <span class=\"hljs-comment\">// 2</span></code></pre> \n\n<p>此时,字符串之间的乘法得出了我们想要的结果.究其实质是因为解释器对字符串进行了<code>隐式类型转换(coercion)</code>.</p>\n<p>JavaScript 语言初期并没有设计异常捕获(<code>exceptions</code>),这也是为什么你会看到现今解释器对如下代码的解释.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// 1</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// Infinity , 很明显, 0 作为分母是错误的,但是解释器最后的值是 Infinity</span>\n<span class=\"lineNumber\">3</span><span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-string\">'a'</span>) <span class=\"hljs-comment\">// NaN </span></code></pre> \n\n<p>为了实现兼容,<code>ECMAScript</code>不得不\"允许\"这部分错误的设计继续存在.但是,对于一些相对较新的特性来说,修复了这个错误的设计.</p>\n<p>例如:</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"lineNumber\">1</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-built_in\">Symbol</span>() <span class=\"hljs-comment\">// except error: can not cover a symbol value to a number</span>\n<span class=\"lineNumber\">2</span> \n<span class=\"lineNumber\">3</span><span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2n</span> <span class=\"hljs-comment\">// except error: can not mix BigInt and other types,use explicit conversions</span>\n<span class=\"lineNumber\">4</span> \n<span class=\"lineNumber\">5</span><span class=\"hljs-number\">1</span>() <span class=\"hljs-comment\">// except error: 1 is not a function</span>\n<span class=\"lineNumber\">6</span> \n<span class=\"lineNumber\">7</span><span class=\"hljs-keyword\">new</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// except error: 1 is not a constructor</span>\n<span class=\"lineNumber\">8</span> \n<span class=\"lineNumber\">9</span><span class=\"hljs-string\">'ab'</span>.length = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 只读属性不可改</span></code></pre> \n\n<h2>3. ECMAScript 规范是如何定义类型转换的?</h2>\n<p>先来看看如下一个使用<code>Typescript</code>编写的函数:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">multiply</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-comment\">// ...</span>\n<span class=\"lineNumber\">3</span>}</code></pre> \n\n<p>如上所示,此函数的两个参数的类型都是<code>number</code>,在转译为<code>JavaScript</code>的过程中,转译器做了什么?</p>\n<p>为了在转译后保证参数类型正确,其过程简述为如下代码:</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">multiply</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">let</span> _a = ToNumberic(a);\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-keyword\">let</span> _b = ToNumberic(b);\n<span class=\"lineNumber\">4</span>  <span class=\"hljs-comment\">/// ...</span>\n<span class=\"lineNumber\">5</span>}</code></pre> \n\n<h3>3.1 转换为原始数据类型或对象</h3>\n<p>当语句需要执行隐式转换的时候,如下<code>抽象操作</code>函数将目标数据转换为预期的原始数据类型或者<code>Object</code>:</p>\n<ul>\n<li>ToBoolean()</li>\n<li>ToNumber()</li>\n<li>ToBumeric(), 兼顾 number 和 BigInt</li>\n<li>ToBigInt()</li>\n<li>ToString()</li>\n<li>ToObject()</li>\n</ul>\n<blockquote>\n<p><a href=\"https://tc39.es/ecma262/#sec-abstract-operations\">抽象操作</a>是在ECMAScript规范中定义的函数,它们的定义是为了简洁地编写规范.JavaScript引擎不必将它们作为单独的函数在引擎中实现.不能直接从JavaScript调用它们.但是引擎实现了类似<code>Number()</code>这样的显示转换函数.</p>\n</blockquote>\n<h3>3.2 转换为数字类型</h3>\n<p>对于需要被隐式转化为<code>numeric</code>类型数据的值来说,将会用到<code>ToNumeric</code>抽象操作.转换的结果可能是<code>number</code>类型或者<code>BigInt</code>类型.</p>\n<p>如若需要将<code>x</code>转换为整形,则使用抽象操作<code>ToInteger</code>.在使用<code>位操作</code>的时候执行的隐式转换则视情形使用抽象操作<code>ToInt32</code>或者<code>ToUint32</code>.</p>\n<p>例如:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-string\">'1'</span> >> <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 使用 ToInt32 抽象方法转为 32 位整数</span>\n<span class=\"lineNumber\">2</span><span class=\"hljs-number\">2</span> >> <span class=\"hljs-string\">'1'</span> <span class=\"hljs-comment\">// 使用 ToUint32 抽象方法转为无符号 32 位整数</span>\n<span class=\"lineNumber\">3</span>-<span class=\"hljs-number\">2</span> >>> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// -2 的二进制表示属于有符号数,因此需要 ToUint32 转换,最后结果是 4294967294</span></code></pre> \n\n<p>更多细则如下表所示:</p>\n<p>| operand        | left operand | right operand | result   |\n| :------------- | :----------- | :------------ | :------- |\n| <code>&#x3C;&#x3C;</code>           | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| signed <code>>></code>    | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| unsigned <code>>>></code> | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Uint32</code> |\n| <code>&#x26;</code>, <code>^</code>, <code>|</code>  | <code>ToInt32()</code>  | <code>ToUint32()</code>  | <code>Int32</code>  |\n| <code>~</code>            | —            | <code>ToInt32()</code>   | <code>Int32</code>  |</p>\n<h3>3.3 转换为属性<code>keys</code>属性</h3>\n<p>抽象操作<code>ToPropertyKey</code>返回一个字符串或者<code>Symbol</code>,常用于:</p>\n<ul>\n<li>括号操作</li>\n<li>对象字面量的计算属性</li>\n<li>in 操作符的<code>left-hand side</code>,用于判定<code>in</code> 的结果</li>\n<li>Object 的几个需要访问<code>value</code>和遍历<code>key</code>相关的函数\n<ul>\n<li>Object.fromEntries</li>\n<li>Object.defineProperty</li>\n<li>Object.getOwnPropertyDescriptor</li>\n<li>Object.prototype.hasOwnProperty</li>\n<li>Object.prototype.propertyIsEnumerable</li>\n</ul>\n</li>\n<li>Reflect 对象的相关方法</li>\n</ul>\n<h3>3.4 转换为数组索引(Array indices)</h3>\n<ul>\n<li><code>ToLength()</code> 主要用于字符串索引计算\n<ul>\n<li>此抽象方法是<code>ToIndex</code>抽象方法的辅助方法</li>\n<li>其值范围是0 ≤ ? ≤ Math.MAX_SAVE_INTEGER</li>\n</ul>\n</li>\n<li><code>ToIndex()</code> 主要用于类数组索引计算\n<ul>\n<li>与 ToLength 主要区别在于,此抽象方法在索引越界的时候抛出异常</li>\n<li>其值范围是0 ≤ ? ≤ Math.MAX_SAVE_INTEGER</li>\n</ul>\n</li>\n<li><code>ToUint32()</code> 用于数组索引计算\n<ul>\n<li>其值范围是0 ≤ ? &#x3C; 2^32-1</li>\n</ul>\n</li>\n</ul>\n<h3>3.5 转换为类数组对象的元素</h3>\n<p>如果你要为<code>类数组</code>对象的某个元素设置值,将可能使用如下的抽象方法:</p>\n<ul>\n<li><code>ToInt8()</code></li>\n<li><code>ToUint8()</code></li>\n<li><code>ToUint8Clamp()</code></li>\n<li><code>ToInt16()</code></li>\n<li><code>ToUint16()</code></li>\n<li><code>ToInt32()</code></li>\n<li><code>ToUint32()</code></li>\n<li><code>ToBigInt64()</code></li>\n<li><code>ToBigUint64()</code></li>\n</ul>\n<p>例如:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-keyword\">let</span> uint16 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>;\n<span class=\"lineNumber\">2</span>uint16 = <span class=\"hljs-built_in\">Int16Array</span>.from(<span class=\"hljs-string\">'12345'</span>);\n<span class=\"lineNumber\">3</span> \n<span class=\"lineNumber\">4</span><span class=\"hljs-built_in\">console</span>.log(uint16);\n<span class=\"lineNumber\">5</span><span class=\"hljs-comment\">// expected output: Int16Array [1, 2, 3, 4, 5]</span></code></pre> \n\n<p>此处的字符串<code>12345</code>在 <code>from</code>函数内部进行迭代,并且进行隐式的类型转换,最终为<code>Int16Array</code>对象设置了 5 个元素值.</p>\n<h2>4. ECMAScript 规范示例解读</h2>\n<p><code>ECMAScript</code>规范明确提供了<code>JavaScript</code>的所有实现算法详细设计.大多数的<code>抽象方法</code>并没有在<code>JavaScript </code>引擎中实现,但是依然有少数抽象方法可以近乎理解为<code>JavaScript</code>引擎中对应的部分函数实现.举个例子,如下内容是<code>ECMAScript</code>规范的一部分:</p>\n<p><strong>The <code>typeof</code> Operator</strong></p>\n<ol>\n<li>\n<p>Let val be the result of evaluating <a href=\"https://tc39.es/ecma262/#prod-UnaryExpression\">UnaryExpression</a>. 让 val 作为评估此一元表达式的结果.</p>\n</li>\n<li>\n<p>If val is a <a href=\"https://tc39.es/ecma262/#sec-reference-record-specification-type\">Reference Record</a>, then</p>\n<p>a. If <a href=\"https://tc39.es/ecma262/#sec-isunresolvablereference\">IsUnresolvableReference</a>(val) is true, return \"undefined\". 如果这个值是一个引用记录(仅存于规范中的类型),并且是一个不可解析的引用(比如声明却未初始化的变量),则返回 <code>undefined</code>.</p>\n</li>\n<li>\n<p>Set val to ? <a href=\"https://tc39.es/ecma262/#sec-getvalue\">GetValue</a>(val). 令 val 等于 GetValue(val) 抽象操作的结果.如有异常则抛出.</p>\n</li>\n<li>\n<p>Return a String according to <a href=\"https://tc39.es/ecma262/#table-typeof-operator-results\">Table 38</a>. 按<code>val</code>的类型选择下表中一个字符串结果.</p>\n</li>\n</ol>\n<h5 style=\"text-align:center\">Table 38: typeof Operator Results</h5>\n<p>| Type of val                                                  | Result      |\n| ------------------------------------------------------------ | ----------- |\n| Undefined                                                    | \"undefined\" |\n| Null                                                         | \"object\"    |\n| Boolean                                                      | \"boolean\"   |\n| Number                                                       | \"number\"    |\n| String                                                       | \"string\"    |\n| Symbol                                                       | \"symbol\"    |\n| BigInt                                                       | \"bigint\"    |\n| Object (does not implement [[Call]]) <code>不可调用的对象返回 object</code> | \"object\"    |\n| Object (implements [[Call]])                                 | \"function\"  |</p>\n<blockquote>\n<p>ECMAScript 规范中为了方便描述算法和设计逻辑,设定了很多抽象操作和规范中的类型,定义了许多简写方式,类似: ? 和 ! 等.</p>\n</blockquote>\n<h2>5. 隐式转换抽象方法示例</h2>\n<h3>5.1 ToPrimitive()</h3>\n<p>这个抽象方法在许多隐式转换算法中被使用到,它可以把任意值转换为原始类型值.由于许多操作只接受原始类型数据(或最终将使用原始类型数据),此抽象方法在<code>ECMAScript</code>规范中被广泛调用.</p>\n<p>接下来我们来看看一个 JavaScript 版本的 <code>ToPrimitive</code>函数.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ToPrimitive</span>(<span class=\"hljs-params\">input: any, hint: <span class=\"hljs-string\">'default'</span> | <span class=\"hljs-string\">'string'</span> | <span class=\"hljs-string\">'number'</span> = <span class=\"hljs-string\">'default'</span></span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">if</span> (Typeof(input) === <span class=\"hljs-string\">'object'</span>) {\n<span class=\"lineNumber\">3</span>    <span class=\"hljs-keyword\">let</span> exoticToPrim = input[<span class=\"hljs-built_in\">Symbol</span>.toPrimitive];\n<span class=\"lineNumber\">4</span>    <span class=\"hljs-keyword\">if</span> (exoticToPrim !== <span class=\"hljs-literal\">undefined</span>) {\n<span class=\"lineNumber\">5</span>      <span class=\"hljs-keyword\">let</span> result = exoticToPrim.call(input, hint);\n<span class=\"lineNumber\">6</span>      <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-params\">Typeof(result) !== <span class=\"hljs-string\">'object'</span></span>)</span> {\n<span class=\"lineNumber\">7</span>        <span class=\"hljs-keyword\">return</span> result;\n<span class=\"lineNumber\">8</span>      }\n<span class=\"lineNumber\">9</span>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>();\n<span class=\"lineNumber\">10</span>    }\n<span class=\"lineNumber\">11</span>    <span class=\"hljs-keyword\">if</span> (hint === <span class=\"hljs-string\">'default'</span>) {\n<span class=\"lineNumber\">12</span>      hint = <span class=\"hljs-string\">'number'</span>\n<span class=\"lineNumber\">13</span>    }\n<span class=\"lineNumber\">14</span>    <span class=\"hljs-keyword\">return</span> OrdinaryToPrimitive(input, hint);\n<span class=\"lineNumber\">15</span>  } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">16</span>    <span class=\"hljs-comment\">// input 是原始数据类型</span>\n<span class=\"lineNumber\">17</span>    <span class=\"hljs-keyword\">return</span> input\n<span class=\"lineNumber\">18</span>  }\n<span class=\"lineNumber\">19</span>}</code></pre> \n\n<p>要理解这个函数,需要了解一些前置知识.</p>\n<p>首先, <code>hint</code>参数表示要转换到原始值的预期类型,默认是<code>number</code>.</p>\n<p>.其次,此函数的目的是为了将某个值转为原始类型数据,如此一来对于本身就是原始类型的数据来说直接返回即可.</p>\n<p>对于对象来说,则需要检查此对象是否重写了<code>Symbol.toPrimitive</code>方法.</p>\n<blockquote>\n<p><code>Symbol.toPrimitive</code> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p>\n</blockquote>\n<p>如果目标对象重写了方法,则将<code>hint</code>和<code>input</code>作为参数按重写的逻辑进行转换,出现异常则抛出.</p>\n<p>如果此对象没有<code>Symbol.toPrimitive</code>函数,则按常规抽象方法<a href=\"https://tc39.es/ecma262/#sec-ordinarytoprimitive\">OrdinaryToPrimitive</a>进行转换.</p>\n<p>接下来看看 <code>OrdinaryToPrimitive</code>的 JavaScript 函数可以如何实现.</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">OrdinaryToPrimitive</span>(<span class=\"hljs-params\">O: object, hint: <span class=\"hljs-string\">'string'</span> | <span class=\"hljs-string\">'number'</span></span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-keyword\">let</span> methodNames;\n<span class=\"lineNumber\">3</span>  <span class=\"hljs-keyword\">if</span> (hint === <span class=\"hljs-string\">'string'</span>) {\n<span class=\"lineNumber\">4</span>    methodNames = [<span class=\"hljs-string\">'toString'</span>, <span class=\"hljs-string\">'valueOf'</span>];\n<span class=\"lineNumber\">5</span>  } <span class=\"hljs-keyword\">else</span> {\n<span class=\"lineNumber\">6</span>    methodNames = [<span class=\"hljs-string\">'valueOf'</span>, <span class=\"hljs-string\">'toString'</span>];\n<span class=\"lineNumber\">7</span>  }\n<span class=\"lineNumber\">8</span>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> name <span class=\"hljs-keyword\">of</span> methodNames) {\n<span class=\"lineNumber\">9</span>    <span class=\"hljs-keyword\">let</span> method = O[name];\n<span class=\"lineNumber\">10</span>    <span class=\"hljs-keyword\">if</span> (IsCallable(method)) {\n<span class=\"lineNumber\">11</span>      <span class=\"hljs-keyword\">let</span> result = method.call(O);\n<span class=\"lineNumber\">12</span>      <span class=\"hljs-keyword\">if</span> (TypeOf(result) !== <span class=\"hljs-string\">'object'</span>) {\n<span class=\"lineNumber\">13</span>        <span class=\"hljs-keyword\">return</span> result;\n<span class=\"lineNumber\">14</span>      }\n<span class=\"lineNumber\">15</span>    }\n<span class=\"lineNumber\">16</span>  }\n<span class=\"lineNumber\">17</span>  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>();\n<span class=\"lineNumber\">18</span>}</code></pre> \n\n<h2>references</h2>\n<ul>\n<li><a href=\"https://2ality.com/2019/10/type-coercion.html\">Type coercion in JavaScript</a></li>\n<li><a href=\"https://timothygu.me/es-howto/\">How to Read the ECMAScript Specification</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019240609\">怎样阅读 ECMAScript 规范？ - SegmentFault 思否</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/11/ecmascript-specification.html\">读懂 ECMAScript 规格 - 阮一峰的网络日志</a></li>\n</ul>\n","title":"javascript语言中的类型转换","date":"2021/3/22","tags":["javascript","tc39"],"mainImg":"https://images.unsplash.com/photo-1472437774355-71ab6752b434?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTY0MTAxMzQ&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1472437774355-71ab6752b434?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTY0MTAxMzQ&ixlib=rb-1.2.1&q=80&w=400","intro":"你好,TC39.请问 JavaScript 世界中的对象转换是如何实现的呢?"}},"__N_SSG":true}
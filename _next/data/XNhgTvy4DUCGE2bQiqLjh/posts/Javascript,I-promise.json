{"pageProps":{"post":{"slug":"Javascript,I-promise","contentHtml":"<p>虽然此前我已经接触过一些异步编程的概念,并且有过一定的实际运用.但是自我感觉,我对<code>JavaScript</code>异步编程的了解依然十分浅显,因此我打算再次对<code>JavaScript</code>中的异步编程进行学习和总结,然后分享出来.</p>\n<h1>1. 前文</h1>\n<p>在对<code>Promise</code>知识进行总结之前,我将回顾一部分<code>JavaScript</code>与异步编程相关的知识.</p>\n<h2>1.1 浅述 JavaScript 调用栈</h2>\n<p>当函数之间发生内嵌调用,将产生<code>函数调用栈</code>.</p>\n<blockquote>\n<p><code>函数调用栈</code>是解释器追踪函数执行流的一种机制,函数入栈的同事也保存了其上下文环境.</p>\n</blockquote>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">h</span>(<span class=\"hljs-params\">z</span>) </span>{\n<span class=\"lineNumber\">2</span>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>().stack)\n<span class=\"lineNumber\">3</span>}\n<span class=\"lineNumber\">4</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">g</span>(<span class=\"hljs-params\">y</span>) </span>{\n<span class=\"lineNumber\">5</span>  h(y + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">6</span>}\n<span class=\"lineNumber\">7</span><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">x</span>) </span>{\n<span class=\"lineNumber\">8</span>  g(x + <span class=\"hljs-number\">1</span>)\n<span class=\"lineNumber\">9</span>}\n<span class=\"lineNumber\">10</span>f(<span class=\"hljs-number\">1</span>)</code></pre> \n\n<p>如上述,随着调用函数<code>f(1)</code>,调用栈内开始存储函数<code>f(1)</code>,内部调用了<code>g(2)</code>也被存入调用栈,最后将<code>h(3)</code>存入调用栈,当前函数执行结束即将之从调用栈定移除,接着执行可能存在的剩余代码,最终调用栈被清空,执行流程回到全局作用域,最终打印如下:</p>\n<pre><code class=\"hljs language-js\"><span class=\"lineNumber\">1</span><span class=\"hljs-built_in\">Error</span>\n<span class=\"lineNumber\">2</span>    at h (REPL3:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">3</span>    at g (REPL6:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">4</span>    at f (REPL9:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">3</span>)\n<span class=\"lineNumber\">5</span>    at REPL10:<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">1</span>\n<span class=\"lineNumber\">6</span>    at Script.runInThisContext (node:vm:<span class=\"hljs-number\">133</span>:<span class=\"hljs-number\">18</span>)\n<span class=\"lineNumber\">7</span>    at REPLServer.defaultEval (node:repl:<span class=\"hljs-number\">474</span>:<span class=\"hljs-number\">29</span>)\n<span class=\"lineNumber\">8</span>    at bound (node:domain:<span class=\"hljs-number\">416</span>:<span class=\"hljs-number\">15</span>)\n<span class=\"lineNumber\">9</span>    at REPLServer.runBound [<span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">eval</span>] (node:domain:<span class=\"hljs-number\">427</span>:<span class=\"hljs-number\">12</span>)\n<span class=\"lineNumber\">10</span>    at REPLServer.onLine (node:repl:<span class=\"hljs-number\">793</span>:<span class=\"hljs-number\">10</span>)\n<span class=\"lineNumber\">11</span>    at REPLServer.emit (node:events:<span class=\"hljs-number\">388</span>:<span class=\"hljs-number\">22</span>)</code></pre> \n\n<p>栈是有限度的,不同环境的栈空间大小不等,分配的栈空间被占满之后,将会引发栈溢出错误.</p>\n<h2>1.2 浅述浏览器事件循环</h2>\n<p>我们可以简单的认为每个浏览器<code>tab</code>运行于一个简单的<code>事件循环</code>进程来实现<code>非阻塞</code>,浏览器中的诸多单一任务,例如:</p>\n<ul>\n<li>解析 HTML</li>\n<li>执行脚本中的 JavaScript 代码</li>\n<li>响应用户交互</li>\n<li>异步网络请求</li>\n<li>等等</li>\n</ul>\n<p>这些任务形成了独立于主线程的<code>任务队列</code>,所有任务只能逐一通知主线程进行处理.由于<code>JavaScript</code>的单线程限制,即使<code>Web Worker标准</code>允许<code>JavaScript</code>脚本创建多个线程,但是子线程由主线程控制,且不可操作<code>DOM</code>,可以说<code>JavaScript</code>的本质依然是<code>单线程</code>.</p>\n<p>如下是从阮老师博客摘取的示意图:</p>\n<p><img src=\"https://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png\" alt=\"\"></p>\n<p>任务队列中的任务是什么时候被主线程执行的呢?</p>\n<h1>参考</h1>\n<ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a></li>\n</ul>\n","title":"Javascript,I promise - 异步编程","date":"2021/4/9","tags":["JavaScript"],"mainImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1611923973164-e0e5f7f69872?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MTc5NzU1MTI&ixlib=rb-1.2.1&q=80&w=400","intro":"Promise, JavaScript 世界中的异步处理对象.我阅读了 Dr.Axel 前辈的电子书,充满感激."}},"__N_SSG":true}
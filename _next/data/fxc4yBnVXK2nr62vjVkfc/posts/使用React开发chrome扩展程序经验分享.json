{"pageProps":{"post":{"slug":"使用React开发chrome扩展程序经验分享","content":"\n### 前言\n\n我每天都在用浏览器，不知道哪一天起想要写一个自己的新标签页扩展。\n\n在那之后，我去看了 `chrome` 的文档，去看了 `github` 上一些开发示例，一步步去学习如何写扩展。\n\n经过一段时间的反复修改、重构（重写）、删减，终于提交了第一版本的源代码。\n\n> 源代码：[youyiqin/lan](https://github.com/youyiqin/lan/tree/main)\n\n### 起步\n\n#### Vite\n\n第一步：配置开发环境。\n\n网上有很多 `chrome` 开发的脚手架和模板，我们可以选择适合自己的去作为整个扩展的基础部分。\n\n但我决定从零开始，逐步搭建整个应用。\n\n整体技术栈如下：\n\n- `Vite` 快速打包构建\n- `React` 创建页面和功能\n- `ESLint`、`Prettier` 提供规范+格式化代码\n- `nvm` Node 版本控制\n- `Git` 代码版本控制\n- `TypeScript` 更好的类型系统支持\n\n上述内容不一一介绍，只是提及一些关键的点。\n\n说穿了，我们还是开发 `chrome` 的扩展。因此，不能用以往的思路去配置 `package.json` 的 `scripts` 命令。\n\n核心在于，我们要用 `Vite` + `React` 互相配合，将代码打包好。\n\n于是，我单独增加了一条构建命令`build:dev`，实例如下：\n\n```json\n{\n  \"name\": \"lan\",\n  \"version\": \"0.0.0\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build:dev\": \"export DEV=dev && tsc && vite build\",\n    \"build\": \"tsc && vite build && uglifyjs dist/bg.js -o dist/bg.js && uglifyjs dist/once.js -o dist/once.js\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  },\n  \"devDependencies\": {\n    \"@types/chrome\": \"^0.0.176\",\n    \"@types/lodash\": \"^4.14.178\",\n    \"@types/react\": \"^17.0.33\",\n    \"@types/react-dom\": \"^17.0.10\",\n    \"@vitejs/plugin-react\": \"^1.0.7\",\n    \"eslint\": \"^8.6.0\",\n    \"eslint-config-prettier\": \"^8.3.0\",\n    \"eslint-plugin-react\": \"^7.28.0\",\n    \"fast-glob\": \"^3.2.10\",\n    \"lodash\": \"^4.17.21\",\n    \"prettier\": \"^2.5.1\",\n    \"react-icons\": \"^4.3.1\",\n    \"sass\": \"^1.48.0\",\n    \"stylelint-config-prettier\": \"^9.0.3\",\n    \"stylelint-config-sass-guidelines\": \"^9.0.1\",\n    \"stylelint-prettier\": \"^2.0.0\",\n    \"typescript\": \"^4.4.4\",\n    \"uglify-js\": \"^3.15.0\",\n    \"vite\": \"^2.7.2\"\n  }\n}\n```\n\n`\"build:dev\": \"export DEV=dev && tsc && vite build\"`: 设置一个环境变量，开发内用于调试，然后通过 tsc 编译 TypeScript 代码，再通过 vite 去构建。\n\n在正式构建的时候，提前使用`uglifyjs`去压缩混淆两个单独的`js`文件，其他的`tsx/ts`文件由`vite`处理即可。\n\n同时，还修改了`vite.config.ts`配置文件如下:\n\n```typescript\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport fg from \"fast-glob\";\nconst isDev = process.env.DEV === \"dev\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    {\n      name: \"watch-external\", // https://stackoverflow.com/questions/63373804/rollup-watch-include-directory/63548394#63548394\n      async buildStart() {\n        const files = await fg([\"public/**/*\"]);\n        for (let file of files) {\n          this.addWatchFile(file);\n        }\n      },\n    },\n  ],\n  build: isDev\n    ? {\n        outDir: \"lan_crx\",\n        watch: {},\n        sourcemap: true,\n      }\n    : {},\n});\n\n```\n\n针对开发环境，修改了构建的目录并且增加了 `sourcemap` 功能便于调试和阅读浏览器加载的代码。\n\n其中关键在于`watch`键，这让我们能够在更新了源代码的时候让 `vite` 去重新`build`整个应用。\n\n> 笔者对热更新和 `chrome`如何配合使用依然没有头绪，如果您有所了解，非常欢迎告知👏🏻\n\n构建后的代码依然被浏览器所访问到，我们暂时只能手动刷新浏览器页面去查看效果。\n\n上述配置中，单独增加了一个`watch-external`插件去监听文件变动，这部分`public`目录内的资源和配置文件是不需要 `vite` 处理的，我们只需要在更新的时候`copy`过去即可。\n\n#### Chrome 辅助\n\n在开发中回用到 `chrome`的很多`API`，这一块需要我们在`tsconfig.json`中的编译选项中增加:\n\n`types`类型支持。我的配置文件如下：\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ESNext\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"],\n    \"allowJs\": false,\n    \"skipLibCheck\": false,\n    \"esModuleInterop\": false,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"Node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n    \"types\": [\"vite/client\", \"chrome\"]\n  },\n  \"include\": [\"./src\"]\n}\n```\n\n如上所示，单独增加了`chrome`的类型。此时，编辑器中就会为代码进行提示了，方便我们使用浏览器的接口。\n\n> 如果不使用 TypeScript 开发，则使用 `jsconfig.json`进行配置\n\n#### 代码质量\n\n关于代码质量和规范的问题，笔者会另开一个文章单独来讲，这里暂时🕊了。\n\n### 核心\n\n开发环境配置好之后，我们就可以开始设计和编写整个应用了。\n\n在一切开始之前，首先最应该做的事情就是明确所有的功能。\n\n绝不能走一步算一步！\n\n![](http://image.biaobaiju.com/uploads/20190624/12/1561351364-QyDkwGOYbE.jpg)\n\n话说回来，我的扩展是一个简单的新标签页替代品。`chrome` 默认的标签页不符合我的需求，我得让新标签页更简单，仅仅支持以下几个功能：\n\n- 极简风！删除一切花里胡哨。\n- 支持超高清壁纸（我真的太爱壁纸）\n- 支持下载壁纸\n- 🍅番茄钟 简单的自定义倒计时\n- 搜索框！通过输入字母组合切换搜索引擎，暂时支持以下几种\n  - 谷歌\n  - 必应\n  - YouTube\n  - github\n  - 知乎\n- 设置\n  - 图标大小\n  - 搜索框新页面打开方式\n  - 番茄钟倒计时时间\n  - 搜索框使用简介\n\n确认了需求，就可以一个一个地实现了。\n\n这里歪楼去谈谈`manifest.json`这个扩展核心配置文件：\n\n```json\n{\n  \"name\": \"岚\",\n  \"description\": \"极简的新标签页插件，献给喜欢壁纸和极简风格的你。\",\n  \"version\": \"1.0\",\n  \"manifest_version\": 3,\n  \"permissions\": [\"storage\", \"downloads\", \"unlimitedStorage\"],\n  \"icons\": {\n    \"16\": \"icons/16.png\",\n    \"32\": \"icons/32.png\",\n    \"64\": \"icons/64.png\",\n    \"128\": \"icons/128.png\"\n  },\n  \"chrome_url_overrides\": {\n    \"newtab\": \"index.html\"\n  },\n  \"background\": {\n    \"service_worker\": \"bg.js\"\n  }\n}\n```\n\n其中三个权限分别对应着某些功能，尤其是最后一个无限制的`storage`存储空间，这是因为默认的`storage`不足以保存超高清的图片`base64`字符串，因此必须申请更多空间。\n\n此外，核心代码中有一个点需要注意，来看看`main.tsx`文件：\n\n```tsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport { getObjFromStorage } from \"./utils/index\";\nimport \"./style/global.sass\";\nimport { iconSize } from \"./types/index\";\n\nconst promiseArr = [\n  getObjFromStorage(\"wallpaper\"),\n  getObjFromStorage(\"icon_size\"),\n  getObjFromStorage(\"tomato_seconds\"),\n  getObjFromStorage(\"open_type\"),\n];\nPromise.all(promiseArr).then((props: any[]) => {\n  const [wallpaper, icon_size, tomato_seconds, open_type] = props;\n\n  ReactDOM.render(\n    <React.StrictMode>\n      <App\n        wallpaper={wallpaper.wallpaper}\n        icon_size={icon_size.icon_size as iconSize}\n        tomatoSeconds={tomato_seconds.tomato_seconds}\n        openType={open_type.open_type}\n      />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n  );\n});\n```\n\n整个应用的初始配置都是写在`storage`中的，因此需要用异步的方法获取到配置再渲染到页面中。\n\n> 上述代码中使用单独一条条的配置去保存数据看起来非常“low”，请原谅😂，这是笔者第一个 chrome 扩展~\n\n然后，倒杯茶。\n\n开始 coding 吧。\n\n### 最重要\n\n啥是最重要的？在我写完之后，我才知道最重要的是让人用我的扩展。\n\n这部分比开发更难。\n\n### 其他\n\n笔者也是在学习中尝试编写扩展，由于时间关系功能相对简陋。前期甚至加上了很多其他功能，并且来回反复修改，最后发现并没有什么必要将这些功能集成到这个扩展中来。\n\n很多东西都是在尝试，接下来有很多新的东西可以忙活了。\n\n如果你想体验一下我的扩展，👏🏻欢迎联系我。\n","title":"使用React开发chrome扩展程序经验分享","date":"2022/2/7","tags":["React","Chrome 扩展"],"mainImg":"https://images.unsplash.com/photo-1607970669494-309137683be5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDQyMTU0MDQ&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1607970669494-309137683be5?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NDQyMTU0MDQ&ixlib=rb-1.2.1&q=80&w=400","intro":"献给我开发的第一个完整的 chrome 扩展：岚"}},"__N_SSG":true}
{"pageProps":{"post":{"slug":"Powershell随写","content":"\n## chapter1：getting started with powershell\n\n### 1.1 允许在你的机器上运行脚本\n\n ```powershell\n# 以管理员身份运行,这条命令将修改注册表,注册表中保存了powershell很多默认配置项\nSet-ExecutionPolicy RemoteSigned\n ```\n\n将powershell的运行策略修改为运行未签名的脚本运行.或者通过管理员权限打开一个终端,执行脚本的时候指明使用`bypass`策略.\n\n```powershell\npowershell.exe -ExecutionPolicy Bypass -File \"c:\\MyScript.ps1\"\n# 或者在此控制台先执行\nSet-ExecutionPolicy Bypass Process\n```\n\n### 1.2 alias和简单函数\n\n举个例子,`write-output`和`write-host`都能接受字符并且输出到屏幕,但是`write-output`还能返回输出的值作为结果,这在变量引用和管道传递方面很有用.简单函数不同但是结果相同,这在powershell中非常常见.\n\n同一个命令,可以有不同的别名,例如`write-output`的`alias`有`echo`和`write`.甚至,可以直接用单引号或者双引号括起来直接输出:\n\n```powershell\n\"hello world\"\n'hello world'\n\n# alias即别名,一条命令可以有不同的别名,就像人可以有不同的外号,如下举例\nls\ndir\n# 都是get-childitem的alias\n```\n\n这些是系统自带的alias,我们可以自己增加,例如:\n\n```powershell\nset-alias -Name ping -value test-netconnection\n\n# 如下所示\n➜  Markdown笔记 Test-NetConnection www.baidu.com\nComputerName           : www.baidu.com\nRemoteAddress          : 14.215.177.39\nInterfaceAlias         : WLAN\nSourceAddress          : 192.168.124.11\nPingSucceeded          : True\nPingReplyDetails (RTT) : 8 ms\n\n➜  Markdown笔记 Set-Alias ping Test-NetConnection\n\n➜  Markdown笔记 ping www.baidu.com\nComputerName           : www.baidu.com\nRemoteAddress          : 14.215.177.39\nInterfaceAlias         : WLAN\nSourceAddress          : 192.168.124.11\nPingSucceeded          : True\n```\n\n但是,不同的终端属于不同的`session`,你可以在当前终端设置`alias`,此时其他终端并不会生效.并且,本终端设置的`alias`会重写默认存在的命令,如上所述,我重写了`ping`命令.本来`ping`命令是这样的:\n\n```powershell\n➜  ~ ping www.baidu.com\n\n正在 Ping www.a.shifen.com [14.215.177.39] 具有 32 字节的数据:\n来自 14.215.177.39 的回复: 字节=32 时间=8ms TTL=55\n来自 14.215.177.39 的回复: 字节=32 时间=8ms TTL=55\n来自 14.215.177.39 的回复: 字节=32 时间=9ms TTL=55\n来自 14.215.177.39 的回复: 字节=32 时间=8ms TTL=55\n\n14.215.177.39 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 8ms，最长 = 9ms，平均 = 8ms\n```\n\n### 1.3 管道\n\n管道符`|`放在一条命令的末尾,可以将命令的返回值传递到下一个命令上去,并且作为下一条命令的`最后一个参数`使用.\n\n```powershell\nGet-ChildItem | Select-Object Name\n#This may be shortened to:\ngci | Select Name\n\n# gci就是命令的alias\n\nGet-ChildItem | ForEach-Object {\n Copy-Item -Path $_.FullName -destination C:\\NewDirectory\\\n}\n#This may be shortened to:\ngci | % { Copy $_.FullName C:\\NewDirectory\\ }\n```\n\n\n\n### 1.4 使用`.net`库的方法\n\npowershell天生支持`.net`的各种方法.毕竟是微软一家子的成员.例如:\n\n```powershell\n#calling Path.GetFileName()\nC:\\> [System.IO.Path]::GetFileName('C:\\Windows\\explorer.exe')\nexplorer.exe\n```\n\n如果你熟悉`.net` 的话,使用它的库函数就能如虎添翼事半功倍.\n\n使用静态方法可以很直接,但是如果有些方法不是静态方法,则需要对`class`进行实例化.举例:\n\n```powershell\n➜  Markdown笔记 $object = [System.DateTime]::now\n➜  Markdown笔记 $object.AddHours(1)\n2020年8月3日 3:00:07\n```\n\n直接就输出一个修改过的时间结果.\n\n### 1.5 安装或者设置\n\n现在默认windows7以上自带`powershell`,但是在其他平台,则需要手动安装,例如支持在Ubuntu上安装`powershell v6`.\n\npowershell脚本的注释使用`#`.或者长注释使用`<# comment #>`内部添加注释,支持换行.\n\n### 1.6 简述创建对象\n\npowershell以管道传递对象,对象在powershell中具有独特的地位.举个例子.\n\n```powershell\n# 创建一个时间对象\n$var = new-object system-datetime\n# 创建一个流对象\n$sr = new-object system.io.streamreader -argumentList \"file stream\"\n\n# 创建一个复杂对象\n$newObj = [PScustomObject]@{\n\tComputerName = 'server1',\n\tEnv = 'Production'\n}\n\n# 创建一个ie浏览器对象\n$IE1 = New-Object -COMObject InternetExplorer.Application -Property @{Navigate2=\"www.microsoft.com\"; Visible = $True}\n\n# The following command gets the same results as the example above.\n$IE2 = New-Object -COMObject InternetExplorer.Application`\n$IE2.Navigate2(\"www.microsoft.com\")`\n$IE2.Visible = $True`\n```\n\n上述可以看出创建对象的时候可以设置一些属性,或者创建基础实例之后再设置属性.所有的对象都可以通过管道进行传输.对象的集合在导入和导出特定的格式,例如csv或者xml的时候非常有效,例如命令`export-csv`的每一行都是一个对象.\n\n## chapter2: variable in powershell\n\n> 变量用于保存数据,以便于后续使用.\n\n### 2.1 简单变量和数组\n\n```powershell\n$name = \"root\"\n$numArray = 1,2,3,4\n$newArray = 1,\"2\" # 不限类型,比较灵活\n$numArray = $numArray +5\n$newArray = $newAarray + $numArray\n```\n\n### 2.2 拆分变量为数组\n\n```powershell\n$input=\"foo.bar.baz\"\n$parts=$input.Split(\".\")\n$foo=$parts[0]\n$bar=$parts[1]\n$baz=$parts[2]\n#You can simply do this:\n$foo,$bar,$baz=$input.Split(\".\")\n```\n\n灵活处理字符串和数组.类似`js`,也可以根据变量的数量去分配.\n\n```powershell\n$foo, $_ = $input.Split(\".\")\n# foo则保存首个拆分的值,_保存剩下的数组.\n```\n\n### 2.3 Scope\n\n作用域范围跟分为局部和全局,函数内部只在内部有效,支持闭包.如果你想要指定外部的变量,以便于和函数内部同名变量区分.则可以使用如下方式:\n\n`$local:foo` 和 `$global:foo`,如果存在多层嵌套,则`global`为最外层.\n\n### 2.4 移除变量\n\n```powershell\n# 需要指定类型为 Variable,再指定变量名\nRemove-Item Variable:\\foo\n```\n\n变量支持像处理文件系统项目的大多数的`*-item`命令进行处理.\n\n更显式的删除变量,可以使用`remove-variable`命令.其简写是`rv`.命令如`rv foo`\n\n## chapter 3: Operators\n\n### 3.1 比较运算符\n\n类似`bash`,使用如下方式进行比较,返回`true`或者`false`的`boolean`值.\n\n```powershell\n2 -eq 2\n2 -ne 2\n2 -lt 2\n2 -gt 2\n2 -ge 2\n2 -le 2\n# 针对大小写是否敏感\na -eqi A # true,字符串不敏感,eqc则敏感\n\n# 字符串比较\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:39:32]\n➜ \"string\" -like \"*ing\"\nTrue\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:40:00]\n➜ \"string\" -like \"ing\"\nFalse\n\n# 加not取反\n➜ \"string\" -notlike \"ing\"\nTrue\n\n# 支持正则表达式\n➜ \"string\" -match \"ing\"\nTrue\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:41:15]\n➜ \"string\" -match \"inge\"\nFalse\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:41:22]\n➜ \"string\" -match \"ing&\"\nFalse\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:41:33]\n➜ \"string\" -match \"ing$\"\nTrue\n\n# 集合数据比较\n\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:41:37]\n➜ \"12\",\"abc\" -contains \"1\"\nFalse\n# root at LAPTOP-G92L1V81 in D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts on git:master ≣ +0 ~1 -0 ! [1:44:14]\n➜ \"12\",\"abc\" -contains \"12\"\nTrue\n\n➜ \"12\" -in \"aaa\",\"12\"\nTrue\n```\n\n### 3.2 算数运算\n\n```powershell\n1+2\t# Addition\n1-2\t# Subtraction\n-1\t# Set negative value\n1*2\t# Multiplication\n1/2\t# Division\n1%2\t# Modulus\n100 -shl 2 # 按位左移\n100 -shr 2 # 按位右移\n\n# 变量计算\n$var = 1\n$var += 2\n$var++\n$var += \"2\" # 也支持,自动类型转换\n```\n\n### 3.3 输出重定向操作\n\n> 大神详解:[Understanding Streams, Redirection, and Write-Host in PowerShell | Scripting Blog](https://devblogs.microsoft.com/scripting/understanding-streams-redirection-and-write-host-in-powershell/)\n\n执行命令或者程序,将产生不同类型的输出信息流.\n\n![](https://devblogs.microsoft.com/wp-content/uploads/sites/29/2019/02/2570.1.png)\n\n顺利执行将产生success的输出流,举个例子:\n\n```powershell\ncmdlet > file # 发送success输出流重写file的内容\ncmdlet >> file # 追加success输出流到file的文件末尾\ncmdlet 1>&2 # 1代表success状态的输出流,此时指的是将success(1)和error(2)的输出重定向到error流中去\n\ncmdlet 2> file # error(2) 输出流\ncmdlet 3> file # powershell v3+支持的warning数据流\ncmdlet 4> file # powershell v3+支持的verbose输出流,详细消息流通常用于提供命令处理的相关信息,便于调试\ncmdlet 5> file # Debug\ncmdlet 6> file # information level\n```\n\n不同的流是平行的,在管道之间传递对象,我们并不希望接受cmdlet各种类型的流式数据.且管道符默认接收了`success`级别的信息.其他的流的数据发往了其他的接收处.\n\n> Windows PowerShell inventor, Jeffrey Snover, says that [Write-Host is harmful](http://www.jsnover.com/blog/2013/12/07/write-host-considered-harmful/)\n\n**Write-Host is not written to any stream**.`write-host`不会污染输出流,且`不向任何流进行输入`.单纯向屏幕输出.\n\n也就是说你无法将`write-host`的message定向到其他流,也没法分配给变量.\n\n还可以看看这里:[about_Redirection - PowerShell | Microsoft Docs](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_redirection?view=powershell-7)\n\n另外举个例子:\n\n```powershell\n# 同时ls查看两个目录,如下命令可以将错误信息重定向转移走,输入到z文件,而不会只是将success的ls d:结果输出z\n▶ ls D:,fake *> z\n\n# 如果不重定向\n▶ ls D:,fake > z\nGet-ChildItem: Cannot find path 'C:\\Users\\root\\fake' because it does not exist.\n~ ⨯\n▶ cat z\n\n\n    Directory: D:\\pw7 workstation\\git-repos\\nextjs_blog\\posts\n# 则z保存了success的信息\n```\n\n至于,将`success`消息重定向到`error流`的操作,终端提示错误,跟书本不符.不过不会真有人想要做这种事吧.\n\n另外,我用过几次将没必要的错误信息流重定向到`$null`中去.或者将没必要的所有流都扔掉:\n\n```powershell\ncmdlet *>$null\n```\n\n### 3.4 混合操作类型\n\n举例如下:\n\n```powershell\n▶ \"2\"+2\n22\n~\n▶ 2+\"22\"\n24\n~\n➜ \"2\" * 2\n22\n➜ 2 * \"2\"\n4\n➜ $a = Read-Host\n33\n➜ $a -gt 5\nFalse\n➜ 5 -gt $a\nFalse\n```\n\n左边的数据类型决定了整体的计算和数据转换方式.\n\n###  3.5 逻辑操作和字符串变换操作\n\n举例:\n\n```powershell\n-and # 与\n-or # 或\n-xor # 异或\n-not # not\n! # not\n\n# 常见替换\n➜ \"just a demo\" -replace \"demo\",\"test\"\njust a test\n\n# 正则表达式单引号替换\n➜ \"root@gmail.com\" -replace '^[\\w]+@(.+)','$1'\ngmail.com\n\n# 拆分数组\n➜ \"root@gmail.com\" -split \"@\"\nroot\ngmail.com\n\n# join数组\n➜ \"1\",\"1\",\"0\" -join \":\"\n1:1:0\n```\n\n\n\n## Chapter 4: Special Operators\n\n### 4.1 数组表达运算符\n\n通过一个表达式返回一个数组:\n\n```powershell\n➜  posts git:(master) @(Get-ChildItem C:\\Windows\\System32\\ntdll.dll)\n\n\n    Directory: C:\\Windows\\System32\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a---           2020/7/17    20:10        1999968 ntdll.dll\n\n➜  posts git:(master) @(Get-ChildItem C:\\Windows\\System32\\ntdll.dll)[0]\n\n\n    Directory: C:\\Windows\\System32\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a---           2020/7/17    20:10        1999968 ntdll.dll\n\n➜  posts git:(master) @(Get-ChildItem C:\\Windows\\System32\\ntdll.dll)[1]\n➜  posts git:(master)\n```\n\n如上所述,`@()`内部的表达式处理返回值将得到一个数组.\n\n### 4.2 调用运算符\n\n```powershell\n$command = 'ls'\n&$command # 等于直接调用字符串的内容,视为命令并执行\n```\n\n### 4.3 点源操作(dot sourcing operator)\n\n`. $profile`是我很常用的一个命令,因为我经常修改预加载的配置文件`$profile`.这个变量指向一个`.ps1`文件,每个console打开的时候都会`run`这个文件.因此,可以在这里面设置一下alias或者function.\n\n当我们在当前terminal下使用`. xxx.ps1`命令执行此脚本的时候,即将此脚本的执行环境范围设置为当前`terminal session`.\n\n回到`$profile`的例子,我修改了这个脚本,并且在当前`terminal`执行了`. $profile`,则此脚本内的函数即加载到我的`terminal session`内了.我可以轻松调用此脚本内的函数处理我的事务.\n\n## Chapter 5: Basic set Operations\n\n### 5.1 对象选择\n\n使用条件表达式`where-object` 过滤枚举对象,其常用alias是`where`和`?`.\n\n```powershell\n➜  ~ $names= @(\"Aaron\",\"Albert\",\"Alphonse\",\"Bernie\",\"Charlie\",\"Danny\",\"Ernie\",\"Frank\")\n➜  ~ $name | Where-Object {$_ -like \"*yi\"}\nyouyi\n➜  ~ $name | Where {$_ -like \"*yi\"}\nyouyi\n➜  ~ $name | ? {$_ -like \"*yi\"}\nyouyi\n```\n\n### 5.2 对象排序\n\n对可迭代对象进行升序和降序排序:\n\n```powershell\n➜  ~ $names= @(\"Aaron\",\"Albert\",\"Alphonse\",\"Bernie\",\"Charlie\",\"Danny\",\"Ernie\",\"Frank\")\n➜  ~ $names | sort\nAaron\nAlbert\nAlphonse\nBernie\nCharlie\nDanny\nErnie\nFrank\n➜  ~ $names | Sort-Object -Descending\nFrank\nErnie\nDanny\nCharlie\nBernie\nAlphonse\nAlbert\nAaron\n\n# 指定属性\n➜  ~ $names | Sort-Object -Top 3 -Property Length\nAaron\nDanny\nErnie\n➜  ~ $names | Sort-Object {$_.length} -Top 3\nAaron\nDanny\nErnie\n```\n\n### 5.3 分组排序\n\n可以通过设置表达式,实现分组的排序.\n\n```powershell\n➜  ~ $names | Group-Object -Property length # group-object alias is group\n\nCount Name                      Group\n----- ----                      -----\n    4 5                         {Aaron, Danny, Ernie, Frank}\n    2 6                         {Albert, Bernie}\n    1 7                         {Charlie}\n    1 8                         {Alphonse}\n```\n\n\n\n### 5.4 对象投影\n\n这个小节标题让我想起当初上SQL的课的时候了.投影一个可迭代对象的部分item,可以对单独的对象进行展开操作.获取自己想要的部分数据.\n\n```powershell\n➜  ~ $dir = ls\n➜  ~ $dir | select name, FullName, LastAccessTime\n\nName                     FullName                               Last\n                                                                Acce\n                                                                ssTi\n                                                                me\n----                     --------                               ----\n.atom                    C:\\Users\\root\\.atom                    202…\n.config                  C:\\Users\\root\\.config                  202…\n.ssh                     C:\\Users\\root\\.ssh                     202…\n.vscode                  C:\\Users\\root\\.vscode                  202…\n3D Objects               C:\\Users\\root\\3D Objects               202…\nContacts                 C:\\Users\\root\\Contacts                 202…\nDocuments                C:\\Users\\root\\Documents                202…\nDownloads                C:\\Users\\root\\Downloads                202…\nFavorites                C:\\Users\\root\\Favorites                202…\nLinks                    C:\\Users\\root\\Links                    202…\nMusic                    C:\\Users\\root\\Music                    202…\nOneDrive                 C:\\Users\\root\\OneDrive                 202…\nPictures                 C:\\Users\\root\\Pictures                 202…\nSaved Games              C:\\Users\\root\\Saved Games              202…\nscoop                    C:\\Users\\root\\scoop                    202…\nSearches                 C:\\Users\\root\\Searches                 202…\nVideos                   C:\\Users\\root\\Videos                   202…\n.bash_history            C:\\Users\\root\\.bash_history            202…\n.bash_profile            C:\\Users\\root\\.bash_profile            202…\n.bashrc                  C:\\Users\\root\\.bashrc                  202…\n.bashrc.swp              C:\\Users\\root\\.bashrc.swp              202…\n.gitconfig               C:\\Users\\root\\.gitconfig               202…\n.git-for-windows-updater C:\\Users\\root\\.git-for-windows-updater 202…\n.node_repl_history       C:\\Users\\root\\.node_repl_history       202…\n.viminfo                 C:\\Users\\root\\.viminfo                 202…\n.vuerc                   C:\\Users\\root\\.vuerc                   202…\n.yarnrc                  C:\\Users\\root\\.yarnrc                  202…\n\n➜  ~\n```\n\n","title":"Powershell随写","date":"2020-08-03","tags":["powershell"],"mainImg":"https://images.unsplash.com/photo-1599418268698-b5a48a743a8e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=1080","coverImg":"https://images.unsplash.com/photo-1599418268698-b5a48a743a8e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8&ixlib=rb-1.2.1&q=80&w=400","intro":"powershell 很棒,我想任何一个善用 windows 的开发者都应该学习 powershell ,系统自带环境的优势让开发者能够使用 powershell 轻松辅助开发,提高工作效率,本文献给对 powershell 感兴趣的朋友.如果你有任何关于 powershell 的内容想要与我沟通,欢迎发邮件."}},"__N_SSG":true}
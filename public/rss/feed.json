{
    "version": "https://jsonfeed.org/version/1",
    "title": "妙才Dev",
    "home_page_url": "http://localhost:3000",
    "feed_url": "http://localhost:3000/rss/feed.json",
    "description": "web developer blog.",
    "icon": "http://localhost:3000/code.png",
    "author": {
        "name": "妙才",
        "url": "https://twitter.com/miaocai0"
    },
    "items": [
        {
            "id": "http://localhost:3000/blog/1397551248",
            "content_html": "<h2 id=\"前言\">前言</h2>\n<p>我在写了一个新的小工具并且将代码上传到 GitHub 的时候，突然想要打开这个仓库的主页，然而我找不到 gh 和 git 这俩 cli 支持这个功能的地方，于是我就用自己当前使用的 fish shell 写了一个函数，用于快速打开我的仓库。</p>\n<h2 id=\"主体内容\">主体内容</h2>\n<h3 id=\"系统环境\">系统环境</h3>\n<ul>\n<li><code>Mac</code></li>\n<li><code>fish</code></li>\n</ul>\n<h3 id=\"脚本代码\">脚本代码</h3>\n<blockquote>\n<p>我对 fish 也不够了解，只是为了是实现这个功能而马上去看了其函数的语法和字符串处理的一些知识。</p>\n</blockquote>\n<pre><code class=\"language-shell\">function ghome\n    # 通过 git 尝试获取当前仓库的地址\n  set -l homepage_url (command git remote --verbose 2&gt; /dev/null | grep fetch | command cut -c 8-)\n  # 显然如果不是仓库则执行失败\n  if [ $status -gt 0 ]\n    echo &#39;Not a git repo&#39;\n    return 1\n  end\n    # 没获取到地址也失败\n  if [ -z $homepage_url ]\n    echo &#39;Not a git repo&#39;\n    return 1\n  end\n    # 不是 GitHub 的仓库也不算\n  if [ -z (echo $homepage_url | grep github) ]\n    echo &#39;Not a git repo...&#39;\n    return 1\n  end\n  # 获取当前的分支名\n  set -l branch (command git rev-parse --abbrev-ref HEAD)\n    # 获取地址并使用 open 命令打开\n  set -l url (string replace -r &#39;\\.git.*&#39; &#39;&#39; $homepage_url)\n  open $url/tree/$branch\nend\n</code></pre>\n<p>如此一来，我就可以很方便的使用<code>ghome</code>命令直接打开的当前仓库的线上主页了。</p>\n<h2 id=\"最后\">最后</h2>\n<p>这看起来只是一个非常无聊的脚本，但是说实话对我来说挺好用的。尬住。</p>\n<blockquote>\n<p><code>fish</code>是一个非常好用的<code>shell</code>环境，某种程度上可以很好的代替<code>zsh</code>，你可以在很多地方搜索到它的优缺点~</p>\n</blockquote>\n<p>又十二点过去了，狗命要紧🐶，睡觉，各位晚安。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"https://fishshell.com/docs/current/tutorial.html\">Tutorial — fish-shell 3.3.1 documentation</a></li>\n<li>源代码<a href=\"https://github.com/youyiqin/fish_functions/tree/main\">youyiqin/fish_functions</a></li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397551248",
            "title": "用fish-shell创建一个快速打开当前仓库主页的函数",
            "summary": "## 前言",
            "date_modified": "2022-10-05T10:06:01.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397548261",
            "content_html": "<p>今天记录一下学习到的后端接口认证的知识，JWT 技术。\n<img src=\"https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGNvZGV8ZW58MHx8MHx8&auto=format&fit=crop&w=700&q=60\" alt=\"\"></p>\n<h1 id=\"前言\">前言</h1>\n<p>我的小项目需要使用一种接口认证机制，为了尽量减小服务器端的资源压力，我选择了近年来非常火热的<code>JWT</code>技术。</p>\n<h1 id=\"简介\">简介</h1>\n<p>什么是<code>JWT</code>?</p>\n<blockquote>\n<p><a href=\"https://jwt.io/\">JSON Web Tokens - jwt.io</a></p>\n</blockquote>\n<p>在其官网的首页上有一段非常显眼的介绍：“JSON Web Token 是一个开放的行业标准（RFC 7519），可以在两方之间安全传输信息”。</p>\n<p>如下是一个经过编码的<code>token</code>：</p>\n<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ\n.\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n</code></pre>\n<p>请忽视换行符，<code>token</code>由三个部分组成并且使用<code>.</code>号分隔：</p>\n<ol>\n<li>头部</li>\n<li>载荷对象</li>\n<li>验证签名</li>\n</ol>\n<p>让我们通过一张图片来理解这个过程：</p>\n<p>![image-20211101223843693](/Users/yi/Library/Application Support/typora-user-images/image-20211101223843693.png)</p>\n<p>上述例子中的：<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code>就是头部数据经过<code>base64</code>编码后的结果。<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</code>则是载体对象经过<code>base64</code>编码后的结果，而<code>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code>则是通过某种算法对<code>头部 base64 编码</code>+<code>.</code>+<code>载荷对象 base64 编码</code>和秘钥进行加密后的结果。</p>\n<h2 id=\"jwt-的优缺点\">JWT 的优缺点</h2>\n<h3 id=\"优点\">优点</h3>\n<ul>\n<li><p>JWT 具有较好的扩展性，且相对于传统的 Session 方案有不占服务器资源的优势</p>\n</li>\n<li><p>JWT 的载荷对象中可以存储信息（加密或不加密可视情况而定）</p>\n</li>\n</ul>\n<h3 id=\"缺点\">缺点</h3>\n<ul>\n<li>易滥用：当载荷对象中存储的信息过多的时候，<code>token</code>将会变得非常冗长，所以需要开发者进行控制，避免滥用于数据交换</li>\n<li>载荷和头部对象可以直接通过 base64 进行解码得到明文信息（当然开发者可以进行额外的加密控制，或者使用 https 技术防止 token 泄露）</li>\n<li>不支持撤销（可以通过增加服务器端缓存或白名单机制来弥补，但同时也增加了资源消耗）</li>\n</ul>\n<h2 id=\"适用场景\">适用场景</h2>\n<ul>\n<li>安全要求不高的认证场景</li>\n<li>短期或一次性认证需求</li>\n</ul>\n<h1 id=\"koa-和-jwt\">Koa 和 Jwt</h1>\n<p>我的个人项目使用了<code>Koa</code>框架开发后端接口应用，为了使用<code>JWT</code>的特性我需要安装以下两个包：</p>\n<ul>\n<li>koa-jwt</li>\n<li>jsonwebtoken</li>\n</ul>\n<p><code>koa-jwt</code>中间件让我们能够设置使用<code>jwt</code>来保护哪些路由，并且将请求头中的<code>token</code>数据解析出来，扩展到<code>ctx</code>上下文中。</p>\n<p>显然，我们可以将注册和登录的接口作为白名单，直接提供给所有用户使用，当用户注册或登录成功的时候，服务端通过<code>jsonwebtoken</code>创建一个<code>token</code>并返回给客户端。</p>\n<p>此时，客户端可以将之保存在<code>localstorage</code>中，并且使用<code>axios</code>之类的库对请求进行拦截，设置拦截器将<code>token</code>放在请求头上面，形如：</p>\n<pre><code class=\"language-bash\">Authorization: Bearer &lt;token&gt;\t\n</code></pre>\n<p>此时，<code>token</code>保存在客户端上，服务端可以通过秘钥和加密算法就能解析到<code>token</code>的信息。</p>\n<blockquote>\n<p>Koa-jwt 和 jsonwebtoken 的使用方法建议阅读文档。</p>\n</blockquote>\n<p>网上有一种<code>refresh token</code>的说法，即设置一个访问周期，当用户持续访问服务器时根据访问周期来提供新<code>token</code>来替换旧<code>token</code>，从而让保持有效期内访问的用户延长需要重新登录的时间。</p>\n<p>显然这种机制需要设置一个合适的<code>token</code>过期时间和刷新周期，被替换的<code>token</code>在某些时间段依然可以访问服务器。</p>\n<p>在不同的场合下选择不同的技术才是解决问题的关键！</p>\n<h1 id=\"参考\">参考</h1>\n<ul>\n<li><a href=\"https://jwt.io/\">JSON Web Tokens - jwt.io</a></li>\n<li><a href=\"https://jwt.io/introduction\">JSON Web Token Introduction - jwt.io</a></li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397548261",
            "title": "谈谈JWT(Json web token) 技术",
            "summary": "今天记录一下学习到的后端接口认证的知识，JWT 技术。",
            "date_modified": "2022-10-05T13:57:02.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397546849",
            "content_html": "<p>目前对 sass 编写样式表一知半解，在写手头的项目时十分不顺，效率低下，因此打算花两个小时重学 sass</p>\n<h1 id=\"前言\">前言</h1>\n<p>时至今日，<code>Sass</code>已经可以视为一门编程语言了。笔者目前对 sass 编写样式表一知半解，在写手头的项目时十分不顺，效率低下，因此打算花两个小时重学 sass。</p>\n<p>某种意义上而言本文仅仅是笔者对于文档的学习和思索，更好的学习方法依然是阅读文档，但是于我于有兴趣阅读此文的朋友而言都一样，我都希望我们能够有所得。</p>\n<h1 id=\"大纲\">大纲</h1>\n<ul>\n<li>语法</li>\n<li>样式规则</li>\n<li>变量</li>\n<li>操作</li>\n<li>模块</li>\n<li>断点和混入</li>\n</ul>\n<h2 id=\"语法\">语法</h2>\n<h3 id=\"基础\">基础</h3>\n<p>sass 支持两种语法，二者可以互相载入，分别是：</p>\n<ul>\n<li>scss</li>\n<li>sass</li>\n</ul>\n<p>二者的区别从扩展名开始，<code>scss</code>对<code>css</code>的兼容性是最好的，几乎所有的<code>css</code>都是有效的<code>scss</code>写法（除了错误的语法被忽略的那部分），正因如此，此语法广受推崇。</p>\n<blockquote>\n<p>当你 copy 一段让人拍案叫绝的代码到自己的样式表中时，你什么都不需要做</p>\n</blockquote>\n<p>笔者喜欢<code>.sass</code>第二种语法，本文内容建议使用<code>.sass</code>来理解。笔者很懒，<code>.sass</code>可以少写些许花括号和分号，唯一需要注意的是<code>.sass</code>对缩进的写法非常严格，不过这不是什么大问题。</p>\n<h3 id=\"解析样式表\">解析样式表</h3>\n<blockquote>\n<p>A Sass stylesheet is parsed from a sequence of Unicode code points. It&#39;s parsed directly, without first being converted to a token stream.</p>\n</blockquote>\n<p><code>sass</code>需要通过编译器去编译成<code>css</code>，流行的编译器如下：</p>\n<ul>\n<li>Dart Sass</li>\n<li>LibSass</li>\n<li>Ruby Sass</li>\n</ul>\n<p>通常我们写样式都用不上除了英文和数字外的字符，上述编译器<code>Dart Sass</code>只支持<code>UTF-8</code>字符，只有当我们需要用超过<code>UTF-8</code>字符集的字符来写样式时，才需要考虑不使用<code>Dart Sass</code>。</p>\n<p>当编译器遇到无效的语法时，解析会失败并且提供错误信息以便开发者修正错误语法。</p>\n<h3 id=\"样式表结构\">样式表结构</h3>\n<p>除了和<code>css</code>类似的样式属性声明外，<code>sass</code>还支持许多增强型特性。</p>\n<p><code>sass</code>由一系列的语句块组成，语句块之间可以嵌套其他语句块。</p>\n<h4 id=\"语句\">语句</h4>\n<p>我们可以将语句分为四种：</p>\n<ul>\n<li>css 语句<ul>\n<li>样式规则</li>\n<li>css @规则，例如 <code>@media</code></li>\n<li>Mixin</li>\n<li>@at-root</li>\n</ul>\n</li>\n<li>普通语句<ul>\n<li>变量声明 <code>$var: value</code></li>\n<li>流程控制 <code>@if</code></li>\n<li>规则控制 <code>@error</code>、<code>@debug</code>等</li>\n</ul>\n</li>\n<li>顶层语句(样式表顶层或嵌套的 css 顶层)<ul>\n<li>文件引入 <code>@import</code></li>\n<li>混入 <code>@minxin</code></li>\n<li>函数定义 <code>@function</code></li>\n</ul>\n</li>\n<li>其他语句<ul>\n<li><code>@extend</code>语句写在样式属性中</li>\n</ul>\n</li>\n</ul>\n<p>前者易于理解，跟<code>css</code>更为接近。后者形如则是<code>sass</code>的核心，有了这些才撑起了整体结构。</p>\n<p>即使对上述词汇了解不多也不需要担心，接下来逐一拆解学习。</p>\n<h4 id=\"表达式\">表达式</h4>\n<p>表达式语法即<code>SassScript</code>。</p>\n<p>表达式位于属性或变量声明的右侧，表达式产生一个<code>值</code>。显然，任意有效的<code>css</code>值都可以理解为<code>sass</code>的表达式。</p>\n<p>在<code>sass</code>中，表达式用于传给<code>mixin</code>或<code>function</code>,亦或配合<code>@if</code>控制流，甚至进行<code>算术运算</code>。</p>\n<p>最简单的表达式只表示静态的值，例如：</p>\n<ul>\n<li>Numbers: 100px</li>\n<li>String: &quot;bolder&quot;</li>\n<li>Colors: #eee</li>\n<li>Booleans: true or false</li>\n<li>Lists: 1px 2px 0 1px</li>\n<li>Maps: 键值对映射，例如<code>(&quot;color&quot;: red, &quot;font-size&quot;: 12px)</code></li>\n</ul>\n<p>其他表达式：</p>\n<ul>\n<li>变量<code>$var</code></li>\n<li>函数调用<code>var(--color-bg-1)</code></li>\n<li>特殊函数<code>calc(1px + 100%)</code>或<code>url(...)</code></li>\n<li>父选择器 <code>&amp;</code></li>\n<li><code>!important</code></li>\n</ul>\n<h3 id=\"操作符\">操作符</h3>\n<p><code>sass</code>支持许多操作符语法：</p>\n<ul>\n<li><code>== or !=</code>比较值</li>\n<li><code>+ - * / % </code>数学计算</li>\n<li><code>&lt; &lt;= &gt; &gt;=</code>逻辑判断</li>\n<li><code>and or not</code>布尔值判断</li>\n<li><code>+ - /</code>字符串拼接</li>\n<li><code>()</code>优先级控制</li>\n</ul>\n<h3 id=\"注释\">注释</h3>\n<p><code>sass</code>是编程语言，有注释很正常。</p>\n<p>在 <code>scss</code> 中写注释，可以这样写：</p>\n<pre><code class=\"language-scss\">// 这个注释不会出现在CSS中\n\n/* 这个将会出现在CSS中，压缩模式下不会有 */\n\n/* CSS中显示插值的计算结果\n * 1 + 1 = #{1 + 1} */\n\n/*! 在压缩模式下也会显示 */\n\np /* 多行注释可以写在任何允许 */\n  /* 使用空格的地方。 */ .sans {\n  font: Helvetica,\n    // 单行注释也是\n    sans-serif;\n}\n</code></pre>\n<p>回到正题，在<code>sass</code>中更简洁：</p>\n<pre><code class=\"language-scss\">//  这个注释不会出现在CSS中\n    这个也被注释掉了\n\n/*  这个将会出现在CSS中，压缩模式下不会有\n\n/*  CSS中显示插值的计算结果\n *  1 + 1 = #{1 + 1}\n\n/*! 在压缩模式下也会显示\n\np .sans\n  font: Helvetica, /* 内联注释必须是闭合的 */ sans-serif\n</code></pre>\n<blockquote>\n<p>当你打算编写样式库时，可以在文档的最上方使用三斜杠<code>///</code>来开头编写文档，最终<code>SassDoc</code>等工具可以读取并且生成美观的文档。</p>\n</blockquote>\n<h3 id=\"特殊函数\">特殊函数</h3>\n<p>此前在表达式处提及特殊函数，在此重申之。</p>\n<p><code>url()</code>是<code>css</code>中常用的函数，在<code>sass</code>中需要用特殊的逻辑来解析它。简单来看，可以按<code>css</code>规则来调用，也可以使用<code>sass</code>变量或函数调用最后的值来解析。举个例子：</p>\n<pre><code class=\"language-scss\">$roboto-font-path: &quot;../fonts/roboto&quot;\n\n@font-face\n    // This is parsed as a normal function call that takes a quoted string.\n    src: url(&quot;#{$roboto-font-path}/Roboto-Thin.woff2&quot;) format(&quot;woff2&quot;)\n\n    font-family: &quot;Roboto&quot;\n    font-weight: 100\n\n\n@font-face\n    // This is parsed as a normal function call that takes an arithmetic\n    // expression.\n    src: url($roboto-font-path + &quot;/Roboto-Light.woff2&quot;) format(&quot;woff2&quot;)\n\n    font-family: &quot;Roboto&quot;\n    font-weight: 300\n</code></pre>\n<p>此外，还有其他的特殊函数：</p>\n<p>css 中的**calc()**跟<code>sass</code>算法冲突，总之一句话，除了<code>sass</code>插值用于动态注入值之外，其他内容都作为原生<code>css</code>内容解析。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-scss\">.logo\n  $width: 800px\n  width: $width\n  position: absolute\n  left: calc(50% - #{$width / 2})\n  top: 0\n</code></pre>\n<p>Sass 中的<code>min()和 max()</code>二者在<code>css</code>支持之前就实现了，当这类特殊函数中不包含除了插值之外的任何<code>SassScript</code>的特性时，解析为<code>css</code>原生函数。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-scss\">$padding: 12px\n\n.post\n  // Since these max() calls don&#39;t use any Sass features other than\n  // interpolation, they&#39;re compiled to CSS max() calls.\n  // 插值和原生的 env 函数\n  padding-left: max(#{$padding}, env(safe-area-inset-left))\n  padding-right: max(#{$padding}, env(safe-area-inset-right))\n\n\n.sidebar\n  // Since these refer to a Sass variable without interpolation, they call\n  // Sass&#39;s built-in max() function.\n  // 变量属于 SassScript\n  padding-left: max($padding, 20px)\n  padding-right: max($padding, 20px)\n</code></pre>\n<p>除此之外，还有众多内建函数，我们在配合相关知识点时候再总结。</p>\n<h2 id=\"变量\">变量</h2>\n<p><code>$&lt;variable&gt;:&lt;expression&gt; </code>即变量定义，使用<code>$</code>开头进行定义，表达式求值。</p>\n<blockquote>\n<p>Sass 标识符和变量名都将连字符<code>-</code>和下划线<code>_</code>视为相同的字符。</p>\n</blockquote>\n<p>任何地方都可以申明变量，<code>sass</code>的变量会被编译，因此一次只能有一个值，可以重新定义同名的变量，使用新值覆盖旧值，再使用新的变量和值，整个过程是命令式的。</p>\n<p>在开发<code>sass</code>库时可以使用<code>!default</code>来编写变量默认值，普通开发者则无需关心。</p>\n<p>举例：</p>\n<pre><code class=\"language-scss\">// _library.sass\n$black: #000 !default\n$border-radius: 0.25rem !default\n$box-shadow: 0 0.5rem 1rem rgba($black, 0.15) !default\n\ncode\n  border-radius: $border-radius\n  box-shadow: $box-shadow\n</code></pre>\n<pre><code class=\"language-scss\">// style.sass\n$black: #222\n$border-radius: 0.1rem\n\n@import &#39;library&#39;\n</code></pre>\n<p>显然，我们在使用他人开发的库时，可以预先定义一些变量来个性化样式表。库的开发者也可以用默认样式兜底。</p>\n<p>既然有变量，当然也有<code>变量作用域</code>。</p>\n<p>一个<code>sass</code>文件顶层声明的变量是整个文件全局可访问的，并且当这个文件被其他文件引入时，顶层的变量将被共享。</p>\n<p>在块中声明的变量却是本地可用的，在当前块内可用，当块内变量和全局变量同名时，在块内的优先级更高。</p>\n<p>但是依然有办法灵活应用规则，举个例子：</p>\n<pre><code class=\"language-scss\">$variable: first global value;\n\n.content {\n  $variable: second global value !global;\n  value: $variable;\n}\n\n.sidebar {\n  value: $variable;\n}\n</code></pre>\n<p>使用<code>!global</code>标志可以显式指定此变量为全局变量。</p>\n<p>另外，在<code>流程控制</code>中声明的变量具有特殊的作用域，并且流程控制内只能<code>给外部存在的变量赋值</code>，而不能声明新的变量。</p>\n<p>举个<code>scss</code>的例子：</p>\n<pre><code class=\"language-scss\">$dark-theme: true !default;\n$primary-color: #f8bbd0 !default;\n$accent-color: #6a1b9a !default;\n\n@if $dark-theme {\n  $primary-color: darken($primary-color, 60%);\n  $accent-color: lighten($accent-color, 60%);\n}\n\n.button {\n  background-color: $primary-color;\n  border: 1px solid $accent-color;\n  border-radius: 3px;\n}\n</code></pre>\n<p>引入此库的其他文件可以自定义暗色主题来控制当前样式的结果。</p>\n<p>还有一个问题，如何判断变量是否存在？<code>sass</code>提供了以下函数：</p>\n<ul>\n<li>Variable-exists()</li>\n<li>Global-variable-exists()</li>\n</ul>\n<p>二者分别判断当前作用域内变量和全局变量。</p>\n<h2 id=\"插值\">插值</h2>\n<p>只要我们需要将表达式的结果嵌入到<code>css</code>块中去，就可以使用<code>#{}</code>包装的表达式，这种语法被称为插值。</p>\n<p>我们可以在任何地方使用插值，插值就像表达式替换。<code>sass</code>以一种直白的方式来让插值生效，举个例子：</p>\n<pre><code class=\"language-scss\">@mixin corner-icon($name, $top-or-bottom, $left-or-right) .icon-#{$name} background-image:\n  url(&quot;/icons/#{$name}.svg&quot;) position: absolute #{$top-or-bottom}: 0 #{$left-or-right}:\n  0 @include corner-icon(&quot;mail&quot;, top, right);\n</code></pre>\n<p>先不论<code>mixin</code>和<code>include</code>是什么，无论你传入什么值过去，编译后将直接在原位置进行替换：</p>\n<pre><code class=\"language-css\">.icon-mail {\n  background-image: url(&quot;/icons/mail.svg&quot;);\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n</code></pre>\n<blockquote>\n<p>需要注意的是，当插值花括号中包含引号时，带引号的字符串周围的引号会被删除。</p>\n</blockquote>\n<h2 id=\"样式规则\">样式规则</h2>\n<p>进入正题。</p>\n<blockquote>\n<p><code>css</code>也已经存在嵌套的草案，很棒。</p>\n</blockquote>\n<p><code>sass</code>支持嵌套，这是<code>sass</code>随处可见的知识点，但凡看过 sass 的开发者都知道，无需赘述。关键在于：<code>控制嵌套深度 </code>，嵌套很棒但过深的嵌套生成的<code>css</code>代码就越多，三层足以避免过犹不及。</p>\n<p>选择器列表支持和组合选择器可以直接使用<code>css</code>语法。</p>\n<p>举个例子 🌰：</p>\n<pre><code class=\"language-scss\">.enlarge\n  font-size: 14px\n    margin: 1rem\n        top: 2rem\n  transition:\n    property: font-size\n    duration: 4s\n    delay: 2s\n\n  &amp;:hover\n    font-size: 36px\n    &amp; &gt; h1\n        color: #333\n    &amp;r\n        color: purple\n\n    .other\n        color: red\n</code></pre>\n<p>上述<code>enlarge</code>类内嵌套了<code>other</code>类，并且使用了<code>&amp;</code>父节点选择器实现了<code>.enlarge:hover</code>、<code>.enlarge &gt; h1</code>甚至是<code>.enlarger</code>这样的选择器效果。</p>\n<p>其中<code>margin</code>属性名还可以视为命名空间嵌套着使用，编译出<code>margin-top: 2rem</code>的样式。</p>\n<p>此外，编译器都能对多个父选择器做出判断：</p>\n<pre><code class=\"language-scss\">ul, ol\n  text-align: left\n\n  &amp; &amp;\n    padding:\n      bottom: 0\n      left: 0\n</code></pre>\n<p>上述父选择器按顺序进行编译，不必担心<code>ul</code>和<code>ol</code>在使用父选择器时出现顺序异常。</p>\n<p><code>&amp;</code>父选择器可以作为判断条件，例如：</p>\n<p><code>if(&amp;, &#39;&amp;.app-background&#39;, &#39;.app-background&#39;)</code></p>\n<p>当前处于子级范围时，采用前者，否则采用后者。</p>\n<blockquote>\n<p>即使是 css，选择器就已经非常强大了。</p>\n</blockquote>\n<p>此外，还可以根据特定的条件去设置属性和值，此时声明一个<code>null</code>作为表达式，最终将不会编译此属性。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-scss\">$rounded-corners: false\n\n.button\n  border: 1px solid black\n  border-radius: if($rounded-corners, 5px, null)\n</code></pre>\n<p>最终的<code>css</code>文件将不包含<code>border-radius</code>属性。</p>\n<p><code>css</code>支持<code>自定义属性</code>，也称为<code>css</code>变量。这个机制允许开发者灵活的设置属性，同时<code>JavaScript</code>能够访问这些值。</p>\n<p>在<code>sass</code>中对<code>css</code>自定义属性的处理需要关注的核心只有一个：仅有插值是动态的，其他标记都将原样编译为<code>css</code>，举个例子：</p>\n<pre><code class=\"language-scss\">$primary: #81899b\n$accent: #302e24\n$warn: #dfa612\n// 插值将顺利转换\n:root\n  --primary: #{$primary}\n  --accent: #{$accent}\n  --warn: #{$warn}\n\n  // Even though this looks like a Sass variable, it&#39;s valid CSS so it&#39;s not\n  // evaluated.\n  // 下一行将原样编译为 css\n  --consumed-by-js: $primary\n</code></pre>\n<p>此外，还需要了解一个非常强大的<code>sass</code>选择器：<code>占位符</code>选择器。</p>\n<p>占位符选择器和其他<code>css</code>选择器类似，它以<code>%</code>开头，并且不会包含在<code>css</code>输出中，举个例子：</p>\n<pre><code class=\"language-scss\">.alert:hover, %strong-alert\n  font-weight: bold\n\n\n%strong-alert:hover\n  color: red\n</code></pre>\n<p>最终编译的结果如下：</p>\n<pre><code class=\"language-css\">.alert:hover {\n  font-weight: bold;\n}\n</code></pre>\n<p>但是，我们却可以在<code>sass</code>中引用其内容对其他选择器进行扩展，减少代码量，举个例子：</p>\n<pre><code class=\"language-scss\">%toolbelt\n  box-sizing: border-box\n  border-top: 1px rgba(#000, .12) solid\n  padding: 16px 0\n  width: 100%\n\n  &amp;:hover\n    border: 2px rgba(#000, .5) solid\n\n.action-buttons\n  @extend %toolbelt\n  color: #4285f4\n\n.reset-buttons\n  @extend %toolbelt\n  color: #cddc39\n</code></pre>\n<p>如上所示，<code>.action-buttons</code>和<code>.reset-button</code>都被扩展了，最后的编译结果为：</p>\n<pre><code class=\"language-css\">.action-buttons,\n.reset-buttons {\n  box-sizing: border-box;\n  border-top: 1px rgba(0, 0, 0, 0.12) solid;\n  padding: 16px 0;\n  width: 100%;\n}\n.action-buttons:hover,\n.reset-buttons:hover {\n  border: 2px rgba(0, 0, 0, 0.5) solid;\n}\n\n.action-buttons {\n  color: #4285f4;\n}\n\n.reset-buttons {\n  color: #cddc39;\n}\n</code></pre>\n<p>显然我们可以灵活编写占位符选择器，并且选择适当的情况下<code>扩展</code>其他选择器，还不用关心占位符选择器这部分代码，因为最终在不引用的情况下会忽略这部分而编译整体。</p>\n<h2 id=\"模块化\">模块化</h2>\n<p>编程语言模块化可以将复杂的单文件拆分成多个小文件，将复杂环境拆分梳理为若干小环境，降低开发者的心智压力。</p>\n<p>按照惯例，开发者将以<code>下划线</code>开头的<code>sass</code>文件视为<code>片段文件</code>，这些片段文件将被<code>@import</code>指令使用，如果不然<code>sass</code>编译器将忽略编译这些片段文件。</p>\n<p>一句话，使用下划线开头的文件作为片段文件，在需要用到片段文件的<code>sass</code>文件使用<code>@import</code>指令将之引入，引入时需要<code>忽略下划线</code>。</p>\n<blockquote>\n<p>css 具有自己的 @import 规则，浏览器在解析到 css 的导入行为时将会发起一个 http 请求获取此目标文件。</p>\n</blockquote>\n<p><code>sass</code>将会获取目标导入文件，并且将此文件和被导入的文件结合，编译出最终样式表。</p>\n<p>当将片段文件导入到目标文件后，目标文件可以使用片段文件中的内容。</p>\n<h2 id=\"规则\">规则</h2>\n<p>Sass 的大部分额外功能都是在 CSS 之上添加新<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule\">@规则</a></p>\n<p>以下是我们可以在日常开发中使用起来的规则：</p>\n<ul>\n<li>@import 引入样式、mixin、函数、变量</li>\n<li>@mixin、@include 增强复用样式块</li>\n<li>@function 增强内置函数外的函数功能</li>\n<li>@at-root 将样式放入 CSS 文档的根目录中</li>\n<li>@error、@warn、@debug 用于调试</li>\n<li>@if、@each、@for、@while 控制函数逻辑</li>\n</ul>\n<p>接着，我们逐一加深这些知识点的印象。</p>\n<h3 id=\"import\">@import</h3>\n<p>原生的<code>css</code>让浏览器呈现时增加<code>http</code>请求，而<code>sass</code>则在编译期间解决问题。</p>\n<p>导入多个文件时可以添加逗号作为分隔，使用<code>.sass</code>语法时不需要为<code>URL</code>添加括号。并且导入的文件内容将会放在<code>@import</code>指令出现的位置，但嵌套导入的 mixin、函数、变量依然具有原作用域。</p>\n<p>另外，对于导入的文件<code>URL</code>，编译器都能很好的自动进行忽略扩展名的文件查找，并且在路径上统一使用<code>/</code>作为分隔符。开发者不需要为不同平台的地址问题费心思了。</p>\n<p>对于加载路径的优先级而言，本地文件的优先级高于<code>node_modules</code>下的库文件。</p>\n<p>如果导入的是一个<code>css</code>文件（本地或远程）亦或使用了<code>url()</code>或媒体查询时，最终将会直接作为原生的<code>css</code>导入使用。</p>\n<h3 id=\"mixin\">@mixin</h3>\n<p>通过<code>@mixin</code>定义一个具名的<code>mixin</code>，通过<code>@include mixinName</code> 使用<code>mixin</code>。</p>\n<blockquote>\n<p>从笔者个人层面来看，<code>mixin</code>就是<code>sass</code>这门语言的&quot;函数&quot;</p>\n</blockquote>\n<p><code>mixin</code>能够让我们轻松通过<code>复用</code>机制减少非语义类的使用，并且<code>mixin</code>非常灵活。</p>\n<p>接下来我直接看几个<code>mixin</code>及其用法：</p>\n<pre><code class=\"language-scss\">@mixin square($size, $radius: 0) width: $size height: $size @if $radius != 0 border-radius:\n  $radius .avatar @include square(100px, $radius: 4px);\n</code></pre>\n<p>如上所示，可以预定义一个<code>mixin</code>，参数支持具有默认值的可选参数，这一点跟<code>JS</code>很像。</p>\n<p>再看一个示例：</p>\n<pre><code class=\"language-scss\">@mixin square($size, $radius: 0, $n: 1) width: $size height: $size @if $n != 1 border:\n  #{$n}px .avatar @include square(100px, $n: 4);\n</code></pre>\n<p>可以传递具名的参数，这样可以忽略传参的顺序。</p>\n<p>再看：</p>\n<pre><code class=\"language-scss\">@mixin order($height, $selectors...) @for $i from 0 to length($selectors) #{nth(\n    $selectors,\n    $i + 1\n  )} position: absolute height: $height margin-top: $i * $height @include order(150px, &quot;input.name&quot;, &quot;input.address&quot;, &quot;input.zip&quot;);\n</code></pre>\n<p>如果最后一个参数以<code>...</code>结尾，即可将传入的额外参数视为一个可以迭代的列表。</p>\n<blockquote>\n<p>nth 是内建函数</p>\n</blockquote>\n<p>最终的编译结果为：</p>\n<pre><code class=\"language-css\">input.name {\n  position: absolute;\n  height: 150px;\n  margin-top: 0px;\n}\n\ninput.address {\n  position: absolute;\n  height: 150px;\n  margin-top: 150px;\n}\n\ninput.zip {\n  position: absolute;\n  height: 150px;\n  margin-top: 300px;\n}\n</code></pre>\n<p>再看一个<code>.scss</code>示例：</p>\n<pre><code class=\"language-scss\">@mixin syntax-colors($args...) {\n  @debug keywords($args); // (string: #080, comment: #800, $variable: $60b)\n\n  @each $name, $color in keywords($args) {\n    pre span.stx-#{$name} {\n      color: $color;\n    }\n  }\n}\n\n@include syntax-colors($string: #080, $comment: #800, $variable: #60b);\n</code></pre>\n<p>传递多个参数，<code>mixin</code>的定义参数位不定键名参数，最终可以使用内建的函数获取到键值对。</p>\n<p>再看：</p>\n<pre><code class=\"language-scss\">@mixin btn($args...) {\n  @warn &quot;The btn() mixin is deprecated. Include button() instead.&quot;;\n  @include button($args...);\n}\n</code></pre>\n<p>看到这里，是否能感受到我们可以使用<code>sass</code>很方便的创建某个<code>UI</code>库的样式表，可以为团队创建基础的<code>sass</code>片段。</p>\n<p>另外，<code>mixin</code>还支持内容块，只需要在<code>mixin</code>中添加一行<code>@content</code>即可，举个例子：</p>\n<pre><code class=\"language-scss\">@mixin hover &amp;: not([disabled]): hover @content .button border: 1px solid black\n  @include hover border-width: 2px;\n</code></pre>\n<p>到这里我已经觉得复杂了，还可以支持多个<code>@content</code>和给内容块传参，善用<code>sass</code>真不容易，需要大量的使用场景和解决问题的经验。</p>\n<h3 id=\"function\">@function</h3>\n<p>通过<code>@function</code>来定义函数，并且可以在任何地方直接调动函数，就像我们使用<code>css</code>原生的函数一样。</p>\n<p>此前笔者提及<code>mixin</code>如<code>sass</code>的函数，然而实际上<code>sass</code>的函数由<code>@function</code>定义，二者是单独的概念。</p>\n<p>来看一个基础函数<code>pow</code>：</p>\n<pre><code class=\"language-scss\">@function pow($base, $exponent) $result: 1 @for $_ from 1 through $exponent $result:\n  $result * $base @return $result .sidebar float: left margin-left: pow(4, 3) * 1px;\n</code></pre>\n<p>如其名，计算乘方。关注函数的标识、参数、结构控制、返回值，这部分跟<code>mixin</code>是一样的。</p>\n<p>此外，<code>sass</code>内建了诸多强大的函数方便我们开发使用，针对不同类型有：</p>\n<ul>\n<li>颜色</li>\n<li>列表</li>\n<li>映射表</li>\n<li>数学模块</li>\n<li>meta</li>\n<li>选择器</li>\n<li>字符串</li>\n</ul>\n<p><code>sass</code>有诸多语法和数据类型，根据这些数据可以配合这部分内建函数处理问题，例如我们需要调整一个颜色值：</p>\n<pre><code class=\"language-scss\">color.adjust($color,\n  $red: null, $green: null, $blue: null,\n  $hue: null, $saturation: null, $lightness: null,\n  $whiteness: null, $blackness: null,\n  $alpha: null)\nadjust-color(...) //=&gt; color\n\n@debug color.adjust(#6b717f, $red: 15); // #7a717f\n@debug color.adjust(#d2e1dd, $red: -10, $blue: 10); // #c8e1e7\n@debug color.adjust(#998099, $lightness: -30%, $alpha: -0.4); // rgba(71, 57, 71, 0.6)\n</code></pre>\n<p>这个内建函数实在是强大而方便，此刻笔者不必赘述，我也非常欠缺使用经验。</p>\n<h3 id=\"extend\">@extend</h3>\n<p><code>sass</code>继承指的是让某个选择器继承另一个选择器的样式。关键在于扩展的目标类是否有效，其中的扩展机制能够保证以下几点：</p>\n<ul>\n<li>不会生成匹配不到任何元素的选择器</li>\n<li>它确保复杂的选择器是交错的，这样无论嵌套 HTML 元素的顺序如何，它们都可以工作。</li>\n<li>它尽可能地减少冗余选择器，同时仍然确保选择器的特性大于或等于被扩展的选择器的特性。</li>\n<li>它知道一个选择器何时匹配另一个选择器所做的一切，并可以将它们组合在一起。</li>\n<li>它智能地处理<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Combinators\">组合选择器</a>、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors\">通用选择器</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not\">:not 选择器</a>。</li>\n</ul>\n<p>举个例子：</p>\n<pre><code class=\"language-scss\">.content nav.sidebar\n  @extend .info\n\n// 不会扩展，因为“p”与“nav”不兼容。\np.info\n  background-color: #dee9fc\n\n// 没有办法知道.guide和.content的层级关系，因此Sass安全起见会生成两种选择器。\n.guide .info\n  border: 1px solid rgba(#000, 0.8)\n  border-radius: 2px\n\n// Sass知道每个匹配“main”的元素。也匹配“.content”。并避免生成不必要的交错选择器。\nmain.content .info\n  font-size: 0.8em\n</code></pre>\n<p>最后的结果为：</p>\n<pre><code class=\"language-css\">p.info {\n  background-color: #dee9fc;\n}\n\n.guide .info,\n.guide .content nav.sidebar,\n.content .guide nav.sidebar {\n  border: 1px solid rgba(0, 0, 0, 0.8);\n  border-radius: 2px;\n}\n\nmain.content .info,\nmain.content nav.sidebar {\n  font-size: 0.8em;\n}\n</code></pre>\n<p>最后扩展的结果非常难以理解（对于我来说），在有必要的时候尽可能写让大多数人易于理解的扩展吧。</p>\n<h3 id=\"调试和信息\">调试和信息</h3>\n<ul>\n<li>@error</li>\n<li>@warn</li>\n<li>@debug</li>\n</ul>\n<p>如上所示，都用于在编译时输出信息或者在调试时检查数据。</p>\n<h1 id=\"参考\">参考</h1>\n<ul>\n<li><a href=\"http://www.sass-china.com/\">Sass 中文文档</a></li>\n<li><a href=\"https://www.sassmeister.com/\">SassMeister | The Sass Playground!</a></li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397546849",
            "title": "Sass 浅解",
            "summary": "目前对 sass 编写样式表一知半解，在写手头的项目时十分不顺，效率低下，因此打算花两个小时重学 sass",
            "date_modified": "2022-10-05T10:02:23.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397545704",
            "content_html": "<p>​ 作为一个 web 开发者，我们需要掌握的 HTML 知识到底应该有多少？HTML 真的如此简单吗，我们是否应该给与其更多的重视？</p>\n<p>​ 带着这些疑问，我决定重新学习<code>HTML</code>知识，如何学习？本文将带着疑问去学习<code>HTML</code>相关的知识，并且做出一定的总结。</p>\n<h2 id=\"前言\">前言</h2>\n<p><strong>HTML</strong>（超文本标记语言），也是万维网的核心标记语言，对于现代浏览器来说，<code>HTML</code>已经发展到了第五个版本，在多年的演变和改进之下，许多不合时宜的内容被清除了，同时随着版本更迭也有新的内容添加进来，作为一个 web 开发者，我们需要紧跟技术的发展，保持前瞻性和技术敏感度。</p>\n<p>知识无限，时间有限。</p>\n<p>忽略掉那些琐碎的片段，我们将从不同的问题开启每一个知识点。</p>\n<h2 id=\"qa\">Q&amp;A</h2>\n<h3 id=\"1-html-和-xml-语法的差别\">1. HTML 和 XML 语法的差别</h3>\n<p>HTML（超文本标记语言）和 XML（可扩展标记语言）结构类似，但是在语法上具有以下不同之处：</p>\n<ul>\n<li>XML 严格区分大小写</li>\n<li>XML 具有严格的树状结构，禁止省略结束标记</li>\n<li>XML 属性值必须用引号包裹起来，而在 HTML 中则是可选的</li>\n<li>XML 所有属性必须具有值，HTML 则允许无值属性（采用默认值）</li>\n<li>XML 解析器不会像 HTML 这样过滤空格</li>\n<li>XML 没有固定的标记标签，所有标签都是自定义可扩展的</li>\n</ul>\n<p>二者在作用上也不同：</p>\n<ul>\n<li>XML 偏向于保存数据，可以被视为持久化结构</li>\n<li>HTML 偏向于描述数据结构</li>\n</ul>\n<p>其他方面：</p>\n<ul>\n<li>在浏览器中，HTML 文件的媒体类型是<code>text/html</code>，而 XML 的媒体类型则是<code>application/xhtml+xml</code>，不同的<code>MIME</code>类型在浏览器中将会以不同的解析器去解析文档。</li>\n</ul>\n<h3 id=\"2-简单快速介绍一下-html-的知识\">2. 简单快速介绍一下 HTML 的知识</h3>\n<p>从最简单的一份<code>html</code>文档说起：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;title&gt;Sample page&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Sample page&lt;/h1&gt;\n    &lt;br /&gt;\n    &lt;p&gt;This is a &lt;a href=&quot;demo.html&quot;&gt;simple&lt;/a&gt; sample.&lt;/p&gt;\n    &lt;!-- this is a comment --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>如上述示例那样，HTML 文档具有树状结构，每一个节点标签都具备<code>开始标签</code>，但是不一定具有结束标签，标签支持<code>嵌套</code>。</p>\n<p>每个标签都可能有属性和值，举个例子：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;url&quot;&gt;somewhere&lt;/a&gt;\n</code></pre>\n<p>标签具有各自的意义，属性值总是在<code>开始标签</code>内，并且如果属性值不包含特殊字符，则可以省略引号，但是更推荐保留引号，让整体结构的描述更准确。</p>\n<p>浏览器通过自己的<code>HTML</code>解析器去解析<code>HTML</code>文档，并且将之转换为<code>DOM（文档对象模型）</code>，这种模型将保存在内存中。</p>\n<p><img src=\"https://i.loli.net/2021/05/24/5e1l7FsB24hyqtR.png\" alt=\"image-20210524205054501\"></p>\n<p>上图是上述简单文档的<code>DOM</code>树状图形式，<code>DOM</code>提供了诸多<code>API</code>可以让开发者控制和修改<code>DOM</code>的结构。</p>\n<blockquote>\n<p>我们可以通过：<code>caniuse.com</code>对标签和属性的兼容性进行查询</p>\n</blockquote>\n<p>又绕回来说上述代码，最基础的上述结构中，可以继续延伸了解一下大部分标签。</p>\n<ul>\n<li><code>&lt;html&gt;</code> 为根元素，页面唯一</li>\n<li><code>&lt;head&gt;</code> 为头部信息标签，页面唯一，内部常嵌套一些补充信息和标题<ul>\n<li><code>&lt;meta&gt;</code> 元数据，常用于设置字符集，添加相关名字和描述性内容，常用于提高<code>SEO</code></li>\n<li><code>&lt;script&gt;</code> 引入 JavaScript</li>\n<li><code>&lt;title&gt;</code> 标题设置</li>\n<li><code>&lt;style&gt;</code> 嵌入 Css</li>\n<li><code>&lt;link&gt;</code> 外部资源链接</li>\n<li><code>&lt;base&gt;</code> 定义页面默认超链接的默认地址和打开方式，建议放在 head 的最前面</li>\n</ul>\n</li>\n<li><code>&lt;body&gt;</code> 页面主体，页面唯一，常用标签全部嵌套在内部。<ul>\n<li><code>&lt;h1&gt;~&lt;h6&gt;</code> 设置标题</li>\n<li><code>&lt;p&gt;</code> 设置段落文本</li>\n<li><code>&lt;a&gt;</code> 超链接</li>\n<li><code>&lt;pre&gt;</code>预格式化</li>\n<li><code>&lt;q&gt;,&lt;blockquete&gt;</code>长短引用内容</li>\n<li><code>&lt;br /&gt;</code>,<code>&lt; hr /&gt;</code> 换行标签和水平线标签</li>\n<li><code>&lt;b&gt;</code> 粗体</li>\n<li><code>&lt;small&gt;</code>小号字体</li>\n<li><code>&lt;i&gt;</code>斜体</li>\n<li><code>&lt;rt&gt;</code> 中文发音注释，顶部显示</li>\n<li><code>&lt;sub&gt;</code>下标</li>\n<li><code>&lt;sup&gt;</code> 上标</li>\n<li><code>&lt;iframe&gt;</code>内联框架，替换<code>&lt;frame&gt;</code></li>\n<li><code>&lt;cite&gt;</code>标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。默认斜体，引用分离，有助于自动摘录参考的功能。</li>\n<li><code>&lt;div&gt;</code> 通用块元素</li>\n<li><code>&lt;span&gt;</code> 内联文本元素</li>\n<li><code>&lt;textarea&gt;</code> 输入区</li>\n<li><code>&lt;input&gt;</code> 输入框<ul>\n<li><code>&lt;datalist&gt;</code> 输入框可选值列表</li>\n</ul>\n</li>\n<li><code>&lt;img&gt;</code> 图像</li>\n<li><code>&lt;map&gt;</code> 图像区域映射<ul>\n<li><code>&lt;area&gt;</code> 定义区域位置和映射目标地址</li>\n</ul>\n</li>\n<li><code>&lt;figure&gt;</code>标记文档中的媒体内容<ul>\n<li><code>&lt;figcaption&gt;</code>媒体的标题，常用于媒体标签的上面或者下面</li>\n</ul>\n</li>\n<li><code>&lt;button&gt;</code> 按钮</li>\n<li><code>&lt;from&gt;</code> 表单<ul>\n<li><code>&lt;fieldset&gt;</code> 表单边框<ul>\n<li><code>&lt;legend&gt;</code>表单边框描述，内容标题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>&lt;video&gt;</code> 视频</li>\n<li><code>&lt;audio&gt;</code> 音频<ul>\n<li><code>&lt;source&gt;</code> 数据源和媒体类型说明，添加多个备用</li>\n</ul>\n</li>\n<li><code>&lt;table&gt;</code> 表格<ul>\n<li><code>&lt;col&gt;</code> 配合 <code>&lt;colgroup&gt;</code>为列添加属性</li>\n<li><code>&lt;caption&gt;</code> 表格标题</li>\n<li><code>&lt;tbody&gt;</code> 表格主体</li>\n<li><code>&lt;td&gt;</code>表格单元</li>\n<li><code>&lt;th&gt;</code> 表头单元格</li>\n<li><code>&lt;tfoot&gt;</code>表格脚注</li>\n<li>...</li>\n</ul>\n</li>\n<li><code>&lt;address&gt;</code> 定义作者地址信息</li>\n<li><code>&lt;ul&gt;, &lt;ol&gt;</code> 有序和无序列表<ul>\n<li><code>&lt;li&gt;</code> 列表项</li>\n</ul>\n</li>\n<li><code>&lt;dl&gt;</code> 定义列表，增加列表的灵活性<ul>\n<li><code>&lt;dt&gt;</code> 定义列表标题</li>\n<li><code>&lt;dd&gt;</code> 定义描述，通常在标题下方，并且具有缩进</li>\n</ul>\n</li>\n<li><code>&lt;del&gt;</code> 被删除的文本</li>\n<li><code>&lt;ins&gt;</code> 默认下划线，定义插入的行内文本</li>\n<li><code>&lt;details&gt;</code> 默认不展开的内容隐藏<ul>\n<li><code>&lt;summary&gt;</code> details 默认显示的描述信息，不支持<code>IE</code></li>\n</ul>\n</li>\n<li><code>&lt;header&gt;</code> 正文中的标题</li>\n<li><code>&lt;nav&gt;</code>旨在封装一组链接，常用于导航栏</li>\n<li><code>&lt;footer&gt;</code> 页脚内容</li>\n<li><code>&lt;main&gt;</code> 正文主体核心内容区域</li>\n<li><code>&lt;article&gt;</code> 文章容器</li>\n<li><code>&lt;section&gt;</code> 相关性内容，比如章节、页眉、页脚或文档中的其他部分。</li>\n<li><code>&lt;aside&gt;</code> 表示与它周围文本没有密切关系的内容，通常的广告区域、搜索、分享链接。</li>\n<li><code>&lt;canvas&gt;</code> canvas 图像容器</li>\n<li><code>&lt;embed&gt;</code> 嵌入页面的元素，外部应用，互动插件等等，本意是不属于当前页面的内容，使用时指定外部资源类型。</li>\n<li><code>&lt;diakig&gt;</code> 对话框，支持性很差</li>\n<li><code>&lt;mark&gt;</code> 类似<code>strong</code>，H5 属性且更为通用</li>\n<li><code>&lt;meter&gt;</code>给定的数据范围度量，需要制定相关属性</li>\n<li><code>&lt;output&gt;</code>表示输出结果的行内元素</li>\n<li><code>&lt;time&gt;</code>标注时间</li>\n<li><code>&lt;datetime&gt;</code>标注日期</li>\n<li><code>&lt;progress&gt; </code>进度条</li>\n<li><code>&lt;select&gt;</code> 下拉列表<ul>\n<li><code>&lt;optgroup&gt;</code> 可选组选项<ul>\n<li><code>&lt;option&gt;</code> 选项</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>所有<code>HTML</code>短语标签如下：</p>\n<table>\n<thead>\n<tr>\n<th><em></th>\n<th>呈现为被强调的文本。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong></td>\n<td>定义重要的文本。</td>\n</tr>\n<tr>\n<td><dfn></td>\n<td>定义一个定义项目。</td>\n</tr>\n<tr>\n<td><code></td>\n<td>定义计算机代码文本。</td>\n</tr>\n<tr>\n<td><samp></td>\n<td>定义样本文本。</td>\n</tr>\n<tr>\n<td><kbd></td>\n<td>定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。</td>\n</tr>\n<tr>\n<td><var></td>\n<td>定义变量。您可以将此标签与 <code>&lt;pre&gt;</code> 及 <code>&lt;code&gt;</code> 标签配合使用。</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-html-和语义化有何意义\">3. HTML 和语义化有何意义</h3>\n<p>我们知道，<code>HTML</code>标签都具有独特的语义，使用合适的标签来组织整体的结构却不是开发者“必须”去做的一件事，在很多情况下，开发者混用不适宜的标签去达到相同的效果屡见不鲜。</p>\n<p>清晰的语义能带来良好的页面结构，并且非常有利于搜索引擎和网络爬虫解析页面内容，大大提高页面内容的识别准确性，优化<code>SEO</code>让页面得到更好的传播和搜索权重。</p>\n<h3 id=\"4-谈谈-html-中的语法错误问题\">4. 谈谈 HTML 中的语法错误问题</h3>\n<p>HTML 的语法错误的处理措施非常宽松，某种程度上 HTML 语法的灵活性让错误的语法产生了不完整的行为。</p>\n<p><code>HTML</code>的语法错误在浏览器中是可以被允许的，不良的语法结构将导致 DOM 语法树的结构不够直观。</p>\n<p>来看看如下语法结构：</p>\n<pre><code class=\"language-html\">&lt;p&gt;\n  &lt;i\n    &gt;She dreamt.\n    &lt;p&gt;\n      &lt;i\n        &gt;She dreamt that she ate breakfast.\n        &lt;p&gt;\n          &lt;i\n            &gt;Then lunch.\n            &lt;p&gt;&lt;i&gt;And finally dinner.&lt;/i&gt;&lt;/p&gt;&lt;/i\n          &gt;\n        &lt;/p&gt;&lt;/i\n      &gt;\n    &lt;/p&gt;&lt;/i\n  &gt;\n&lt;/p&gt;\n</code></pre>\n<p>浏览器通过解析器解析此结构最终在 DOM 语法树中的结果如下：</p>\n<p><img src=\"https://i.loli.net/2021/05/26/bfOFlSEG73CZqLn.png\" alt=\"image-20210526223813242\"></p>\n<p>也许这与我们的期望相去甚远，原来两层的语法树却形成了多层的嵌套结构，我们可以从中看出几个语法错误的特点：</p>\n<ul>\n<li>HTML 的语法非常宽松，语法错误是可以被允许和正常解析的</li>\n<li>错误的语法将在解析后产生意想不到的 DOM 结构，并且很有可能降低性能</li>\n</ul>\n<h3 id=\"5-简单谈谈你对于-html-元标签的理解\">5. 简单谈谈你对于 HTML 元标签的理解</h3>\n<p><code>HTML</code>文档信息可以在其<code>head</code>标签内使用<code>meta</code>标签进行补充说明，一般的形式是以<code>key/value</code>键值对为结构描述关于文档的额外说明。</p>\n<p><code>&lt;meta&gt;</code>不支持嵌套，没有闭合标签，其内容不会再页面显示，通常我们会增加一些额外信息描述，这往往有利于搜索引擎和提高<code>SEO</code>效率，对于机器是可读的</p>\n<p><code>meta</code>的有效属性包含以下四个：</p>\n<ul>\n<li><code>name</code> 属性名</li>\n<li><code>content</code>属性值</li>\n<li><code>scheme</code> 指定<code>content</code>的格式，但<code>H5</code>不支持</li>\n<li><code>http-equiv</code> 把<code>content</code>关联到<code>HTTP</code>头部，例如控制页面刷新时间，设置字符集类型和文档类型</li>\n<li><code>charset</code> 字符集</li>\n</ul>\n<p>以下是我们日常工作中可能会用到的键值对数据，。</p>\n<pre><code class=\"language-html\">&lt;head&gt;\n  &lt;meta name=&quot;description&quot; content=&quot;博客&quot; /&gt;\n  &lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,XML,JavaScript&quot; /&gt;\n  &lt;meta name=&quot;author&quot; content=&quot;someone&quot; /&gt;\n  &lt;meta name=&quot;revised&quot; content=&quot;Tutorialspoint, 5/27/2021&quot; /&gt;\n  &lt;meta charset=&quot;UTF-8&quot; /&gt;\n  &lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url = https://www.google.com&quot; /&gt;\n&lt;/head&gt;\n</code></pre>\n<h3 id=\"6-html-无障碍方面有何了解\">6. HTML 无障碍方面有何了解</h3>\n<p>无障碍设计的目标是让健全或者残疾人，年轻人或老年人都可以平等，便捷地获取站点的服务，增加受益群体。</p>\n<p>通常，最大的受益人群是不擅长访问互联网的普通人或者视力障碍用户，甚至是听力、精神、肢体障碍用户。</p>\n<p><code>W3C</code>推动了无障碍化实施规范，主要的辅助即使包括硬件放大镜或者软件放大镜，盲文显示器和读屏软件等。</p>\n<p>在开发的时候，可以采用可读性高的设计方案，甚至是对比度高的字体和图片等。另外，编写语义化的<code>HTML</code>将会对屏幕阅读器非常友好。</p>\n<p>在时间充分的情况下，建议遵循<code>WAI-ARIA</code>规范或者<a href=\"http://www-03.ibm.com/able/guidelines/web/accessweb.html\">IBM 无障碍化网站开发检查项(IBM Web accessibility checklist – Version 5.2 )</a>进行开发。</p>\n<p>在测试的时候，可以使用<code>webking</code>静态检测工具进行测试。</p>\n<h3 id=\"7-关于-html-注释的知识点\">7. 关于 HTML 注释的知识点</h3>\n<p>对于任何语言来说，注释都是很有必要的，在浏览器中注释将会被忽略，但是对于复杂的页面来说，必要的注释能让阅读源码的人提高阅读效率。</p>\n<p><code>HTML</code>使用<code>&lt;!-- ... --&gt;</code>作为注释标签（注意，边界不能有多余的空格，否则注释将被视为普通字符串），注释可以跨行。</p>\n<p>还有一种注释被称为条件注释：<code>&lt;!--[if IE 8]&gt; ... &lt;![endif]--&gt;</code>，这种注释在<code>IE</code>中能被有效识别，在其他浏览器中被忽略，因此尝尝被用于为<code>IE</code>浏览器设置兼容性属性。</p>\n<blockquote>\n<p><code>&lt;comment&gt;</code>标签内部也可以被视为注释（IE 浏览器有效），但是在<code>HTML5</code>中已经无效</p>\n</blockquote>\n<p>在一些旧浏览器中，依然支持如下两种注释：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Commenting Style Sheets&lt;/title&gt;\n    &lt;style&gt;\n      &lt;!-- .example {\n        border: 1px solid #4a7d49;\n      }\n      //--&gt;\n    &lt;/style&gt;\n    &lt;script&gt;\n      &lt;!--\n      document.write(&quot;Hello World!&quot;);\n      //--&gt;\n    &lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div class=&quot;example&quot;&gt;Hello , World!&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>但是在现代浏览器中，上述<code>JS</code>和<code>CSS</code>部分注释都无效。</p>\n<h3 id=\"8-对于-img-标签的理解\">8. 对于 img 标签的理解</h3>\n<p><code>img</code>标签必须设置<code>src</code>和<code>alt</code>属性，添加具有实际意义的<code>alt</code>属性可以让页面更友好。</p>\n<p><code>img</code>是替换内联元素，可以理解为<code>inline-block</code>。</p>\n<p>可以提前为<code>img</code>标签添加<code>width</code>和<code>height</code>属性值和对齐方向属性<code>align</code>(H5 已弃用)，如此一来在加载过程中也能具有稳定的宽高显示，从而保证页面的稳定。如果要实现固定的宽高比，自适应宽高比，则可以预设宽高值之一为固定值，另一个为<code>auto</code>。</p>\n<blockquote>\n<p><code>img</code>此类自闭合标签是无法在内部嵌套子元素的，因此也就没法使用伪类<code>::before</code>和<code>::after</code></p>\n</blockquote>\n<p><code>img</code>标签的事件监听如下：</p>\n<ul>\n<li><code>onload</code>: 图像顺利加载完成</li>\n<li><code>onerror</code>: 图像资源 404、403、500、请求超时或者返回的资源不是有效的图片</li>\n<li><code>onabort</code>: 图像加载被强制停止，例如主动点击浏览器<code>stop</code>按钮</li>\n</ul>\n<p><code>HTML5</code>的趋势之一，就是减少元素标签的属性值，关于样式的部分尽可能使用<code>CSS</code>文件来描述。</p>\n<p>另外，<code>img</code>支持<code>usemap</code>属性，配合<code>map</code>标签内嵌<code>area</code>可以实现点击图片不同区域跳转到不同的目标区域或者地址的功能。</p>\n<h3 id=\"9-列举几个-html-最佳实践\">9. 列举几个 HTML 最佳实践</h3>\n<ul>\n<li>编写有效可读的<code>DOM</code><ul>\n<li>全部小写</li>\n<li>保持缩进</li>\n<li>自动关闭标签</li>\n<li>避免过渡注释</li>\n<li>组织<code>DOM</code>，尽量减少元素</li>\n</ul>\n</li>\n<li>尽量不使用内联样式和内联脚本，内联的样式必须是关键样式（渲染页面顶部所需的最小 CSS 集）</li>\n<li>将脚本标签放在 body 底部</li>\n<li>照顾无障碍用户，使用意义明确的标签和描述性属性值</li>\n<li>正确使用 title 和 meta 标签，增强<code>SEO</code></li>\n<li>压缩文件和使用<code>CDN</code>加速</li>\n<li>对数据交互进行验证，永远不要相信用户的输入，提高应用的安全性</li>\n</ul>\n<h3 id=\"10-谈谈你所理解的-table-标签\">10. 谈谈你所理解的 table 标签</h3>\n<p>曾经开发者们使用表格进行布局，现在<code>table</code>标签更纯粹了，绝大多数用来展示表格数据。</p>\n<p>表格允许开发者们将图片、图像、链接等数据排列到单元格的行和列中。</p>\n<p>一个表格标签，内部嵌套着行盒子<code>tr</code>(table row)和单元格<code>td</code>。如果有必要，可以添加一行<code>th</code>表格列标题。</p>\n<p>甚至是使用<code>thead</code>、<code>tbody</code>、<code>tfoot</code>将整体结构拆开：</p>\n<pre><code class=\"language-html\">&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Month&lt;/th&gt;\n      &lt;th&gt;Savings&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;January&lt;/td&gt;\n      &lt;td&gt;$100&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;February&lt;/td&gt;\n      &lt;td&gt;$80&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n  &lt;tfoot&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Sum&lt;/td&gt;\n      &lt;td&gt;$180&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tfoot&gt;\n&lt;/table&gt;\n</code></pre>\n<p>表格标签支持多属性控制样式，但是推荐使用<code>CSS</code>控制样式。</p>\n<h3 id=\"11-关于列表\">11. 关于列表</h3>\n<p>列表分为三种：</p>\n<ul>\n<li>有序列表 <code>ol</code></li>\n<li>无序列表<code>ul</code></li>\n<li>自定义列表 <code>dl</code></li>\n</ul>\n<p>而非自定义列表项则统一使用<code>li</code>,列表可以使用类型属性<code>type</code>和排序起始属性<code>start</code>控制列表项前面的标志。</p>\n<p>自定义列表则使用<code>dt</code>作为列表标题，<code>dd</code>作为列表项，且默认存在缩进。</p>\n<p>如果需要对列表前的类型样式做修改，则可以使用<code>list-style-type</code>设置浏览器默认支持的几个元素。</p>\n<p>如果需要自定义样式，则可以配合伪类<code>::marker</code>使用。</p>\n<p>甚至只要是<code>display: list-item</code>且可内嵌子元素的标签，都支持左边自定义一个显示顺序内容，合理使用<code>counter()</code>可以为多个项设置计算后的顺序前缀内容，这对于创建菜单序号和级联序号非常有用。</p>\n<h3 id=\"12-超链接\">12. 超链接</h3>\n<p>超链接可以在用户点击链接后进行当前页面跳转或打开新的标签页进行跳转，为用户提供不同站点之间的导航功能，开发者可以通过<code>a</code>标签创建超链接，点击超链接后的行为取决于 <code>a</code>标签的<code>target</code>属性值。</p>\n<p>可以为<code>target</code>设置以下几个不同属性值：</p>\n<ul>\n<li><code>_blank</code>：在新的浏览器标签页打开链接的地址</li>\n<li><code>_self</code>：在相同的<code>frame</code>内打开链接地址（默认值）</li>\n<li><code>_parent</code>：在父级<code>frame</code>打开链接地址</li>\n<li><code>_top</code>：在当前标签顶层<code>body</code>下打开链接地址（chrome 将会提示离开当前页面）</li>\n<li><code>targetframe</code>：在目标<code>frame</code>内打开链接地址</li>\n</ul>\n<p>除了作为导航外，还可以实现下载功能：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;large.jpg&quot; download&gt;下载&lt;/a&gt;\n</code></pre>\n<blockquote>\n<p>IE 不支持<code>dowload</code>属性</p>\n</blockquote>\n<p>提供一个<code>download</code>属性让浏览器处理下载功能，并且可以为<code>download</code>属性提供值作为下载的文件名。</p>\n<p>但是此方案在跨域场景下各厂家实现区别很大，因此不同源的方案不如使用<code>download.js</code>这个第三方库。</p>\n<p>另外，我们在使用邮件类型的地址的时候，需要为<code>href</code>属性值之前添加协议类型：<code>mailto:</code>，例如：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;mailto: abc@example.com&quot;&gt;Send Email&lt;/a&gt;\n</code></pre>\n<p>浏览器对此链接的点击行为做出反应，调用默认的邮件处理程序预置目标邮件地址，并且可以在<code>mail</code>地址后添加参数，邮件处理程序会解析类似<code>主题</code>或<code>body</code>的预置内容。</p>\n<h3 id=\"13-frames\">13. Frames</h3>\n<p>浏览器可以通过创建不同的<code>Frame</code>分割视图区域，并且每个<code>Frame</code>有单独的<code>HTML</code>结构，浏览器标签所有的<code>Frame</code>的集合被称为<code>frameset</code>。</p>\n<blockquote>\n<p><code>frameset</code>代替<code>body</code>标签，定义页面的行与列的布局。</p>\n</blockquote>\n<p>这种技术的缺点也很明显：</p>\n<ul>\n<li>小屏幕设备显示功能效果不好，难以让分割视图的特性发挥效果。</li>\n<li>不同分辨率的终端显示效果可能不同</li>\n<li>浏览器的返回按钮可能会出乎意料，甚至无法实现用户想要的效果</li>\n<li>少数浏览器不支持此标签</li>\n<li>跨<code>Frame</code>通信较为复杂</li>\n</ul>\n<p>示例:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;HTML Frames&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;\n    &lt;frame name=&quot;left&quot; src=&quot;https://www.baidu.com&quot; /&gt;\n    &lt;frame name=&quot;center&quot; src=&quot;https://www.baidu.com&quot; /&gt;\n    &lt;frame name=&quot;right&quot; src=&quot;https://www.baidu.com&quot; /&gt;\n\n    &lt;noframes&gt;\n      &lt;body&gt;\n        Your browser does not support frames.\n      &lt;/body&gt;\n    &lt;/noframes&gt;\n  &lt;/frameset&gt;\n&lt;/html&gt;\n</code></pre>\n<p>还有一个标签：<code>iframe</code>也是提供一个内嵌的<code>frame</code>功能，不过它可以脱离<code>frameset</code>使用，更具有灵活性。</p>\n<p>这种技术的应用较为少见，请谨慎使用（笔者在广告功能中常能见到其踪影）。</p>\n<h3 id=\"14-字体滚动\">14. 字体滚动</h3>\n<p><code>marquee</code>的兼容性良好，但是此元素已经不再推荐使用，规范随时可能删除此标签，开发者们更应该通过<code>CSS</code>动画来实现文字滚动。</p>\n<h3 id=\"15-html-通用属性\">15. HTML 通用属性</h3>\n<blockquote>\n<p>在 base、head、html、meta、param、script、style、title 元素上无效</p>\n</blockquote>\n<p>H5 之前有五个除了上述几个元素外其他所有元素共有的可用属性：</p>\n<ul>\n<li>class</li>\n<li>id</li>\n<li>style</li>\n<li>title</li>\n<li>tabindex</li>\n<li>accesskey</li>\n</ul>\n<p>前四者较为常用，后两者却容易被忽视。<code>tabindex</code>属性用于获取或指定当前元素的<code>tab</code>键激活顺序，其值范围为：<code>0~32767</code>。</p>\n<p>如果不设置，则默认值是 0，并且按出现顺序进行跳转，但是可以设置值为<code>-1</code>，使得元素不能被<code>TAB</code>键访问，如果某些元素是隐藏的，在其未显示之前不应该被<code>TAB</code>键访问到，因此可以设置<code>tabindex=-1</code>。</p>\n<blockquote>\n<p>如果为<code>div</code>设置了<code>tabindex</code>，则其内部嵌套的元素如果没有设置<code>tabindex</code>，则无法通过方向键跳转。</p>\n</blockquote>\n<p>如果针对某些元素设置了<code>tabindex</code>，则<code>tab</code>键将从大到小进行跳转，慎用此特性以免给惯用快捷键访问的用户造成困扰，但如果良好地设计<code>tabindex</code>，则可以提供良好的无障碍访问功能。</p>\n<p>同样的，<code>accesskey</code>也容易被人忽略，即使其功能强大。</p>\n<p>我们可以为元素设置<code>accesskey</code>的值，然后通过不同系统的浏览器快捷键+此属性的值进行快速访问。</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/image-20210616060934949.png\" alt=\"image-20210616060934949\"></p>\n<blockquote>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2017/05/html-accesskey/comment-page-1/#comment-414139\">HTML accesskey 属性与 web 自定义键盘快捷访问 « 张鑫旭-鑫空间-鑫生活</a></p>\n</blockquote>\n<p>如果你喜欢<code>vimium</code>的功能，我猜这个属性的功能能够让你很开心。但是很多应用都没有使用到这个属性，这是无障碍访问功能的一部分，常常被人忽视，使其看起来犹如屠龙之技。</p>\n<p>并且不同浏览器之间快捷键不同，对于元素的交互行为也不一样，这两个缺陷使其应用性大打折扣。浏览器快捷键和操作系统之间的影响可以从上图中看出端倪，而行为上的不一致，最简明的例子就是<code>IE</code>浏览器和<code>chrome</code>浏览器之间对<code>&lt;a&gt;</code>元素的行为不一致。前者只是让其获得焦点，后者却可以触发点击行为。</p>\n<p><a href=\"https://www.npmjs.com/package/accesskey\">accesskey - npm</a>这里有一个支持增强<code>accesskey</code>功能和处理一致性行为的第三方库，或许以后用得上。</p>\n<blockquote>\n<p>不过话说回来，这个属性提醒了我可以在<code>electron</code>技术上使用这个功能，这样就可以减少使用系统快捷键绑定的逻辑代码。</p>\n</blockquote>\n<p><code>HTML5</code>版本出来之后，新增了部分全局属性：</p>\n<ul>\n<li>contenteditable：是否可编辑</li>\n<li>Data-*：自定义的元素数据存储，可以配合<code>JavaScript</code>或者<code>CSS</code>属性选择器使用</li>\n<li>draggable：实验中的属性，是否可以拖动</li>\n<li>dropzone：较为少见的属性，不如使用此名第三方库（<a href=\"https://github.com/dropzone/dropzone\">dropzone/dropzone: Dropzone is an easy to use drag'n'drop library. It supports image previews and shows nice progress bars.</a>）</li>\n<li>hidden：常用</li>\n<li>spellcheck：拼写检查，也是实验中的功能</li>\n</ul>\n<h3 id=\"16-字体知识\">16. 字体知识</h3>\n<p>字体是相对于操作系统而言的，不同操作系统默认支持某些特定的字体，因此在样式表中我们可以指定多种字体以支持不同的操作系统，如果没有指定字体，则使用系统默认的字体。</p>\n<p>CSS 定义了 5 个常用的字体名称: <code>serif, ``sans-serif, ``monospace</code>, <code>cursive,</code>和 <code>fantasy. </code>这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。</p>\n<p>示例样式如下：</p>\n<pre><code class=\"language-css\">p {\n  font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif;\n}\n</code></pre>\n<p>提供了三种字体，前面的优先，如果系统不支持此字体则一次往后递增，最后使用默认字体。</p>\n<p>我们可以使用<code>@font-face</code>自定义字体：</p>\n<pre><code class=\"language-css\">@font-face {\n    font-family: &lt;fontFamily&gt;; /* 自定义的字体名称; */\n    src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;  /* 自定义的字体的存放路径、格式; */\n    [font-weight: &lt;weight&gt;]; /*  是否为粗体 */\n    [font-style: &lt;style&gt;]; /*  定义字体样式，如斜体 */\n}\n</code></pre>\n<p>字体具有不同的格式，源文件格式可能会是：</p>\n<ul>\n<li>.tff</li>\n<li>.otf</li>\n</ul>\n<p>前者字体格式值为<code>TrueType</code>，后者为<code>OpenType</code>，甚至还有：</p>\n<ul>\n<li>Embedded Open Type (.eot)</li>\n<li>Web Open Font Format (.woff)</li>\n</ul>\n<p>为了保证兼容性，可以同时提供多种自定义字体：</p>\n<pre><code class=\"language-css\">@font-face {\n  font-family: &quot;myFont&quot;;\n  src: url(&quot;myFont.eot&quot;); /* IE9 Compat Modes */\n  src: url(&quot;myFont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), /* IE6-IE8 */\n      url(&quot;myFont.woff&quot;) format(&quot;woff&quot;); /* Modern Browsers */\n}\n</code></pre>\n<p>自定义字体的另一个广泛使用案例：<code>图标字体</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/image-20210618003909597.png\" alt=\"image-20210618003909597\"></p>\n<p>图标字体可以很方便的配合伪类使用，并且非常灵活，开发者可以轻松修改其颜色和大小等。另外，兼容性很好，在某些需要兼容<code>IE</code>的项目中可以放心使用。</p>\n<p>使用图标字体还有以下几个优点：</p>\n<ul>\n<li>轻松替换</li>\n<li>不会失真</li>\n<li>便捷，可压缩</li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397545704",
            "title": "HTML浅解",
            "summary": "​ 作为一个 web 开发者，我们需要掌握的 HTML 知识到底应该有多少？HTML 真的如此简单吗，我们是否应该给与其更多的重视？",
            "date_modified": "2022-10-05T10:01:26.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397544441",
            "content_html": "<p>一年一度的ECMAScript规范发布，看看今年有什么新内容！</p>\n<h2 id=\"前言\">前言</h2>\n<p><code>ECMAScript</code> 是标准化的 <code>JavaScript</code> 语言，于 1997 年发布了第一版，现已发展成为世界上使用最广泛的通用编程语言之一。</p>\n<p><code>ECMAScript 2022 Language</code>是 ECMAScript 语言规范的第 13 版，因此我们也可以称之为<code>ES13</code>!</p>\n<p>那么，今年新增了哪些内容呢？</p>\n<h3 id=\"类增强\">类增强</h3>\n<p>简单来说有以下三点：</p>\n<ul>\n<li>属性可以通过以下方式创建<ul>\n<li>公共的实例字段</li>\n<li>静态的公共字段</li>\n</ul>\n</li>\n<li>新增私属性插槽（井号）<ul>\n<li>私有字段（私有实例字段和私有静态字段）</li>\n<li>私有方法和访问器（非静态）</li>\n</ul>\n</li>\n<li>静态的初始化块</li>\n</ul>\n<p>直接看代码：</p>\n<pre><code class=\"language-js\">class MyClass {\n  instancePublicField = 1; // 公共实例字段\n  static staticPublicField = 2; // 静态公共字段\n\n  #instancePrivateField = 3; // 私有实例字段\n  static #staticPrivateField = 4; // 静态私有字段\n\n  #nonStaticPrivateMethod() {}\n  get #nonStaticPrivateAccessor() {} // 非静态私有访问器\n  set #nonStaticPrivateAccessor(value) {}\n\n  static #staticPrivateMethod() {} // 私有静态方法\n  static get #staticPrivateAccessor() {} // 静态访问器\n  static set #staticPrivateAccessor(value) {}\n\n  static {\n    // 静态的初始化块\n  }\n\n    constructor(value) {\n    this.property = value; // 公共实例字段\n  }\n}\n</code></pre>\n<p>举一个静态初始化块的例子：</p>\n<pre><code class=\"language-js\">class Translator {\n  static translations = {\n    yes: &#39;ja&#39;,\n    no: &#39;nein&#39;,\n    maybe: &#39;vielleicht&#39;,\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static { // (A)\n    for (const [english, german] of Object.entries(this.translations)) {\n      this.englishWords.push(english);\n      this.germanWords.push(german);\n    }\n  }\n}\n</code></pre>\n<p>通过使用静态初始化块，我们可以将所有类相关的代码放在类的内部。</p>\n<p>上述例子中，可以将初始化两个<code>word</code>数组的过程优化到静态初始化块内部，从而实现我们需要的效果，如果需要还可以访问私有插槽属性。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>一个类可以有多个静态初始化块</li>\n<li>静态初始化块和静态属性可以交错初始化</li>\n<li>超类（superclass）的静态初始化块在子类的静态初始化块之前执行</li>\n</ul>\n<p>此外，类的私有化属性插槽可以通过<code>in</code>操作符检查，举个例子：</p>\n<pre><code class=\"language-js\">class ClassWithPrivateSlot {\n  #privateSlot = true;\n  static hasPrivateSlot(obj) {\n    return #privateSlot in obj;\n  }\n}\n\nconst obj1 = new ClassWithPrivateSlot();\nassert.equal(\n  ClassWithPrivateSlot.hasPrivateSlot(obj1), true\n);\n\nconst obj2 = {};\nassert.equal(\n  ClassWithPrivateSlot.hasPrivateSlot(obj2), false\n);\n</code></pre>\n<h3 id=\"顶层-await\">顶层 await</h3>\n<p>规范新增顶层<code>await</code>支持，现在我们可以直接在模块内使用顶层<code>await</code>，而不必再额外进入异步函数内再使用<code>await</code>。</p>\n<p>看实例：</p>\n<pre><code class=\"language-js\">const res = await fetch(&quot;https://jsonplaceholder.typicode.com/todos/1&quot;).then(\n  (response) =&gt; response.json()\n);\n\nconsole.log(&quot;res is:&quot;, res);\n</code></pre>\n<p>保存上述内容为文件<code>index.mjs</code>，使用<code>node v17.5</code>以上版本或<code>bunjs</code>直接运行：</p>\n<p><code>node index.mjs</code>即可直接获取到输出。</p>\n<p>那么，我们可以在什么地方使用这个特性呢？举个例子：</p>\n<pre><code class=\"language-js\">// first.mjs\nconst response = await fetch(&#39;http://example.com/first.txt&#39;);\nexport const first = await response.text();\n\n// main.mjs\nimport {first} from &#39;./first.mjs&#39;;\nimport {second} from &#39;./second.mjs&#39;;\nassert.equal(first, &#39;First!&#39;); // true\nassert.equal(second, &#39;Second!&#39;); // true\n</code></pre>\n<p>有了顶层<code>await</code>，我们可以像使用同步导出那样直接导出异步的值。</p>\n<p>大致等同于以下代码：</p>\n<p><code>first.mjs</code>:</p>\n<pre><code>export let first;\nexport const promise = (async () =&gt; { // (A)\n  const response = await fetch(&#39;http://example.com/first.txt&#39;);\n  first = await response.text();\n})();\n</code></pre>\n<p><code>main.mjs</code>:</p>\n<pre><code>import {promise as firstPromise, first} from &#39;./first.mjs&#39;;\nimport {promise as secondPromise, second} from &#39;./second.mjs&#39;;\nexport const promise = (async () =&gt; { // (B)\n  await Promise.all([firstPromise, secondPromise]); // (C)\n  assert.equal(first, &#39;First content!&#39;);\n  assert.equal(second, &#39;Second content!&#39;);\n})();\n</code></pre>\n<p>方便了不少，不是吗？</p>\n<h3 id=\"errorcause\">error.cause</h3>\n<p>为<code>Error</code>及其子类添加<code>cause</code>属性，更方便地传递错误原因，增强传递错误信息的能力。</p>\n<pre><code class=\"language-js\">function readFiles(filePaths) {\n  return filePaths.map(\n    (filePath) =&gt; {\n      try {\n        // ···\n      } catch (error) {\n        throw new Error(\n          `While processing ${filePath}`,\n          {cause: error}\n        );\n      }\n    });\n}\n</code></pre>\n<p>现在，可以访问错误对象的<code>cause</code>属性获取更多详情。</p>\n<h3 id=\"at\">.at()</h3>\n<p>就像使用<code>python</code>一样使用<code>JavaScript</code>，通过下标访问数组变得容易，具有显式的函数支持，此外跟直接使用<code>[]</code>访问不一样的是，<code>.at()</code>支持传负数参数进行逆序取值。</p>\n<h3 id=\"正则表达式flag：d\">正则表达式Flag：/d</h3>\n<p>看例子：</p>\n<pre><code class=\"language-js\">const matchObj = /(a+)(b+)/d.exec(&#39;aaaabb&#39;);\n\nassert.equal(\n  matchObj[1], &#39;aaaa&#39;\n);\nassert.deepEqual(\n  matchObj.indices[1], [0, 4] // (A)\n);\n\nassert.equal(\n  matchObj[2], &#39;bb&#39;\n);\nassert.deepEqual(\n  matchObj.indices[2], [4, 6] // (B)\n);\n</code></pre>\n<p>通过<code>d</code>执行的正则表达式匹配，可以得到匹配的元素的起始下标。</p>\n<h3 id=\"objecthasownobj-propkey\">Object.hasOwn(obj, propKey)</h3>\n<p><code>Object.hasOwn(obj, propKey)</code>提供了一种安全的方式通过属性<code>key</code>检查对象是否含有非继承的目标属性。</p>\n<pre><code class=\"language-js\">const proto = {\n  protoProp: &#39;protoProp&#39;,\n};\nconst obj = {\n  __proto__: proto,\n  objProp: &#39;objProp&#39;,\n}\n\nassert.equal(&#39;protoProp&#39; in obj, true); // (A)\n\nassert.equal(Object.hasOwn(obj, &#39;protoProp&#39;), false); // (B)\nassert.equal(Object.hasOwn(proto, &#39;protoProp&#39;), true); // (C)\n</code></pre>\n<h2 id=\"最后\">最后</h2>\n<p>众所周知：</p>\n<p><code>JavaScript</code>和<code>ECMAScript</code>的区别在于，前者是一个不同平台实现的编程语言，后者是这门语言的标准规范，平台基于此规范实现这门语言。</p>\n<p><code>ECMAScript</code>由<code>TC39</code>标准委员会设计，其成员来自各大科技公司和其他平台等等，每年都会在年中发布最新的规范。</p>\n<p>不同的提案经过四个阶段，最终才会进入规范，在进入规范之前不建议使用，因为其始终是不稳定的，关注每年的新增内容即可。</p>\n",
            "url": "http://localhost:3000/blog/1397544441",
            "title": "ECMAScript 2022新规范",
            "summary": "一年一度的ECMAScript规范发布，看看今年有什么新内容！",
            "date_modified": "2022-10-05T10:00:52.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397543780",
            "content_html": "<p>前端工程化中，使用 babel 对新语法和 API 预置 polyfill 是非常流行的做法之一，但之前笔者对这个过程和其中使用到的插件不够了解，因此在网上搜寻了一些博客和知识分享，学习一番，再次总结一下。</p>\n<h2 id=\"前言\">前言</h2>\n<p>本文将对<code>babel7</code>的语法转换和<code>polyfill</code>的相关知识进行分析，主要内容为<code>@babel/preset-env</code>和<code>plugin-transform-runtime</code>，Babel 7.4 之后不再推荐使用<code>@babel/polyfill</code>。</p>\n<h2 id=\"preset-env\">Preset-env</h2>\n<blockquote>\n<p>Preset-env 会污染全局环境。</p>\n</blockquote>\n<p>babel 7 版本推荐使用<code>@babel/preset-env</code>代替以往的诸多<code>polyfill</code>方案，现今我们可以使用<code>preset-env</code>简单地实现语法和功能特性的需求。</p>\n<blockquote>\n<p>@babel/preset-env is a smart preset that allows you to use the latest JavaScript without needing to micromanage which syntax transforms (and optionally, browser polyfills) are needed by your target environment(s).</p>\n</blockquote>\n<p>可知，<code>preset-env</code>可以转换新语法，甚至可以配置转换新的<code>API</code>，通过配置其可选项来实现功能支持。</p>\n<p><code>@babel/preset-env</code>有三个常用的关键可选项:</p>\n<ul>\n<li><p>targets</p>\n</li>\n<li><p>useBuiltIns</p>\n</li>\n<li><p>corejs</p>\n</li>\n</ul>\n<h3 id=\"target\">target</h3>\n<p>首先是<code>targets</code>，这个字段可以填写<code>browserslist</code>的查询字符串，官方推荐使用<code>.browserslistrc</code>文件去指明编译的<code>target</code>，这个配置文件还可以和<code>autoprefixer</code>、<code>stylelint</code>等工具一起共享配置。</p>\n<p>所以某种程度上不推荐在<code>.babelrc</code>的<code>preset-env</code>配置中直接使用<code>targets</code>进行配置。</p>\n<blockquote>\n<p>如果<code>preset-env</code>中指明<code>ignoreBrowserslistConfig</code>，则忽略<code>.browserslistrc</code>的配置项。</p>\n</blockquote>\n<h3 id=\"usebuiltins\">useBuiltIns</h3>\n<p>其次是用于指定<code>polyfill</code>方案的<code>useBuiltIns</code>，其默认值是<code>false</code>，在不主动<code>import</code>的情况下不使用<code>preset-env</code>来实现<code>polyfills</code>，只使用其默认的语法转换功能。</p>\n<blockquote>\n<p>如果使用默认值<code>false</code>，则应该避免在入口文件引入<code>polyfill</code>，使得打包体积过大。</p>\n</blockquote>\n<p>但是如果我们需要使用其<code>polyfill</code>功能，则可以选择两种方式：</p>\n<ul>\n<li>entry</li>\n<li>usage</li>\n</ul>\n<p><code>entry</code>指的是将会根据浏览器目标环境(<code>targets</code>)的配置，引入全部浏览器暂未支持的<code>polyfill</code>模块，无论在项目中是否使用到。</p>\n<p>先安装两个包：</p>\n<pre><code class=\"language-bash\">yarn add core-js@3 regenerator-runtime\n</code></pre>\n<p>我们需要做的就是在入口处引入<code>polyfill</code>（或者在 webpack 配置文件中新增这两个包作为额外的入口）:</p>\n<pre><code class=\"language-js\">import &quot;core-js/stable&quot;;\nimport &quot;regenerator-runtime/runtime&quot;;\n</code></pre>\n<p>对于项目开发来说，这种方案较为稳妥。尽管将浏览器暂不支持的模块全部引入可能会让某些项目中未使用的模块占据一定的额外体积，但是可以避免项目中引入的第三方库<code>polyfill</code>处理不当，导致引用异常。</p>\n<p>其次，设置<code>useBuiltIns</code>的值为<code>usage</code>时，我们不需要手动在入口文件引入<code>polyfill</code>，<code>Babel</code>将会根据我们的代码使用情况自动注入<code>polyfill</code>，如此一来在打包的时候将会相对地减少打包体积。</p>\n<p><code>唯一的问题</code>:当项目中引入的第三方库有<code>polyfill</code>处理不当的情况下，将会出现引用异常的问题，使用社区广泛使用的流行库能降低这个风险。</p>\n<h3 id=\"corejs\">corejs</h3>\n<p>core-js 是完全模块化的 javascript 标准库。</p>\n<p>推荐让浏览器的<code>polyfill</code>统一由<code>corejs</code>来管理。</p>\n<blockquote>\n<p>core-js v2 已经不再维护，推荐一致使用 v3 版本</p>\n</blockquote>\n<p>我们来看一个使用<code>entry</code>的整体<code>preset-env</code>配置示例：</p>\n<pre><code class=\"language-js\">// .babelrc\n{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      {\n        &quot;targets&quot;: {\n          &quot;chrome&quot;: &quot;80&quot; // 推荐使用 .browserslistrc\n        },\n        &quot;useBuiltIns&quot;: &quot;entry&quot;,\n        &quot;corejs&quot;: {\n          &quot;version&quot;: 3, // 2 和 3 版本都需要手动安装库：yarn add core-js@3\n          &quot;proposals&quot;: false\n        }\n      }\n    ]\n  ],\n  &quot;plugins&quot;: []\n}\n</code></pre>\n<blockquote>\n<p>笔者个人而言，不推荐使用 proposals 功能，只使用最新规范中的特性。</p>\n</blockquote>\n<p>之后再在入口文件手动引入<code>polyfill</code>:</p>\n<pre><code class=\"language-js\">import &quot;core-js/stable&quot;;\nimport &quot;regenerator-runtime/runtime&quot;;\n// other code\n</code></pre>\n<h2 id=\"plugin-transform-runtime\">Plugin-transform-runtime</h2>\n<p>使用之前请安装库:</p>\n<pre><code class=\"language-bash\">yarn add @babel/runtime //默认 corejs为 false，如果使用 core-js v3 的 runtime，则需要安装 @babel/runtime-corejs3\nyarn add -D babel-plugin-transform-runtime\n</code></pre>\n<p>之前提过<code>preset-env</code>的<code>polyfill</code>会污染全局，作为项目开发无可厚非，但是如果我们在开发提供给其他开发者使用的<code>library</code>，我想我们不应该污染全局，并且应该提供更好的打包体积和效率。</p>\n<blockquote>\n<p>A plugin that enables the re-use of Babel&#39;s injected helper code to save on codesize.</p>\n</blockquote>\n<p><code>plugin-transform-runtime</code>可以主要做了三件事：</p>\n<ul>\n<li>当开发者使用异步或生成器的时候，自动引入<code>@babel/runtime/regenerator</code>，开发者不必在入口文件做额外引入</li>\n<li>提供沙盒环境，避免全局环境的污染</li>\n<li>移除<code>babel</code>内联的<code>helpers</code>，统一使用<code>@babel/runtime/helpers</code>代替，减小打包体积</li>\n</ul>\n<p>当使用此方案时，不需要在入口文件处手动引入<code>core-js</code>和<code>regenerator-runtime</code>。详细的配置项建议在需要用的时候查看官方文档。</p>\n<h2 id=\"总结\">总结</h2>\n<p><code>@babel/preset-env</code>和<code>plugin-transform-runtime</code>二者都可以设置使用<code>corejs</code>来处理<code>polyfill</code>，二者各有使用场景，在项目开发和类库开发的时候可以使用不同的配置。</p>\n<p><code>不要同时为二者配置core-js的功能</code>，以免产生复杂的不良后果。</p>\n<p>最后，让我们来看看两个场景下的<code>babel</code>配置项：</p>\n<h3 id=\"项目开发\">项目开发</h3>\n<p><code>useBuiltIns</code>使用<code>usage</code>，尽量使用社区广泛使用的优质库以优化打包体积，不使用暂未进入规范的特性。<code>plugin-transform-runtime</code>只使用其移除内联复用的辅助函数的特性，减小打包体积。</p>\n<pre><code class=\"language-js\">{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      {\n        // targets 官方推荐使用 .browserslistrc 配置\n        &quot;useBuiltIns&quot;: &quot;usage&quot;,\n        &quot;corejs&quot;: {\n          &quot;version&quot;: 3,\n          &quot;proposals&quot;: false\n        }\n      }\n    ]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel/plugin-transform-runtime&quot;,\n      {\n        &quot;corejs&quot;: false // 默认值，即使如此依然需要 yarn add @babel/runtime\n      }\n    ]\n  ]\n}\n</code></pre>\n<h3 id=\"类库开发\">类库开发</h3>\n<p>类库开发尽量不使用污染全局环境的<code>polyfill</code>，因此<code>@babel/preset-env</code>只发挥语法转换的功能，<code>polyfill</code>由<code>plugin-transform-runtime</code>来处理，推荐使用<code>core-js@3</code>，并且不使用未进入规范的特性。</p>\n<pre><code class=\"language-js\">{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n    ]\n  ],\n  &quot;plugins&quot;: [\n    [\n      &quot;@babel/plugin-transform-runtime&quot;,\n      {\n        &quot;corejs&quot;: {\n          &quot;version&quot;: 3,\n          &quot;proposals&quot;: true\n        },\n        &quot;useESModules&quot;: true\n      }\n    ]\n  ]\n}\n</code></pre>\n<p>总的来说，在配置开发环境的时候还是要参考官方文档的说明，这样才能减少出错的可能。</p>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><p><a href=\"https://babeljs.io/docs/en/babel-preset-env#usebuiltins\">@babel/preset-env · Babel</a></p>\n</li>\n<li><p><a href=\"https://babeljs.io/docs/en/babel-plugin-transform-runtime#docsNav\">@babel/plugin-transform-runtime · Babel</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/361874935\">吃一堑长一智系列: 99% 开发者没弄明白的 babel 知识</a></p>\n</li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397543780",
            "title": "Babel 7: polyfill方案浅解 ",
            "summary": "前端工程化中，使用 babel 对新语法和 API 预置 polyfill 是非常流行的做法之一，但之前笔者对这个过程和其中使用到的插件不够了解，因此在网上搜寻了一些博客和知识分享，学习一番，再次总结一下。",
            "date_modified": "2022-10-05T09:59:52.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397542082",
            "content_html": "<p>网格布局<code>(Grid)</code>被视为当前最强大的<code>CSS</code>布局方案。</p>\n<p>善用网格布局，可以轻松实现界面布局，并且具有现代浏览器良好的支持度。</p>\n<h2 id=\"1-前言\">1. 前言</h2>\n<p>我需要的布局大致如下：</p>\n<p><img src=\"https://i.loli.net/2021/06/10/GlXYwLiM4uyUIst.png\" alt=\"\"></p>\n<p>可以看到，此布局并不复杂，我们可以使用多种方式来实现它，但今天我的计划是使用<code>Grid</code>布局。</p>\n<p><code>Grid</code>布局将容器划分为“行”与“列”，产生单元格，然后指定“item”所在的单元格，因此也常被视为“二维布局”。</p>\n<h2 id=\"2-基本概念\">2. 基本概念</h2>\n<h3 id=\"21-容器和项目\">2.1 容器和项目</h3>\n<p>如名所示，最外层的元素作为容器<code>(container)</code>，内部每一个最外层的元素作为一个单独的项目<code>(item)</code>。</p>\n<pre><code class=\"language-html\">&lt;main&gt;\n  &lt;section&gt;a&lt;/section&gt;\n  &lt;section&gt;b&lt;/section&gt;\n  &lt;section&gt;c&lt;/section&gt;\n&lt;/main&gt;\n</code></pre>\n<p><code>Grid</code>布局针对<code>main</code>生效，<code>section</code>作为<code>item</code>，其内部元素与布局无关。</p>\n<h3 id=\"22-行和列\">2.2 行和列</h3>\n<p><img src=\"https://i.loli.net/2021/06/10/IFci7q2pKmdLsG6.png\" alt=\"\"></p>\n<p>我想这一张图已经非常明显地使用深色体现出行<code>(row)</code>与列<code>(column)</code>的区别，行和列是有交叉的。</p>\n<h3 id=\"23-单元格和网格线\">2.3 单元格和网格线</h3>\n<p>行列交叉的区域，我们称之为<code>Cell(单元格)</code>，如前言所示，我们将子元素放在单元格中。而深色区域，我们将之称为<code>Grid line(网格线)</code>，通常<code>n</code>行<code>m</code>列，即可产生可供布局的<code>n*m</code>个<code>Cell</code>。</p>\n<p>不要讲空白区域视为单元格，单元格始终是<code>行</code>和<code>列</code>相交产生的。</p>\n<h2 id=\"3-容器属性和项目属性\">3. 容器属性和项目属性</h2>\n<p><code>Grid</code>布局属性分为定义在<code>container</code>上的<code>容器属性</code>,定义在<code>item</code>上的<code>项目属性</code>。</p>\n<h3 id=\"31-容器属性\">3.1 容器属性</h3>\n<h4 id=\"311-display\">3.1.1 display</h4>\n<p>显示为<code>container</code>设置<code>display: grid</code>显示属性布局为<code>grid</code>。</p>\n<pre><code class=\"language-css\">div {\n  display: grid;\n}\n</code></pre>\n<p>此时，<code>container</code>是一个单独的容器，默认是块级元素，也可以设置<code>display: inline-grid</code>为行内<code>Grid</code>布局，使其整体视为一个行内块级元素。</p>\n<blockquote>\n<p>网格布局将使得子项（item）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>display: vertical-align</code>、<code>display: column-*</code>等设置失效。</p>\n</blockquote>\n<h4 id=\"312-grid-template-rows-、grid-template-columns\">3.1.2 grid-template-rows 、grid-template-columns</h4>\n<p><code>grid</code>布局除了需要显示指定布局类型为<code>grid</code>外，还需要指定行和列的值。</p>\n<p><code>grid-template-rows</code>定义行高，有多少行就提供多少个值。</p>\n<p><code>grid-template-column</code>定义列宽，同样，有多少列就提供多少个值。</p>\n<p>例如，如果我们要设置一个九宫格，则分别需要三行三列：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-rows: 100px 100px 100px;\n  grid-template-column: 100px 100px 100px;\n}\n</code></pre>\n<p>如此一来配上<code>item</code>(css 提供一些颜色值):</p>\n<pre><code class=\"language-html\">&lt;div id=&quot;container&quot;&gt;\n  &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt;\n  &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt;\n  &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt;\n  &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;\n  &lt;div class=&quot;item item-5&quot;&gt;5&lt;/div&gt;\n  &lt;div class=&quot;item item-6&quot;&gt;6&lt;/div&gt;\n  &lt;div class=&quot;item item-7&quot;&gt;7&lt;/div&gt;\n  &lt;div class=&quot;item item-8&quot;&gt;8&lt;/div&gt;\n  &lt;div class=&quot;item item-9&quot;&gt;9&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>我们可以得到一个九宫格布局：</p>\n<p><img src=\"https://i.loli.net/2021/06/10/ACZfnmovTdDsiwk.png\" alt=\"\"></p>\n<p>除了使用<code>px</code>这样的绝对单位，也可以使用百分数，甚至可以使用<code>repeat</code>类函数简化赋值：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: repeat(3, 33.33%);\n  grid-template-rows: repeat(3, 33.33%);\n}\n</code></pre>\n<p>甚至是：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: repeat(2, 100px 40px 50px);\n  grid-template-rows: 50px 50px 50px;\n}\n</code></pre>\n<p>定义了<code>100px 20px 80px 100px 20px 80px</code>，6 列宽度不一的列。</p>\n<p><img src=\"https://i.loli.net/2021/06/10/1UQYPNlAax5rodI.png\" alt=\"image-20210610012604962\"></p>\n<p>如上所示，第三行由于没有<code>item</code>，默认空白。</p>\n<p>某些场合下，我们希望容器尽可能填充每一行的<code>item</code>，可以使用<code>auto-fill</code>关键字：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, 100px);\n}\n</code></pre>\n<p><img src=\"https://i.loli.net/2021/06/10/RkMNLhud9IpliCw.png\" alt=\"image-20210610012923160\"></p>\n<p>容器根据最大宽度进行自动列填充，此时行与列的数量是根据宽度变化的。</p>\n<p>某些场合下，我们希望动态根据片段比例对行数进行判断，次数可以使用<code>fr(fraction)</code>关键字，表示列的宽度片段，例如：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: 2fr 1fr;\n}\n</code></pre>\n<p>上述示例表示，第一列宽度为整个容器宽度的<code>2/3</code>，第二列为<code>1/3</code>，一般配合绝对宽度使用可以实现很灵活的布局效果：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: 150px 1fr 2fr;\n}\n</code></pre>\n<p>上述示例，每一行先扣除第一列的<code>150px</code>宽度，剩下的再动态计算分配。也可以使用<code>auto</code>关键字，由浏览器决定长度。</p>\n<pre><code class=\"language-css\">grid-template-columns: 100px auto 100px;\n</code></pre>\n<p>网格线可以具有名字，并且可以有多个名字<code>（使用中括号括起来）</code>，方便后续复用。</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];\n  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];\n}\n</code></pre>\n<h4 id=\"313-gap\">3.1.3 gap</h4>\n<p>网格线间距属性<code>gap</code>，其属性为行和列的简写：</p>\n<pre><code class=\"language-css\">.container {\n  gap: &lt;row-gap&gt; &lt;column-gap&gt;;\n  gap: 20px 20px;\n}\n</code></pre>\n<p>如果简写忽略了第二个值，则默认等于第一个值。</p>\n<h4 id=\"314-grip-template-areas\">3.1.4 grip-template-areas</h4>\n<p>网格布局可以通过字符串，抽象画的划分不同<code>item</code>所属的区域。</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: 100px 100px 100px;\n  grid-template-rows: 100px 100px 100px;\n  grid-template-areas:\n    &quot;a b c&quot;\n    &quot;d e f&quot;\n    &quot;g h i&quot;;\n}\n\n.area-a {\n  grid-area: a;\n  ....;\n}\n</code></pre>\n<p><code>grid-template-areas</code>通过空格将不同区域分割开来，然后可以在<code>css</code>中直接使用<code>grid-area</code>属性和区域名作为值，再为标签添加类即可针对性的设置样式。</p>\n<p>不使用的区域可以使用<code>.</code>占位，可以不同<code>cell</code>具有相同的<code>area</code>名，以便于指定样式，例如：</p>\n<pre><code class=\"language-css\">grid-template-areas:\n  &quot;a . a&quot;\n  &quot;b . b&quot;\n  &quot;c . d&quot;;\n</code></pre>\n<blockquote>\n<p><code>grip-template-rows</code>可以定义子项高度，同时也可以为网格线命名，而网格线可以有多个名字。<code>grid-template-areas</code>指定区域名的时候，也默认生成了<code>areaName-start</code>和<code>areaName-end</code>这样的网格线别名。</p>\n</blockquote>\n<h4 id=\"315-grid-auto-flow\">3.1.5 grid-auto-flow</h4>\n<p>容器划分好网格后，容器内<code>item</code>按顺序放置，默认先行后列，这个顺序是可以更改的。<code>grid-auto-flow</code>就是设置这个顺序的属性，默认值为<code>row</code>,先行后列，如果需要先列后行，则设置值为<code>column</code>。</p>\n<p>当某行或者某列按次序放置子项的时候，存在剩余宽度不足的情形，如果需要可以在<code>row</code>或<code>column</code>后添加一个<code>dense</code>值，二者用空格分开，意为尽可能让子项连续密集显示，如此一来就会跳过宽度超过剩余宽度的子项，按序优先使用后续满足条件的子项。例如：</p>\n<p><img src=\"https://i.imgur.com/P3bSu2L.png\" alt=\"\"></p>\n<p>属性：</p>\n<pre><code class=\"language-css\">grid-auto-flow: row dense;\n</code></pre>\n<p>结果：</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032514-20210612221449095.png\" alt=\"\"></p>\n<p>对于某些严格需要避免中间空白的布局来说，这个属性非常有效。</p>\n<h4 id=\"316-单元格位置\">3.1.6 单元格位置</h4>\n<p><code>justify-items</code>设置单元格水平布局，<code>align-items</code>设置单元格垂直布局，二者可选的值为：</p>\n<ul>\n<li>start</li>\n<li>end</li>\n<li>center</li>\n<li>Stretch （默认值，拉伸）</li>\n</ul>\n<p>如果要设置整个容器内的单元格位置，也就是将容器内所有单元格视为一个整体，其布局属性可用：</p>\n<ul>\n<li>justify-content:：整体水平对齐</li>\n<li>align-content： 整体垂直对齐</li>\n<li>place-content：此为上述两个属性的简写方式，如果忽略第二个值则采用第一个值</li>\n</ul>\n<p>这几个布局属性的值类似<code>flex</code>的布局值，分别是：</p>\n<ul>\n<li>start</li>\n<li>end</li>\n<li>center</li>\n<li>stretch（拉伸）</li>\n<li>Space-around 项目两侧间隔相等，子项之间距离两个间隔</li>\n<li>Space-between 子项之间距离相等，第一个子项和最后一个子项左边或右边没有空白，紧贴容器</li>\n<li>Space-evenly 子项左右空白距离相等</li>\n</ul>\n<h4 id=\"317-grid-auto-rows-and-grid-auto-columns\">3.1.7 grid-auto-rows and grid-auto-columns</h4>\n<p>当<code>容器网格</code>只有三行的时候，如果需要指定某个<code>子项</code>在第五行，这时候浏览器自动<code>根据子项大小</code>创建新的网格以放置额外的子项，我们可以通过<code>grid-auto-rows</code>和<code>grid-auto-columns</code>指定自动创建的网格的高度和宽度。</p>\n<p>例如：</p>\n<pre><code class=\"language-css\">.container {\n  display: grid;\n  grid-template-columns: 100px 100px 100px;\n  grid-template-rows: 100px 100px 100px;\n  grid-auto-rows: 50px;\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032525.png\" alt=\"\"></p>\n<p>之所以<code>8</code>和<code>9</code>会占据图中的位置，是因为我们使用<code>css</code>指定其行和列的位置值：</p>\n<pre><code class=\"language-css\">.item-8 {\n  background-color: #d0e4a9;\n  grid-row-start: 4;\n  grid-column-start: 2;\n}\n\n.item-9 {\n  background-color: #4dc7ec;\n  grid-row-start: 5;\n  grid-column-start: 3;\n}\n</code></pre>\n<p>由此引出<code>grid-row-start</code>和<code>grid-column-start</code>属性，可以指定其元素的位置。</p>\n<p>除了<code>start</code>还有<code>end</code>可以指定，看示例：</p>\n<pre><code class=\"language-css\">.item-1 {\n  grid-column-start: 2;\n  grid-column-end: 4;\n}\n</code></pre>\n<p>此时如果没有指定<code>grid-auto-flow: row dense;</code>,则会让布局看起来如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032526.png\" alt=\"\"></p>\n<p>为了方便记忆，可以将网格线数字改为网格线名。</p>\n<p>这四个属性的值还可以使用<code>span</code>关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</p>\n<pre><code class=\"language-css\">.item-1 {\n  grid-column-start: span 2;\n}\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032528.png\" alt=\"\"></p>\n<h4 id=\"318-属性简写\">3.1.8 属性简写</h4>\n<p>此前我有翻译过<code>google html &amp; css guide</code>文档风格指南，其中有一条建议是尽量在<code>css</code>中使用简写，我认为这是一个很好的准则。</p>\n<p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p>\n<p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p>\n<blockquote>\n<p>如果你喜欢简写，务必不要弄错简写的属性顺序。</p>\n</blockquote>\n<p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p>\n<pre><code class=\"language-css\">.item {\n  grid-column: &lt;start-line&gt; / &lt;end-line&gt;;\n  grid-row: &lt;start-line&gt; / &lt;end-line&gt;;\n}\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"language-css\">.item-1 {\n  grid-column: 1 / 3;\n  grid-row: 1 / 2;\n}\n/* 等同于 */\n.item-1 {\n  grid-column-start: 1;\n  grid-column-end: 3;\n  grid-row-start: 1;\n  grid-row-end: 2;\n}\n</code></pre>\n<p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p>\n<p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>\n<pre><code class=\"language-css\">.item-1 {\n  background: #b03532;\n  grid-column: 1 / 3;\n  grid-row: 1 / 3;\n}\n/* 等同于 */\n.item-1 {\n  background: #b03532;\n  grid-column: 1 / span 2;\n  grid-row: 1 / span 2;\n}\n</code></pre>\n<p><a href=\"https://jsbin.com/volugow/edit?html,css,output\">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032529.png\" alt=\"\"></p>\n<p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p>\n<pre><code class=\"language-css\">.item {\n  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;\n}\n\n.item-1 {\n  grid-area: 1 / 1 / 3 / 3;\n}\n</code></pre>\n<p>效果如上图所示。</p>\n<h3 id=\"32-子项属性\">3.2 子项属性</h3>\n<p>子项和容器的属性可以拆分开来，通过诸如<code>justify-self</code>等带<code>self</code>关键字的属性控制单独的子项的样式，并且优先级高于容器上相关的样式属性。</p>\n<h4 id=\"321-justify-self-、align-self、place-self\">3.2.1 justify-self 、align-self、place-self</h4>\n<p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>\n<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>\n<pre><code class=\"language-css\">.item {\n  justify-self: start | end | center | stretch;\n  align-self: start | end | center | stretch;\n}\n</code></pre>\n<p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p>\n<pre><code class=\"language-css\">place-self: center center;\n</code></pre>\n<p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>\n<h2 id=\"4-解题\">4. 解题</h2>\n<p>学习了<code>grid</code>布局的知识后，让我们将之运用到一开头我的需求中来，再次看这个图：</p>\n<p><img src=\"https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/GlXYwLiM4uyUIst-20210613022942072.png\" alt=\"\"></p>\n<p>针对性的容器<code>CSS</code>如下：</p>\n<pre><code class=\"language-css\">.container {\n}\n</code></pre>\n<h2 id=\"参考\">参考</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\">CSS Grid 网格布局教程 - 阮一峰的网络日志</a></li>\n</ul>\n",
            "url": "http://localhost:3000/blog/1397542082",
            "title": "CSS之Grid布局",
            "summary": "网格布局`(Grid)`被视为当前最强大的`CSS`布局方案。",
            "date_modified": "2022-10-05T09:58:26.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        },
        {
            "id": "http://localhost:3000/blog/1397540450",
            "content_html": "<p>第一次看到这本书的时候,记得是几年前在桂电图书馆里,断断续续看了六章,后来便离开了学校.现在买了纸质书打算重新看一遍,这里记录下阅读随想.</p>\n<h1 id=\"函数式编程简介\">函数式编程简介</h1>\n<blockquote>\n<p>函数要小,要更小.</p>\n</blockquote>\n<p>函数式编程,远离外部环境的依赖,隔绝突变与状态.</p>\n<p>数学的函数定义中,函数必须接收一个<code>参数</code>,返回一个值.函数根据接收的参数运行.给定的参数下,返回值是不变的.</p>\n<p><code>JavaScript函数式编程</code>基于数学函数及其思想进行发展.运用函数式的范式进行开发能创造可缓存和可测试的代码库.</p>\n<blockquote>\n<p>简单分辨函数与方法 - JS,不必深究 window 和 global 对象.</p>\n</blockquote>\n<ul>\n<li>函数: 一段通过名称可调用的代码</li>\n<li>方法: 通过名称且关联对象的名称被调用的代码</li>\n</ul>\n<p>函数的引用透明性指的是,函数对相同的输入返回相同的值.不依赖全局数据的函数,能够自由地在多线程状态下运行,全程无锁.并且函数是<code>可缓存</code>的,合理运用这一点,可以节省大量重复计算的资源消耗和时间消耗.</p>\n<blockquote>\n<p>引用透明性是一种哲学</p>\n</blockquote>\n<p><strong>命令式?声明式?</strong></p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3];\nfor (i = 0; i &lt; arr.length; i++) console.log(i);\n</code></pre>\n<p>上述代码示例,我们告诉编译器如何去做,这就是<code>命令式</code>.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3];\narr.forEach((i) =&gt; console.log(i));\n</code></pre>\n<p><code>forEach</code>是一个高阶函数,意在告知编译器<code>做什么</code>,<code>如何做</code>的部分则在高阶函数内的普通函数中实现.这便是<code>声明式</code>.</p>\n<p><strong>纯函数</strong>:对给定的输入,返回相同的输出的函数.纯函数不依赖于外部环境.也不会改变外部环境.易于对函数进行<code>测试</code>.</p>\n<p>纯函数是<code>易于阅读</code>的.为纯函数设置<code>具有意义</code>的函数名是一种最佳实践.</p>\n<blockquote>\n<p>纯函数应该被设计为只做一件事,并且把它做到完美,这也会是 Unix 的哲学.</p>\n</blockquote>\n<p>纯函数支持<code>管道和组合</code>.</p>\n<pre><code class=\"language-shell\">cat package.json | grep axios\n</code></pre>\n<p><code>bash</code>命令的管道和组合威力巨大,组合是函数式编程的核心.我们称之为<code>function composition</code>.</p>\n<h1 id=\"javascript-函数式基础\">JavaScript 函数式基础</h1>\n<p>略,简述基础<code>JavaScript</code>.</p>\n<h1 id=\"高阶函数-hof\">高阶函数 HOF</h1>\n<p><strong>JavaScript 数据类型</strong>:</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Object</li>\n<li>undefined</li>\n<li>Symbol</li>\n<li>BigInt</li>\n</ul>\n<p>除了<code>object</code>外,都是原始数据类型.</p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8\">计算机科学</a>中，<strong>抽象化</strong>（英语：Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是隐藏起它的实现细节。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。一个电脑系统可以分割成几个<a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B1%A4\">抽象层</a>（Abstraction layer），使得程序员可以将它们分开处理。</p>\n</blockquote>\n<p>抽象化,让我们专注于可控层面的工作,将复杂的内容简单化,让开发者专注于预订的目标,不必<code>事事关心</code>.</p>\n<p>我们通过<code>高阶函数</code>实现抽象.</p>\n<pre><code class=\"language-js\">const forEach = (arr, Fn) =&gt; {\n  for (let i = 0; i &lt; arr.length; i++) Fn(arr[i]);\n};\n</code></pre>\n<p>这是一个简单的高阶函数,抽象了<code>遍历数组</code>的问题,如果你使用这个函数,你并不需要关注内部代码是如何实现的.上述例子是一个简单逻辑,同理也可以是更为复杂的逻辑,这样一来就将复杂问题<code>抽象</code>出来了.</p>\n<p>让我们开始学习构建复杂的高阶函数.</p>\n<p>创建一个<code>every</code>函数如下:</p>\n<pre><code class=\"language-js\">const every = (arr, fn) =&gt; {\n  let result = true;\n  for (const i = 0; i &lt; arr.length; i++) {\n    result = result &amp;&amp; fn(arr[i]);\n  }\n  return result;\n};\n\n// for..of.. 版本\n// for...of..是 es6 的函数,可以方便遍历数组\nconst every = (arr, fn) =&gt; {\n  let result = true;\n  for (const value of arr) {\n    result = result &amp;&amp; fn(arr[value]);\n  }\n  return result;\n};\n</code></pre>\n<p>如此一来,我们抽象了对数组遍历的操作.</p>\n<p>接着,编写一个<code>some</code>函数,其接受一个数组和一个函数,如果数组中一个元素通过接收的函数返回<code>true</code>,则<code>some</code>函数返回<code>true</code>:</p>\n<pre><code class=\"language-js\">const every = (arr, fn) =&gt; {\n  let result = true;\n  for (const value of arr) {\n    result = result || fn(arr[value]);\n  }\n  return result;\n};\n</code></pre>\n<blockquote>\n<p>some 函数和 every 函数都不算高效,这里只是作为对高阶函数的展示.</p>\n</blockquote>\n<p><code>JavaScript</code>的<code>array</code>原型内置<code>sort</code>函数,可以给数组排序.这是一个典型的<code>高阶函数</code>.它接收一个可选的函数来决定排序顺序逻辑.极大的提高了排序的灵活性.我们知道,默认的<code>sort</code>排序是将数组元素转换为<code>string</code>并且按<code>Unicode</code>编码点进行排序,因此数字 2 在默认排序算法中小于 12.让我们看看此可选的<code>compare</code>函数的骨架:</p>\n<pre><code class=\"language-js\">function compare(a, b) {\n  if (条件) {\n    // a 小于 b\n    return -1;\n  }\n  if (条件) {\n    // a 大于 b\n    return 1;\n  }\n  // a 等于 b\n  return 0;\n}\n</code></pre>\n<p>举个例子,现在我们有一个用户数组,每个元素是一个用户的信息.</p>\n<pre><code class=\"language-js\">const people = [\n  {\n    name: &quot;Aaron&quot;,\n    age: 10,\n  },\n  {\n    name: &quot;Rose&quot;,\n    age: 11,\n  },\n];\n</code></pre>\n<p>而需求则是,通过姓名排序或者通过年龄排序.根据前置知识,可以写出如下代码:</p>\n<pre><code class=\"language-js\">// 简化逻辑,忽略相等的情况\npeople.sort((a, b) =&gt; (a.name &gt; b.name ? 1 : -1));\npeople.sort((a, b) =&gt; (a.age &gt; b.age ? 1 : -1));\n</code></pre>\n<p>上述代码,我们将雷同的部分写了两遍.现在我们来设计一个函数,接收一个参数,返回一个函数.是的,将要设计的这个函数是一个<code>高阶函数</code>.</p>\n<pre><code class=\"language-js\">const sortBy = (property) =&gt; {\n  return (a, b) =&gt; {\n    return a[property] &gt; b[property] ? 1 : -1;\n  };\n};\n// 简化版\nconst sortBy = (property) =&gt; (a, b) =&gt; a[property] &gt; b[property] ? 1 : -1;\n</code></pre>\n<p>现在,我们可以重写按<code>name</code>或者<code>age</code>的排序代码了.</p>\n<pre><code class=\"language-js\">people.sort(sortBy(&quot;name&quot;));\npeople.sort(sortBy(&quot;age&quot;));\n</code></pre>\n<p>这就是<code>高阶函数</code>的魅力.运用高阶函数,提高代码质量,降低代码数量.</p>\n<h1 id=\"闭包与高阶函数\">闭包与高阶函数</h1>\n<p>简而言之,闭包就是一个内部函数.在一个函数内部的函数,可以称为<code>闭包函数</code>.</p>\n<p>从<code>技术上</code>来讲,上述闭包函数的闭包场景存在三个可访问的作用域:</p>\n<ul>\n<li>自身声明内变量</li>\n<li>外部函数变量</li>\n<li>全局变量</li>\n</ul>\n<p><strong>闭包可以记住上下文环境</strong>.话说回来,由于我们要在函数式编程中处理很多函数,因此需要一种调试方法.</p>\n<p>举个例子,一个字符串数组,想要解析成整数数组,如下代码会有问题:</p>\n<pre><code class=\"language-js\">[&quot;1&quot;, &quot;2&quot;].map(parseInt);\n</code></pre>\n<p><code>map</code>函数用三个参数调用了<code>parseInt</code>,分别是:</p>\n<ol>\n<li>element</li>\n<li>index</li>\n<li>arr</li>\n</ol>\n<p>而<code>parseInt</code>函数全盘接纳,来看看此函数的定义:</p>\n<pre><code class=\"language-js\">parseInt(string, radix);\n</code></pre>\n<p><code>radix</code>是可选的基数,如果提供 10,则转换为十进制的整数.</p>\n<p>如果 <code>radix</code> 是 <code>undefined</code>、<code>0</code>或未指定的，JavaScript 会假定以下情况：</p>\n<ol>\n<li>如果输入的 <code>string</code>以 &quot;<code>0x</code>&quot;或 &quot;<code>0x</code>&quot;（一个 0，后面是小写或大写的 X）开头，那么 radix 被假定为 16，字符串的其余部分被当做十六进制数去解析。</li>\n<li>如果输入的 <code>string</code>以 &quot;<code>0</code>&quot;（0）开头， <code>radix</code>被假定为<code>8</code>（八进制）或<code>10</code>（十进制）。具体选择哪一个 radix 取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。<strong>因此，在使用 <code>parseInt</code> 时，一定要指定一个 radix</strong>。</li>\n<li>如果输入的 <code>string</code> 以任何其他值开头， <code>radix</code> 是 <code>10</code> (十进制)。</li>\n</ol>\n<p>如果第一个字符不能转换为数字，<code>parseInt</code>会返回 <code>NaN</code>。</p>\n<p>此时,<code>[&#39;1&#39;, &#39;2&#39;].map(parseInt)</code>的结果是: [1, NaN].</p>\n<p>如何用函数式的思维,创建一个高阶函数,对<code>parseInt</code>进行抽象.</p>\n<pre><code class=\"language-js\">const unary = (fn) =&gt;\n  fn.length === 1 ? fn : (arg) =&gt; fn(arg)[(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)].map(unary(parseInt));\n</code></pre>\n<p>现在,即使<code>map</code>以三个参数调用<code>unary</code>函数执行后返回的函数,都只会让<code>element</code>参数生效.</p>\n<p>我们得到了预期中的结果:<code>[1,2,3]</code> :seedling:</p>\n<p>现在,让我们为自己的工具库添加一个工具函数,这个函数接收一个函数作为参数,让这个接收的函数只能被执行一次.</p>\n<pre><code class=\"language-js\">const once = (fn) =&gt; {\n  let done = false;\n  return () =&gt; (done ? undefined : ((done = true), fn.apply(this, arguments)));\n};\n</code></pre>\n<p>现在用一个变量<code>done</code>保存函数的执行状态.</p>\n<pre><code class=\"language-js\">const demoFn = (a, b) =&gt; {\n  console.log(a, b, &quot;just called once.&quot;);\n};\nconst newDemoFn = once(demoFn);\nnewDemoFn(1, 2); // output: 1 2 just called once.\nnewDemoFn(3, 4); // no output\n</code></pre>\n<p>继续,创建下一个函数<code>memoized</code>,使函数记住其计算结果:</p>\n<pre><code class=\"language-js\">const memoized = (fn) =&gt; {\n  const lookupTable = {};\n  return (arg) =&gt; lookupTable[arg] || (lookupTable[arg] = fn(arg));\n};\n</code></pre>\n<p>一个速查<code>table</code>保存了函数解构,如果不存在则执行此函数,保存到速查表中并且返回此结果.</p>\n<p><strong>memoized 函数是经典的函数式编程,是闭包与纯函数的实战</strong></p>\n<h1 id=\"数组的函数式编程\">数组的函数式编程</h1>\n<p>我们将创建一组函数用于解决常见的数组问题,关键在于函数式的方法,而非命令式的方法.</p>\n<blockquote>\n<p>把函数应用于一个值,并且创建新的值的过程被称为&quot;投影&quot;</p>\n</blockquote>\n<p><code>Array.map</code>就是典型的投影函数.我们来试着创建一个<code>map</code>函数.</p>\n<pre><code class=\"language-js\">const map = (arr, fn) =&gt; {\n  const result = [];\n  for (const v of arr) {\n    result.push(fn(v));\n  }\n  return result;\n};\n</code></pre>\n<p>一个<code>filter</code>函数,对数组内容进行过滤.</p>\n<pre><code class=\"language-js\">const filter = (arr, fn) =&gt; {\n  const result = [];\n  for (const v of arr) {\n    if (fn(v)) result.push(v);\n  }\n  return result;\n};\n</code></pre>\n<p>一个<code>reduce</code>函数,对数组的所有值进行<code>归约</code>操作.</p>\n<pre><code class=\"language-js\">var reduce = (arr, fn, defaultAccumlator) =&gt; {\n  let accumlator;\n  if (defaultAccumlator !== undefined) {\n    accumlator = defaultAccumlator;\n    for (const v of arr) {\n      accumlator = fn(accumlator, v);\n    }\n  } else {\n    accumlator = arr[0];\n    for (let i = 1; i &lt; arr.length; i++) {\n      accumlator = fn(accumlator, arr[i]);\n    }\n  }\n  return [accumlator];\n};\n</code></pre>\n<p><strong>继续</strong>,上<code>zip</code>函数,用于合并两个单独的数组,返回一个处理过的新数组.这个函数可以对给定的两个数组的限定对象进行结对处理,如何处理取决于具体的函数逻辑.结对的结果就是返回一个新的数组.</p>\n<pre><code class=\"language-js\">const zip = (arr1, arr2, fn) =&gt; {\n  let index,\n    result = [];\n  for (index = 0; index &lt; Math.min(arr1.length, arr2.length); index++) {\n    result.push(fn(arr1[index], arr2[index]));\n  }\n  return result;\n};\n</code></pre>\n<h1 id=\"currying-和偏应用\">currying 和偏应用</h1>\n<p><strong>一些术语</strong>:</p>\n<ul>\n<li>unary function: 一元函数,只接收一个参数的函数.</li>\n<li>binary function: 二元函数</li>\n<li>变参函数:接受可变数量参数的函数</li>\n<li>currying: 柯里化,这是一个过程,将一个多参函数转变为一个嵌套的一元函数.</li>\n</ul>\n<p>上代码:</p>\n<pre><code class=\"language-js\">const curry = (binaryFn) =&gt; {\n  return (firstArg) =&gt; {\n    return (secondArg) =&gt; {\n      return binaryFn(firstArg, secondArg);\n    };\n  };\n};\n// 简化\nconst curry = (binaryFn) =&gt; (firstArg) =&gt; (secondArg) =&gt;\n  binaryFn(firstArg, secondArg);\n</code></pre>\n<p>完美利用了闭包的特性,也许对于一些深谙此道的 coder 而言,这不算什么.但是对于此刻的我来说,从未如此清晰体会到闭包和 currying.如此之美.</p>\n<p>开发者编写代码的时候会在应用中编写日志,下面我们编写一个<code>日志函数</code>.</p>\n<pre><code class=\"language-js\">const loggerHelper = (mode, msg, errorMsg, lineNo) =&gt; {\n  if (mode === &quot;DEBUG&quot;) {\n    console.debug(msg, errorMsg + &quot;at line:&quot; + lineNo);\n  } else if (mode === &quot;WARN&quot;) {\n    console.warn(msg, errorMsg + &quot;at line:&quot; + lineNo);\n  } else if (mode === &quot;ERROR&quot;) {\n    console.error(msg, errorMsg + &quot;at line:&quot; + lineNo);\n  } else {\n    throw &quot;WRONG MODE&quot;;\n  }\n};\n</code></pre>\n<p>上述代码不是良好的设计,多次重用了部分代码,让整体不够简洁.之前创建的<code>curry</code>函数也无法处理这个日志函数.我们需要<strong>更进一步</strong>.我们需要把多参数函数转化为<code>unary function</code>.</p>\n<pre><code class=\"language-js\">const curry = (fn) =&gt; {\n  if(typeof fn !== &#39;function&#39;) throw Error(&#39;No function provided&#39;)\n  // args 是可变参数\n  return function curryFn(...args) {\n    // 如果可变参数少于被柯里化的函数的参数数量\n    if(args.length &lt; fn.length) {\n      return function() {\n        // 执行此函数,返回一个处理一次参数的函数\n        return curryFn.apply(null, args.concat(\n            Array.slice.call(arguments)\n        ))\n      }\n    }\n    return fn.apply(null, args)\n}\n</code></pre>\n<blockquote>\n<p><code>arguments</code>对象是所有（非箭头）函数中都可用的<strong>局部变量</strong>。你可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。</p>\n</blockquote>\n<p>回到<code>日志函数</code>:</p>\n<pre><code class=\"language-js\">const errorDebugLog = curry(loggerHelper)(&quot;ERROR&quot;)(&quot;ERROR:&quot;);\nconst warnDebugLog = curry(loggerHelper)(&quot;WARN&quot;)(&quot;WARN:&quot;);\nerrorDebugLog(&quot;balabala..&quot;, 21); // output: &#39;ERROR: balabala at line 21&#39;\n</code></pre>\n<p>这就是闭包的魅力,在首次传入<code>loggerHelper</code>的时候,闭包生成了可访问变量作用域,记住了函数信息.</p>\n<p>现在,让我们来解决两个问题:</p>\n<ul>\n<li>在数组内容中检查是否存在数字</li>\n<li>求数组的平方</li>\n</ul>\n<p>首先,创建一个检查函数:<code>findNumberInArr</code></p>\n<pre><code class=\"language-js\">const match = curry((expr, str) =&gt; str.match(expr));\nconst hasNumber = curry(match(/[0-9]+/));\nconst filter = curry((fn, arr) =&gt; arr.filter(fn));\n// create fn\nconst findNumberInArr = filter(hasNumber);\n// test\nfindNumberInArr([&quot;demo&quot;, &quot;demo1&quot;]); // output: [&#39;demo1&#39;]\n</code></pre>\n<p>现在求数组的平方,我们通过<code>curry</code>函数进行处理,这次不要直接通过<code>map</code>函数传入一个平方函数解决这个问题.换一个视角.</p>\n<pre><code class=\"language-js\">const map = curry((fn, arr) =&gt; arr.map(f));\nconst squareAll = map((x) =&gt; x * x);\n// 现在,squareAll 是一个unary 函数\nsquareAll([1, 2, 3]); // output: [1, 4, 9]\n</code></pre>\n<p>我们可以很多地方直接使用<code>squareAll</code>函数了.如果需要在多个地方求数组的平方,这个函数可以简化降低代码量,当然,我们还可以配合<code>memoized</code>函数进行缓存处理!</p>\n<p>是时候谈谈<code>偏应用</code>了,接下来我们将创建一个<code>partial</code>函数以解决我们的问题.</p>\n<p>比如我们有这样一个场景,我们需要在 10 秒后执行一个函数,这个需求在多个地方用得上,也许我们会直接如此编程:</p>\n<pre><code class=\"language-js\">setTimeout(() =&gt; {\n  // some code\n}, 10000);\n</code></pre>\n<p>一旦需要在另一个地方使用这个逻辑,就需要重写一遍这些代码.而且无法使用<code>curry</code>函数进行处理,因为时间参数是最后一个参数.解决这个问题的方案之一就是创建一个封装函数:</p>\n<pre><code class=\"language-js\">const setTimeoutWrapper = (time, fn) =&gt; {\n  setTimeout(fn, time);\n};\n</code></pre>\n<p>然后使用<code>curry</code>函数进行优化.然而,我们可以进一步减少创建此类函数的开销.</p>\n<p><strong>这就是偏应用</strong>的应用场景.</p>\n<pre><code class=\"language-js\">var partial = (fn, ...partialArgs) =&gt; {\n  let args = partialArgs\n  return (...fullArguments) {\n    let arg = 0\n    for(let i=0;i&lt;args.length &amp;&amp; arg &lt; fullArguments.length;i++) {\n      if(args[i] === undefined) {\n        args[i] = fullArguments[arg++]\n      }\n    }\n    return fn.apply(null, args)\n  }\n}\n\nconst delayTenMs = partial(setTimeout, undefined, 10)\nconst demoFn = () =&gt; {\n  // sdasdsadad\n}\ndelayTenMs(demoFn)\n</code></pre>\n<p>再次使用了闭包,记住了<code>setTimeout</code>需要的参数列表长度,暂未提供的参数用 undefined 代替.后续返回一个函数,提供参数的同时,补全之前用 undefined 代替的部分参数,最终执行函数.</p>\n<p>例如,我们需要美化一个<code>json</code>对象的输出.先看看 json stringify 函数的定义.</p>\n<pre><code class=\"language-js\">JSON.stringify(value[, replacer [, space]])\n</code></pre>\n<p><strong>参数</strong></p>\n<ul>\n<li><p><code>value</code></p>\n<p>将要序列化成 一个 JSON 字符串的值。</p>\n</li>\n<li><p><code>replacer</code> 可选</p>\n<p>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</p>\n</li>\n<li><p><code>space</code> 可选</p>\n<p>指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">const obj = { foo: &quot;bar&quot;, bar: &quot;foo&quot; };\n// 第二参数\nJSON.stringify(obj, null, 2);\n// 想办法移除样板代码 null 和 2\nconst prettyJson = partial(JSON.stringify, undefined, null, 2);\nprettyJson(obj);\n</code></pre>\n<p>啊!<code>partial</code>函数有 bug.<code>partialArgs</code>传递的是数组,数组传递的是引用.如果不创建一个新的数组,并且在最后重置数组的话,执行一次<code>partial</code>化后的函数<code>delayTenMs</code>,内部 args 就固定了,闭包变量保存了首次执行的时候提供的参数去替换<code>undefined</code>,这里的<code>undefined</code>就像占位符.</p>\n<p>书上并没有给出一个示例代码来解决问题,只是提出存在 bug 的观点,我写下了如下代码,使用扩展运算符重置占位符效果的<code>undefined</code>变量.</p>\n<pre><code class=\"language-js\">const partial = (fn, ...partialArgs) =&gt; {\n  let args = [...partialArgs];\n  return (...fullArgs) =&gt; {\n    let argIndex = 0;\n    for (\n      let index = 0;\n      index &lt; args.length &amp;&amp; argIndex &lt; fullArgs.length;\n      index++\n    ) {\n      if (args[index] === undefined) {\n        args[index] = fullArgs[argIndex++];\n      }\n    }\n    const result = fn.apply(null, args);\n    args = [...partialArgs];\n    return result;\n  };\n};\n</code></pre>\n<p>晚安.</p>\n<p>2020 年 12 月 21 日 01:41:11</p>\n<h1 id=\"管道和组合\">管道和组合</h1>\n<p>函数式组合在函数式编程中被称为<code>组合 composition</code>.</p>\n<blockquote>\n<p>每个程序只为做好一件事,重构要比在旧的复杂程序中添加新属性更好. From Ken·Thompson</p>\n</blockquote>\n<blockquote>\n<p>每一个程序的输出应该是另一个未知程序的输入.</p>\n</blockquote>\n<p>我们将要创建<code>compose</code>函数,例如:</p>\n<pre><code class=\"language-js\">const compose = (a, b) =&gt; (c) =&gt; a(b(c));\n</code></pre>\n<p>依然是熟悉的高阶函数,接收函数作为参数,返回函数.返回的函数的<code>参数</code>是关键.</p>\n<p><code>compose</code>函数能解决我们常见的一些问题.你是否写过类似如下代码:</p>\n<pre><code class=\"language-js\">const data = someFn(&quot;this&quot;);\nconst result = otherFn(data);\n</code></pre>\n<p>一个函数的输出,作为另一个函数的输入.<code>compose</code>函数为此而生.</p>\n<pre><code class=\"language-js\">const getResult = compose(otherFn, someFn);\n</code></pre>\n<p><code>getResult</code>是一个函数,接收的参数跟<code>someFn</code>函数一致.我们创建了一个函数<code>getResult</code>.这是一种优雅而简单的实现方式.</p>\n<p>上述<code>someFn</code>只接收一个参数,如果需要接收多个参数的话,我们可以使用<code>curry</code>和<code>partial</code>两个函数进行优化.</p>\n<blockquote>\n<p>组合的思想就是把小函数组合成大函数,简单的函数易于阅读,测试和维护.</p>\n</blockquote>\n<p>创建小的函数单元,可以通过 compose 组合重建应对各种需求.</p>\n<p>但是,上述<code>compose</code>函数无法处理更多函数作为参数.仅仅支持两个函数作为参数是不够的,让我们来优化一下.</p>\n<pre><code class=\"language-js\">const compose =\n  (...fns) =&gt;\n  (value) =&gt;\n    reduce(fns.reverse(), (acc, fn) =&gt; fn(acc), value);\n</code></pre>\n<p>竟然如此简单桥面,接收一个入口参数<code>value</code>,首先设置为初始的<code>acc</code>值,依次执行并且返回作为下一个函数的入口.</p>\n<p>组合是从右到左执行的,而管道则从左到右.接下来创建<code>pipe</code>管道函数.</p>\n<pre><code class=\"language-js\">const pipe =\n  (...fns) =&gt;\n  (value) =&gt;\n    reduce(fns, (acc, fn) =&gt; fn(acc), value);\n</code></pre>\n<p>只是执行方向不同而已,因此参数列表不必反向.</p>\n<blockquote>\n<p>在公共代码库中建议使用单一的数据流,我更喜欢管道,因为这让我想起 shell 知识.同时使用管道和组合容易在团队中引起混淆.</p>\n</blockquote>\n<p>接下来,本书描述了<strong>组合</strong>的优势.</p>\n<p>组合支持结合律.书上并没有详细的介绍和案例分析.只是单纯举例:</p>\n<pre><code class=\"language-js\">compose(f, compose(g, h)) == compose(compose(f, g), h);\n</code></pre>\n<p>通过组合小函数的方式,让函数的组合更加灵活.</p>\n<p>下面,我们来创建一个<code>identity</code>函数,用于分析调试.接收一个参数,打印并且返回.</p>\n<pre><code class=\"language-js\">const identity = (it) =&gt; {\n  console.log(it);\n  return it;\n};\n</code></pre>\n<p>由于组合和管道数据是流动的关系,可以在其间插入<code>identity</code>函数,输出数据用于调试.这确实非常简单有效.</p>\n<h1 id=\"函子\">函子</h1>\n<p>本章最重要的内容就是<code>编程错误处理</code>.我们需要了解一个新的概念:<code>functor:函子</code>,它将以纯函数的形式帮我们处理错误.</p>\n<blockquote>\n<p>函子是一个普通对象,它实现了<code>map</code>函数,在遍历每一个对象的时候生成一个新的对象.</p>\n</blockquote>\n<p>函子是<code>容器</code>,其持有值.</p>\n<pre><code class=\"language-js\">const Container = function (val) {\n  this.value = val;\n};\n</code></pre>\n<blockquote>\n<p>不使用箭头函数,箭头函数没有<code>[[construct]]</code>和<code>prototype</code>属性,无法用<code>new</code>实例化.</p>\n</blockquote>\n<p>现在,<code>container</code>可以持有传给它的任何值.</p>\n<pre><code class=\"language-js\">let a = new Container(3)\n=&gt; Container(value: 3)\nlet bObj = new Container({a: 1})\n=&gt; Container({a:1})\n</code></pre>\n<p>继续,创建一个<code>of</code>静态方法.</p>\n<pre><code class=\"language-js\">Container.of = function (value) {\n  return new Container(value);\n};\n</code></pre>\n<p>于是,我们可以使用<code>static</code>函数创建对象了.</p>\n<pre><code class=\"language-js\">const testObj = Container.of(3)\n=&gt; Container(value:3)\n</code></pre>\n<p>接下来,我们需要创建<code>map</code>函数,之后这便是一个<code>函子</code>.</p>\n<p><img src=\"https://i.loli.net/2020/12/24/vX1AIKxhgOlQzMd.png\" alt=\"\"></p>\n<p>看代码:</p>\n<pre><code class=\"language-js\">Container.prototype.map = function (fn) {\n  return Container.of(fn(this.value));\n};\n</code></pre>\n<p>经过<code>map</code>函数处理,会返回一个新的 container 对象.于是,我们可以进行如下编码:</p>\n<pre><code class=\"language-js\">let double = x =&gt; x + x\nContainer.of(3).map(double)\n=&gt; Container(6)\nContainer.of(3).map(double).map(double)\n=&gt; Container(12)\n</code></pre>\n<p>得到了我个人一直以来不够了解的链式调用的实现思路.</p>\n<blockquote>\n<p>函子是一个实现了 map 契约的对象</p>\n</blockquote>\n<p>所以,函子能用在什么地方?</p>\n<pre><code class=\"language-js\">const MayBe = function (val) {\n  this.value = val;\n};\nMayBe.of = function (v) {\n  return new MayBe(v);\n};\nMayBe.prototype.isNothing = function () {\n  return this.value === null || this.value === undefined;\n};\nMayBe.prototype.map = function (fn) {\n  return this.isNothing() ? MayBe.of(null) : MayBe.of(this.value);\n};\n</code></pre>\n<p>:construction_worker:</p>\n<p>上用例</p>\n<pre><code class=\"language-js\">MayBe.of(&#39;string&#39;).map(x =&gt; x.toUpperCase())\n=&gt; MayBe {value: &#39;STRING&#39;}\n</code></pre>\n<p>即使不是<code>typescript</code>,无法避免<code>of</code>方法传入<code>null</code>或者<code>undefined</code>,内部的<code>map</code>方法也会做一次检查,逻辑抽象出来避免了错误.代码没有在<code>null</code>或者<code>undefined</code>下崩溃.这是一种声明式的方式去编程,这也是一个安全的容器.</p>\n<pre><code class=\"language-js\">MayBe.of(&quot;pg&quot;)\n  .map((x) =&gt; x.toUpperCase())\n  .map((x) =&gt; `Mr. ${x}`);\n</code></pre>\n<p>链式调用,优美简洁.</p>\n<p><strong>另一个函子</strong><code>Either</code>,上述<code>MayBe</code>函子在传入<code>null</code>或者<code>undefined</code>后,最后的结果是<code>null</code>.可是我们很难分析出问题出在哪里.我们需要一个更强大的函子,解决分支拓展的问题.</p>\n<pre><code class=\"language-js\">const Nothing = function (val) {\n  this.value = val;\n};\nNothing.of = function (v) {\n  return new Nothing(v);\n};\nNothing.prototype.map = function (f) {\n  return this;\n};\nconst Some = function (val) {\n  this.value = val;\n};\nSome.of = function (v) {\n  return new Some(v);\n};\nSome.prototype.map = function (f) {\n  return Some.of(f(this.value));\n};\n</code></pre>\n<p><code>Nothing</code>的 map 函数,返回自身,而不是运行函数<code>f</code>.</p>\n<p>2020 年 12 月 25 日 12:57:10 :100:</p>\n<p>能在<code>Some</code>上运行函数,而<code>Nothing</code>不行.来吧,实现<code>Either</code>.</p>\n<pre><code class=\"language-js\">const Either = {\n  Some,\n  Nothing,\n};\n</code></pre>\n<p>如果我们有一个<code>web</code>请求,返回数据可能是正常数据,或者一条错误信息.</p>\n<pre><code class=\"language-js\">const getData = (type) =&gt; {\n  let resp;\n  try {\n    resp = Some.of(data);\n  } catch {\n    resp = Nothing.of(error);\n  }\n};\n</code></pre>\n<p>后续返回的 response 对象依然是函子,可以使用链式调用的 map 函数.但是,错误信息能保存下去,<code>Nothing</code>从头到尾都不会变,直接返回<code>this</code>使得后续的 map 函数<code>失效</code>.</p>\n<p>现在,你根据上下文,可以很容易看出异常出在哪里.是的,是<code>catch</code>到了错误.</p>\n<p>上述函子都是<code>pointed</code>函子,ES6 的 Array.of 也是<code>pointed</code>函子.</p>\n<h1 id=\"深入理解-monad-函子\">深入理解 Monad 函子</h1>\n<p><code>reddit</code>开放了一些<code>api</code>接口,例如:<strong><a href=\"https://www.reddit.com/search.json?q=something\">https://www.reddit.com/search.json?q=something</a></strong></p>\n<p>粘贴一个随机的返回数据,不必详细深究:</p>\n<pre><code class=\"language-json\">{\n  &quot;kind&quot;: &quot;Listing&quot;,\n  &quot;data&quot;: {\n    &quot;after&quot;: &quot;t3_k1qcrx&quot;,\n    &quot;dist&quot;: 25,\n    &quot;facets&quot;: {}.\n    &quot;modhash&quot;: &quot;&quot;,\n    &quot;children&quot;: [...],\n  &quot;before&quot;: null\n  }\n}\n</code></pre>\n<p><code>children</code>部分非常庞大,不再展开.每一个<code>children</code>都是一个对象,内含一个<code>Permalink</code>键,值是一个相对<code>url</code>,访问这个<code>url</code>则能获取到评论数组.</p>\n<p>我们如何按搜索的结果,获取文章的评论,最后返回一个数组,每个元素是一个对象,对象内是<code>title</code>和<code>comments</code>.</p>\n<pre><code class=\"language-js\">const request = require(&quot;sync-request&quot;);\nconst searchReddit = (search) =&gt; {\n  let response;\n  try {\n    response = JSON.parse(\n      request(\n        &quot;GET&quot;,\n        &quot;https://www.reddit.com/saerch.json?q=&quot; + encodeURI(search)\n      ).getBody(&quot;utf8&quot;)\n    );\n  } catch (err) {\n    response = { msg: &quot;something wrong&quot;, errorCode: err[&quot;statusCode&quot;] };\n  }\n  return response;\n};\n\nconst getComments = (link) =&gt; {\n  let resp;\n  try {\n    resp = JSON.parse(\n      request(&quot;GET&quot;, &quot;https://www.reddit.com/&quot; + link).getBody(&quot;utf8&quot;)\n    );\n  } catch (err) {\n    resp = {\n      msg: &quot;get comment failed&quot;,\n      errorCode: err[&quot;statusCode&quot;],\n    };\n  }\n  return resp;\n};\n\n// 合并两个函数\nconst mergeViaMayBe = (searchText) =&gt; {\n  let redditMayBe = MayBe.of(searchReddit(searchText));\n  let ans = redditMayBe\n    .map((arr) =&gt; arr[&quot;data&quot;])\n    .map((arr) =&gt; arr[&quot;children&quot;])\n    .map((arr) =&gt;\n      map(arr, (x) =&gt; {\n        return {\n          title: x[&quot;data&quot;].title,\n          permalink: x[&quot;data&quot;].permalink,\n        };\n      })\n    )\n    .map((obj) =&gt;\n      map(obj, (x) =&gt; {\n        return {\n          title: x.title,\n          comments: MayBe.of(\n            getComments(x.permalink.replace(&quot;?ref=search_posts&quot;, &quot;.json&quot;))\n          ),\n        };\n      })\n    );\n};\n</code></pre>\n<p>运用函子,可以使用链式方法解决问题,非常优雅.</p>\n<p>但是,这依然不够,观察上述结果中<code>comments</code>依然是<code>MayBe</code>对象,想要真正取值还是需要继续<code>map</code>调用.</p>\n<p>下面,介绍<code>Monad</code>函子以解决过多的<code>map</code>嵌套问题.让<code>MayBe</code>武装到牙齿.</p>\n<pre><code class=\"language-js\">MayBe.prototype.join = function () {\n  return this.isNothing() ? MayBe.of(null) : this.value\n}\nlet joinExample = MayBe.of(MayBe.of(1))\n=&gt; MayBe{value: MayBe{value: 1}}\njoinExample.join()\n// 返回值展开一个层级\n=&gt; MayBe {value: 1}\n</code></pre>\n<p>如果我们想要对内部的值进行操作,也许可以先展开层级,再执行<code>map</code>函数,以减少<code>map</code>的调用.那么既然当我们需要展开一层的时候都需要在后面跟一个<code>join</code>方法,我们可以再封装一个<code>chain</code>函数来做这件事.</p>\n<pre><code class=\"language-js\">MayBe.prototype.chain = function (f) {\n  return this.map(f).join();\n};\n</code></pre>\n<p><code>Monad</code>就是包含<code>chain</code>方法的特殊函子.或者说,一个函子拥有<code>chain</code>方法,就可以称为<code>Monad</code></p>\n<p>2020 年 12 月 26 日 01:34:57</p>\n<h1 id=\"使用-generator\">使用 Generator</h1>\n<p>如果你是<code>promise</code>的粉丝,建议学习<code>Generator</code>及其解决异步代码问题的方式.</p>\n<p>让我们先来谈谈<code>同步和异步</code>:</p>\n<ul>\n<li><p>同步:函数执行的时候阻塞调用者,直到函数执行结束返回结果.</p>\n</li>\n<li><p>异步:函数执行不会阻塞,但是函数执行结束就会返回结果.</p>\n</li>\n</ul>\n<p>让我们来创建<code>Generator</code>,注意观察这个特殊语法.</p>\n<pre><code class=\"language-js\">function* gen() {\n  return &quot;first generator&quot;;\n}\n</code></pre>\n<p>我们在函数前面用一个星号 <strong>*</strong> 来表示这是一个<code>Generator</code>函数.</p>\n<pre><code class=\"language-js\">let genResult = gen();\n</code></pre>\n<p>此刻,<code>genResult</code>并不是<code>first generator</code>,而是:</p>\n<p><code>gen {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorRecevier]]: Window}</code></p>\n<p>这是一个<code>Generator</code>原始类型的实例.这个实例拥有<code>next</code>方法.执行此方法,上面的代码返回一个对象:</p>\n<p><code>{value: &#39;first generator&#39;, done: true}</code></p>\n<p><code>Generator</code>实例如同序列,一旦使用<code>next</code>消费,则不能再次得到上次消费的值.也就是说,如果你继续执行<code>next()</code>方法,结果的<code>vaue</code>将是<code>undefined</code>.</p>\n<pre><code class=\"language-js\">function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n</code></pre>\n<p>有趣的是,实例执行<code>next</code>将会返回<code>yield</code>后的结果,并且下次执行<code>next</code>会从当前<code>yield</code>后继续执行.当所有<code>yield</code>结果都消费之后,<code>done</code>属性变成<code>true</code>.</p>\n<pre><code class=\"language-js\">let genResult = gen();\nfor (let v of genResult()) {\n  console.log(v);\n}\n// 1\n// 2\n// 3\n</code></pre>\n<p><code>for..of..</code>利用了<code>next</code>和<code>done</code>属性完成遍历.</p>\n<p><code>Generator</code>不止如此,还可以想其实例通过<code>next</code>函数传递数据.</p>\n<pre><code class=\"language-js\">function * sayFullName(){\n  let firstName = yield\n  let secondName = yield\n  console.log(`${firstName} - ${secondName}`)\n}\n\n// call it\nlet fullName = sayFullName()\nfullName.next()\nfullName.next(&#39;Fname&#39;)\nfullName.next(&#39;Sname&#39;)\n=&gt; console log : Fname - Sname\n</code></pre>\n<p>首次运行<code>next</code>,函数暂停于: <code>let firstName = yield</code></p>\n<p>再次运行带参数的<code>next</code>,则<code>let firstName = yield</code>转为<code>let firstName = &quot;Fname&quot;</code></p>\n<blockquote>\n<p><code>Generator</code>与<code>异步应用</code>可以很和谐.</p>\n</blockquote>\n<p>假如有两个本质上是异步的函数如下:</p>\n<pre><code class=\"language-js\">let getDataOne = (cb) =&gt; {\n  setTimeout(() =&gt; {\n    cb(&quot;dummy data one&quot;);\n  }, 1000);\n};\n\nlet getDataTwo = (cb) =&gt; {\n  setTimeout(() =&gt; {\n    cb(&quot;dummy data two&quot;);\n  }, 1000);\n};\n</code></pre>\n<p>一旦时间过去,就执行传入的回调函数<code>cb</code>.如果要用<code>generator</code>来解决回调函数可能导致的函数回调地狱的问题?</p>\n<p>让我们来改造<code>getDataOne</code>:</p>\n<pre><code class=\"language-js\">let geneator;\nlet getDataOne = () =&gt; {\n  setTimeout(() =&gt; {\n    // 调用 Generator\n    // 使用 next 加参数传送数据\n    generator.next(&quot;fake data one&quot;);\n  }, 1000);\n};\n</code></pre>\n<p>然而,我并不是很理解这段代码,<code>generator</code>是<code>undefined</code>,为何调用<code>next</code>.</p>\n<p>2020 年 12 月 26 日 22:56:50</p>\n<p>2020 年即将结束,在异步编程的问题上让我们拥抱<code>async</code>和<code>await</code>吧.</p>\n<p>终于看完了这本书,这本书非常适合我现在的水平,让我能够学习得很愉快.再次感谢,即使昨天是圣诞节我依然一个人过.</p>\n<p>再会啦.</p>\n",
            "url": "http://localhost:3000/blog/1397540450",
            "title": "Javascript-ES6-函数式编程阅读随写",
            "summary": "第一次看到这本书的时候,记得是几年前在桂电图书馆里,断断续续看了六章,后来便离开了学校.现在买了纸质书打算重新看一遍,这里记录下阅读随想.",
            "date_modified": "2022-10-05T09:57:04.000Z",
            "author": {
                "name": "妙才",
                "url": "https://twitter.com/miaocai0"
            }
        }
    ]
}
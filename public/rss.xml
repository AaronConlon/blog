<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>AaronConlon's Blog</title>
        <link>https://i5lin.top</link>
        <description>AaronConlon's Blog</description>
        <lastBuildDate>Fri, 16 Aug 2024 09:55:31 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>zhCN</language>
        <image>
            <title>AaronConlon's Blog</title>
            <url>https://i5lin.top/coder3.svg</url>
            <link>https://i5lin.top</link>
        </image>
        <copyright>All rights reserved 2024, Blog</copyright>
        <atom:link href="https://i5lin.top/rss" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[【译文】TanStack Query: 在变更之后自动使查询失效]]></title>
            <link>https://i5lin.top/blog/post/2402228975</link>
            <guid>2402228975</guid>
            <pubDate>Thu, 11 Jul 2024 04:36:47 GMT</pubDate>
            <description><![CDATA[我喜欢 Tanstack query`但是在使用过程中遇到了 mutation 之后自动 invalidate 数据的问题，于是搜索到一篇博客，本文是这篇博客的翻译内容。]]></description>
            <content:encoded><![CDATA[<p><code>查询</code>（Query）和<code>变更</code>（Mutation）就像是一枚硬币的两面。<code>查询</code>（Query）定义了一个异步资源用于读取，这通常来源于数据获取。而<code>变更</code>（Mutation）则是用于更新此类资源的操作。</p>
<p>当一个<code>变更</code>（Mutation）完成时，它很可能会影响<code>查询</code>（Query）。例如，变更一个<code>issue</code>很可能会影响<code>issue</code>列表。因此，有些人可能会觉得奇怪，为什么不把<code>Query</code>和<code>Mutation</code>关联起来？</p>
<p>原因其实很简单：<code>TanStack Query</code>完全没有主观地要求你如何管理自己的资源，并非每个人都喜欢在<code>mutation</code>之后重新获取数据。</p>
<p>有些情况下，我们希望将<code>mutation</code>返回的数据手动放进缓存中，以避免一次网络请求。此外还有很多不同的方法来执行<code>invalidate</code>（无效化）操作。</p>
<blockquote>
<p>Tanstack Query 将 query 的数据缓存起来，开发者可以通过 invalidate 行为让其失效，从而自动执行 queryFn 请求最新的数据</p>
</blockquote>
<ul>
<li>你会在<code>onSuccess</code>还是<code>onSettled</code>回调函数中执行<code>invalidate</code>操作？前者仅在变更成功之后调用，后者则在出错的时候也会调用。</li>
<li>你想要等待 <code>invalidations</code>结束吗？等待<code>invalidate</code>行为结束的话将会保持<code>mutation</code>的挂起状态，直到<code>invalidate</code>结束（通常是<code>refetch</code>资源数据）。这是可能是一件好事，例如，如果你希望在提交模态框表单之后等待列表数据更新再关闭模态框。但是，如果你确定想要<code>提交成功后立即关闭模态框</code>，甚至可能会导致用户一开始因为网络请求的原因可能看不到最新的数据而感到惊奇，那么就没必要等待<code>invalidations</code>结束。</li>
</ul>
<p>由于没有一种普适的解决方案，<code>Tanstack Query</code>并不提供对应开箱即用的功能。然而，感谢<code>Tanstack Query</code>支持全局缓存回调功能，在<code>Tanstack Query</code>中实现你想要的自动无效化并不难。</p>
<h3>全局缓存回调（The Global Cache Callbacks）</h3>
<p><code>变更</code>（Mutations）有回调函数——<code>onSuccess</code>、<code>onError</code> 和 <code>onSettled</code>，这些回调函数需要在每个单独的 <code>useMutation</code> 中定义。此外，这些回调函数也存在于 <code>MutationCache</code> 中。每一个<code>queryClient</code>实例在创建的时候都可以配置一个<code>mutationCache</code>，这个<code>mutationCache</code>里的回调函数会在每一个<code>mutation</code>调用之后执行（并且会在单独定义的<code>mutation</code>参数中定义的回调之前执行）。</p>
<p>如下所示：</p>
<pre><code class="language-js">import { QueryClient, MutationCache } from &#39;@tanstack/react-query&#39;

// 创建 MutationCache 并提供回调函数
const mutationCache = new MutationCache({
  onSuccess: (data, variables, context, mutation) =&gt; {
    console.log(&#39;Mutation was successful&#39;);
    if(Array.isArray(mutation?.meta?.awaits)) {
      return queryClient.invalidateQuires({
          queryKey: mutation.meta.awaits	        
        },{ cancelRefetch: false })
    }
  },
  onError: (error, variables, context) =&gt; {
    console.error(&#39;Mutation failed&#39;);
  },
  onSettled: (data, error, variables, context) =&gt; {
    console.log(&#39;Mutation settled&#39;);
  }
});

// 创建 QueryClient 并传入自定义的 MutationCache
const queryClient = new QueryClient({
  mutationCache,
  // 其他选项
});
</code></pre>
<p>这些回调函数接收的参数与<code>useMutation</code>中的参数相同，只是它们还会接收<code>变更实例</code>（Mutation instance）作为最后一个参数。而且与通常的回调函数一样，返回的 <code>Promise</code> 会被等待。</p>
<p>那么如何借此实现自动<code>invalidation</code>呢？我们只需要在全局回调函数内部调用<code>queryClient.invalidateQueries()</code>就行了：</p>
<pre><code class="language-js">const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: () =&gt; {
      queryClient.invalidateQueries()
    },
  }),
})
</code></pre>
<p>通过上面的五行代码，我们得到了在 Remix（抱歉，React-Router）中相似的行为：在每次提交之后让一切失效。向你致敬，Alex 展示了这一思路：<a href="https://x.com/alexdotjs/status/1744467890277921095"><a href="https://x.com/alexdotjs/status/1744467890277921095">Alex / KATT 🐱 on X: &quot;@housecor I just invalidate everything on every mutation https://t.co/0TALY8NdrV&quot; / X</a></a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240620173116614.png" alt="image-20240620173116614"></p>
<h3>但这是不是有点激进了？</h3>
<p>可能是，也可能不是。这得看情况。再强调一次，为什么没有内置这个机制，因为有很多方法可以实现这一点。在这里我们需要澄清一点，<code>无效化并不总是等同于重新获取数据</code>。</p>
<p><code>Invalidation</code>仅仅是重新获取所有匹配的活跃查询，并将其余标记为<code>stale</code>（过期），这样它们在下次使用时会被重新获取。</p>
<p>这通常是一个很好且折衷的方案。想想你现在有一个带有筛选条件的<code>issue</code>列表，由于你将过滤条件对象作为<code>queryKey</code>的一部分，每次筛选条件对象变化都会生成不同<code>queryKey</code>的缓存记录，然而我们每次只渲染一个筛选对象对应的结果。重新获取所有数据会产生大量当前不必要的请求，我们也没法保证用户会修改筛选条件来让查看对应的结果，从而让这些请求有价值。</p>
<p>因此，<code>invalidation</code> 只重新获取我当前在屏幕上看到的内容（活跃的查询），以获取最新的视图，而其余的内容将在需要时重新获取。</p>
<h3>尝试让特定的查询失效</h3>
<p>好吧，精细化验证是有必要的。变更<code>issue</code>列表的数据后让个人资料的数据失效从而触发其重新获取个人资料？？？这真的没什么意义可言。</p>
<p>再说一次，这需要权衡考虑。如果你明确知道需要重新获取什么数据，那么精细化控制让哪些<code>Query</code>失效是一个很好的实践方案。如果你希望代码尽量简单，宁愿频繁获取多一些数据也不希望错过重新回去的机会，那么重新获取所有匹配的活跃查询，并将其余标记为<code>stale</code>（过期）也可以。</p>
<p>过去，我们经常进行精细化重新验证，结果发现稍后需要添加的另一个资源与使用的失效模式不匹配。在那时，我们不得不遍历所有变化回调函数，看看是否需要重新获取该资源。这样做很麻烦且容易出错。</p>
<p>此外，我们通常为大多数查询使用中等大小的<code>staleTime</code>（大约2分钟）。因此，在无关的用户交互后进行失效的影响可以忽略不计。</p>
<p>当然，你可以使你的逻辑更复杂，使重新验证更智能化。以下是我过去使用过的一些技术：</p>
<h3>将其与<code>mutationKey</code>相关联。</h3>
<p><code>MutationKey</code>和<code>QueryKey</code>之间没有共同点，而且<code>MutationKey</code>也是可选的。如果需要的话，你可以通过使用<code>MutationKey</code>来指定应该失效哪些查询，从而将它们关联起来。</p>
<blockquote>
<p>如果你不需要标记一个 <code>mutation</code>，那么定义的时候不提供<code>mutationKey</code>也无所谓。</p>
</blockquote>
<pre><code class="language-js">const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) =&gt; {
      queryClient.invalidateQueries({
        queryKey: mutation.options.mutationKey,
      })
    },
  }),
})
</code></pre>
<p>这样一来就可以通过定义时的<code>mutationKey</code>去让对应<code>queryKey</code>的数据失效，触发重新执行对应的<code>queryFn</code>请求数据，如果你没有提供<code>mutationKey</code>，它仍然会让所有匹配的活跃查询失效。</p>
<h3>根据 staleTime 排除 Queries</h3>
<p>我经常通过给查询设置<code>staleTime: Infinity</code>来将其标记为“静态”。如果我们不希望这些查询失效，可以设置 <code>queryClient</code>实例的<code>staleTime</code>设置，并通过<code>断言（predicate）</code>过滤器来排除它们。</p>
<pre><code class="language-js">const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) =&gt; {
      const nonStaticQueries = (query: Query) =&gt; {
        // 获取默认的失效时间
        const defaultStaleTime =
          queryClient.getQueryDefaults(query.queryKey).staleTime ?? 0
        // 不同的 useQuery 使用相同的 queryKey 仅产生多个观察者，收集失效时间数组
        const staleTimes = query.observers
          .map((observer) =&gt; observer.options.staleTime)
          .filter((staleTime) =&gt; staleTime !== undefined)
                // 获取失效时间
        const staleTime =
          query.getObserversCount() &gt; 0
            ? Math.min(...staleTimes)
            : defaultStaleTime
                // 判断是否使用默认的失效机制
        return staleTime !== Number.POSITIVE_INFINITY
      }

      queryClient.invalidateQueries({
        queryKey: mutation.options.mutationKey,
        predicate: nonStaticQueries,
      })
    },
  }),
})
</code></pre>
<blockquote>
<p>invalidateQueries 中的 <code>predicate</code>函数将对每一个 <code>query</code>实例进行遍历，并且根据其返回的布尔值决定是否要让其失效。</p>
</blockquote>
<p>确定查询的实际<code>staleTime</code>并不是那么简单，因为<code>staleTime</code>是观察者级别的属性。但这是可行的，我们还可以将断言过滤器与其他过滤器（如<code>queryKey</code>）结合使用。很棒。</p>
<h3>使用 meta 选项</h3>
<p>我们可以使用<code>meta</code>字段来存储关于<code>mutation</code>的元数据（静态信息）。举个例子，我们可以添加一个<code>invalidates</code>字段来标记这个<code>mutation</code>，然后再用这些标记来模糊匹配我们希望失效的查询：</p>
<pre><code class="language-js">import { matchQuery } from &#39;@tanstack/react-query&#39;

const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: (_data, _variables, _context, mutation) =&gt; {
      queryClient.invalidateQueries({
        predicate: (query) =&gt;
          // 一次性让所有匹配的标签失效
          // 或者让所有活跃内容失效（亦或是 false 不让任何缓存失效）
          mutation.meta?.invalidates?.some((queryKey) =&gt;
            matchQuery({ queryKey }, query)
          ) ?? true,
      })
    },
  }),
})

// usage:
useMutation({
  mutationFn: updateLabel,
  meta: {
    invalidates: [[&#39;issues&#39;], [&#39;labels&#39;]],
  },
})
</code></pre>
<p>如上所示，我们通过<code>meta</code>字段让<code>issue</code>和<code>labels</code>匹配的项失效，触发其重新获取数据。</p>
<p>这里，我们仍然使用谓词函数来进行一次调用到<code>queryClient.invalidateQueries</code>。但在函数内部，我们使用<code>matchQuery</code>进行模糊匹配，你可以从 <code>React Query</code> 中导入这个函数。这个函数在将单个<code>queryKey</code>作为过滤器传递时内部也会使用，但现在我们可以用多个键来进行匹配。</p>
<p>这种模式比在<code>useMutation</code>的<code>onSuccess</code>回调函数中调用<code>queryClient.invalidateQueries</code>更好一些，至少我们不用每次都使用<code>useQueryClient</code>来引入<code>queryClient</code>。另外，这种模式还和默认让所有内容失效结合起来，非常灵活。</p>
<blockquote>
<p>在 TypeScript 项目中使用 meta 属性，需要修改其默认类型：</p>
<pre><code class="language-js">declare module &#39;@tanstack/react-query&#39; {
  interface Register {
    mutationMeta: {
      invalidates?: Array&lt;QueryKey&gt;
    }
  }
}
</code></pre>
</blockquote>
<h3>等还是不等？</h3>
<p>在上面的例子中我们几乎等待<code>invalidation</code>结束，如果你希望你的变更（mutation）尽快结束，那么这就够了。</p>
<p>我经常遇到一个具体的场景是希望所有内容都失效，但是却让<code>mutation</code>保持挂起的状态，直到其中若干重要的更新完成。例如，我希望变更标签数据后等待特定标签的<code>refetch</code>完成，但是并不等待其他同样<code>invalidation</code>的数据重新获取完成。</p>
<p>我们可以扩展一下<code>meta</code>对象来实现这个需求，举个例子：</p>
<pre><code class="language-js">useMutation({
  mutationFn: updateLabel,
  meta: {
    invalidates: [[&#39;labels&#39;, &#39;issues&#39;]],
    awaits: [[&#39;labels&#39;]],
  },
})
</code></pre>
<blockquote>
<p>以下内容为译者扩展，原文并未出现如何实现 awaits 控制的代码</p>
</blockquote>
<p>我们可以在配置 <code>queryClient</code>的时候，扩展<code>onSuccess</code>函数，内部检查是否提供<code>awaits</code>数组来控制返回值。</p>
<pre><code class="language-typescript"> mutationCache: new MutationCache({
    onSuccess(data, variables, context, mutation): unknown {
      queryClient.invalidateQueries({
        predicate: (query) =&gt;
          // invalidate all matching tags at once
          // or nothing if no meta is provided
          mutation.meta?.invalidates?.some((queryKey) =&gt;
            matchQuery({ queryKey }, query)
          ) ?? false,
      });
      const awaits = mutation.meta?.awaits;
      if (Array.isArray(awaits)) {
        return queryClient.invalidateQueries(
          { queryKey: awaits },
          { cancelRefetch: false }
        );
      }
    },
  }),
</code></pre>
<p>这里我们如果提供了<code>awaits</code>内容，就将<code>Promise</code>返回，<code>useMutation</code>处定义的<code>onSuccess</code>函数将会在这个<code>Promise</code>转为<code>resolve</code>状态之后才执行，如此一来我们就可以等待指定的<code>query</code>实例失效并且请求新数据之后再执行自己的<code>onSuccess</code>回调函数逻辑了。</p>
<p>回到原文。</p>
<p>或者，我们可以利用 <code>MutationCache</code> 上的回调在 <code>useMutation</code> 上的回调之前运行的机制，配合全局回调设置为使所有内容无效，再添加一个本地回调来等待我们想要的结果：</p>
<pre><code class="language-typescript">const queryClient = new QueryClient({
  mutationCache: new MutationCache({
    onSuccess: () =&gt; {
      queryClient.invalidateQueries()
    },
  }),
})

useMutation({
  mutationFn: updateLabel,
  onSuccess: () =&gt; {
    // returning the Promise to await it
    return queryClient.invalidateQueries(
      { queryKey: [&#39;labels&#39;] },
      { cancelRefetch: false }
    )
  },
})
</code></pre>
<p>这将会：</p>
<ul>
<li>全局配置中让所有匹配的 query 失效，但是在回调中我们既没有等待，也没有返回<code>Promise</code>内容，因此这是一个一劳永逸的失效行为</li>
<li>然后，我们本地提供的 <code>onSuccess</code>回调将会立即执行，我们可以主动返回一个仅让匹配<code>[&#39;labels&#39;]</code>查询<code>key</code>的失效 <code>Promise</code>状态，因此 <code>Mutation</code> 将保持待<code>pending</code>状态，直到重新获取<code>[&#39;labels&#39;]</code> 为止。</li>
</ul>
<blockquote>
<p><strong>cancelRefetch</strong></p>
<p>我们将 cancelRefetch 设置为 false 传递给 invalidateQueries，默认为 true 是因为我们通常希望命令式重新获取调用优先并取消当前正在运行的调用，以保证之后的数据是最新的。</p>
<p>但是在这里，情况刚好相反。由于我们的全局回调已经使所有内容无效，包括我们想要等待的查询，因此我们只需使用无效查询来“拾取”已经在运行的 Promise 并返回它。如果你不这样，那么就会看到一个针对<code>[&#39;labels&#39;]</code>的请求被创建。</p>
</blockquote>
<p>我认为这表明添加您熟悉的自动失效抽象并不需要很多代码。请记住，<code>每个抽象都有成本：它是一个新的 API，需要正确学习、理解和应用。</code></p>
<p>我希望通过展示所有这些可能性，可以更清楚地了解为什么我们没有在 <code>React Query</code> 中内置任何内容。找到一个足够灵活、能够覆盖所有情况而不臃肿的 API 并不是一件容易的事情。为此，我更愿意为您提供在用户空间中构建此工具的工具。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[想要钓鱼就要去鱼多的地方，想要赚钱就要将可以赚钱的方法重复实践]]></title>
            <link>https://i5lin.top/blog/post/2355907288</link>
            <guid>2355907288</guid>
            <pubDate>Sun, 16 Jun 2024 18:13:48 GMT</pubDate>
            <description><![CDATA[飞机耳 + 玉足]]></description>
            <content:encoded><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240617012026938.png" alt="飞机耳 + 玉足"></p>
<p>OK！继续来分享上一周接触到的一些讯息！</p>
<h2>Dozer</h2>
<p><img src="https://github.com/Mortennn/Dozer/raw/master/Stuff/demo.gif" alt=""> </p>
<p><a href="https://github.com/Mortennn/Dozer">Mortennn/Dozer: Hide menu bar icons on macOS</a> 是一个隐藏<code>macOS</code>菜单栏图标的开源程序，笔者体验下来内存占用为<code>45 M</code>左右，比此前自己使用的同类应用都小。</p>
<h2>NanaZip</h2>
<p><img src="https://github.com/M2Team/NanaZip/raw/main/Documents/ContextMenu.png" alt=""></p>
<p><a href="https://github.com/M2Team/NanaZip">M2Team/NanaZip: The 7-Zip derivative intended for the modern Windows experience</a> 7 - Zip 衍生的开源压缩和解压缩<code>Windows</code>软件，装机必备。</p>
<h2>Shiki 代码演示</h2>
<p><a href="https://github.com/shikijs/shiki-magic-move">GitHub - shikijs/shiki-magic-move: Smoothly animated code blocks with Shiki </a>是一个具有精美动画效果的代码演示工具，可以用来写一些教程或文档，甚至是面向开发者的特殊应用。使用<code>shikijs</code>可以展示非常精美的代码变化效果。</p>
<h2>Moria</h2>
<p><img src="https://github.com/s1ntoneli/Moria-dist/raw/main/Screenshot.png" alt=""></p>
<p><a href="https://github.com/s1ntoneli/Moria-dist">s1ntoneli/Moria-dist: Moria 分发</a> 是一个 Macos 平台的应用，可以<strong>在任意 App 中，快速搜索、执行菜单中的命令，节约时间</strong>！基于原生的菜单功能，通过全局快捷键<code>⌘+Shift+o</code>快速搜索当前应用的所有菜单功能，因此我们可以利用这个工具摆脱对鼠标的依赖，快速定位到菜单中的命令中去。<img src="https://github.com/s1ntoneli/Moria-dist/raw/main/moria-zh.gif" alt=""></p>
<h2>KeyCastr</h2>
<p><img src="https://github.com/keycastr/keycastr/raw/main/assets/mouse-click-visualizer.gif" alt=""></p>
<p><a href="https://github.com/keycastr/keycastr">keycastr/keycastr: KeyCastr, an open-source keystroke visualizer</a> 是一款开源的键盘镜像软件，可以在你输入的时候将键盘按键实时地显示在屏幕上，如果你想要展示自己的键盘操作，这是一个不错的选择。</p>
<h2>Tailwindcss 变体组合</h2>
<blockquote>
<p>类名变体笔者最初在<code>windicss</code>上看到，后续也在<code>unocss</code>中看到此插件，但是<code>tailwindcss</code>官方始终没有发布自己的插件</p>
</blockquote>
<p><a href="https://github.com/brandonmcconnell/tailwindcss-multi">brandonmcconnell/tailwindcss-multi: Variant-grouped utility support for Tailwind CSS</a>是一个<code>tailwindcss</code>的转换器插件，可以将如下类名进行转换：</p>
<pre><code class="language-jsx">&lt;div class=&quot;hover:multi-[bg-red-500;text-white]&quot;&gt;
  When hovered, this text is white and the background is red.
&lt;/div&gt;
</code></pre>
<p>转为:</p>
<pre><code class="language-jsx">&lt;div class=&quot;hover:bg-red-500 hover:text-white&quot;&gt;
  When hovered, this text is white and the background is red.
&lt;/div&gt;
</code></pre>
<p>需要注意的是，由于<code>tailwindcss</code>的破坏性更新，如果需要在<code>multi</code>内部使用嵌套和冒号，则需要额外添加<code>[]</code>。</p>
<h2>33 个技能点</h2>
<p><a href="https://github.com/stephentian/33-js-concepts">stephentian/33-js-concepts: :scroll: 每个 JavaScript 工程师都应懂的33个概念 @leonardomso</a></p>
<p>这个项目是为了帮助开发者掌握 <code>JavaScript</code> 概念而创立的。它不是必备，但在未来学习（<code>JavaScript</code>）中，可以作为一篇指南。</p>
<h2>Notion 风格的头像创作</h2>
<p><a href="https://notion-avatar.vercel.app/zh">Notion 风格头像制作</a>：可以在这里选择不同的贴图最终创建一个自己喜欢的<code>notion style</code>的头像</p>
<h2>IOS 开发课程</h2>
<p><a href="https://www.bilibili.com/video/BV1FG411J7b9/?spm_id_from=333.999.0.0&vd_source=657d9351ae87e8da9ec0f1670d72d27c">赵纯想最新录制｜《iOS开发课程-新手零基础版》Swift5.5 iOS16 SwiftUI4.0｜ 苹果iOS软件开发教程_哔哩哔哩_bilibili</a></p>
<h2>在线工具箱 - 腾讯出品</h2>
<p><a href="https://tool.browser.qq.com/">帮小忙，腾讯QQ浏览器在线工具箱平台</a> ：腾讯也来吃这口饭了，非常全面的工具箱，不过有些功能依然需要满足腾讯特色企业精神（充钱）。</p>
<h2>Git 从入门到应付日常工作</h2>
<p><a href="https://wgzhao.github.io/notes/misc/git-from-zero-to-hero/">Git从入门到应付日常工作 - 个人笔记</a> 这是一篇网上某作者的<code>Git</code>知识分享文档，对于日常使用<code>Git</code>的开发者来说，我个人感觉可以一看，或许对你有所帮助。</p>
<h2>最后</h2>
<p>六月十二日是我对象木木生日，祝她生日快乐！</p>
<blockquote>
<p>非常期待读者的点赞和支持，或多或少我都能从中得到鼓励❤️</p>
</blockquote>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[996 让我身心皆疲]]></title>
            <link>https://i5lin.top/blog/post/2329007295</link>
            <guid>2329007295</guid>
            <pubDate>Sat, 01 Jun 2024 08:30:01 GMT</pubDate>
            <description><![CDATA[喵，今天天气预告]]></description>
            <content:encoded><![CDATA[<p><img src="https://pbs.twimg.com/media/GNNlgVjbQAAu3eu?format=jpg&name=large" alt="喵，今天天气预告"></p>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>Node.js CLI Apps Best Practices</h2>
<p><img src="https://github.com/lirantal/nodejs-cli-apps-best-practices/raw/main/.github/node-js-cli-apps-best-practices.png" alt=""></p>
<p><a href="https://github.com/lirantal/nodejs-cli-apps-best-practices">lirantal/nodejs-cli-apps-best-practices: The largest Node.js CLI Apps best practices list ✨</a>  是一个指导性的仓库，主要介绍了开发<code>Node.js</code>命令行程序的最佳实践，如果你也需要开发命令行程序，非常推荐学习一下。</p>
<h2>速通 TypeScript</h2>
<p><a href="https://github.com/joye61/typescript-tutorial">joye61/typescript-tutorial: TypeScript速成教程（2小时速成）</a>：本教程以<strong>快速工程实践</strong>为目标，旨在让读者<strong>速成</strong>，能够迅速的GET到语言的核心知识点，并付诸实践！</p>
<p>此文最近更新于三年前，初始提交是五年前，其版本内容会缺少最近几年的新知识，不过难得之处在于作者写得非常简洁，值得不擅长<code>TypeScript</code>的开发者花两小时学习一下。</p>
<h2>Fuzzysort</h2>
<p><img src="https://camo.githubusercontent.com/e48f2780f5a126e6d01d109ace0fb70fb0194bf36e8f784da1b3df2e35597832/68747470733a2f2f692e696d6775722e636f6d2f61786b4f4d56732e706e67" alt=""></p>
<p><a href="https://github.com/farzher/fuzzysort">farzher/fuzzysort: Fast SublimeText-like fuzzy search for JavaScript.</a> 如果你需要在<code>JavaScript</code>生态下开发内容模糊搜索的功能，那么<code>fuzzysort</code>将会是一个很好的开源选项。</p>
<p><img src="https://camo.githubusercontent.com/e25c8399f5925447cfe16b162da891b73a07cf60e0f8a1dcce77964ba39c0f77/68747470733a2f2f692e696d6775722e636f6d2f6d7561773336332e676966" alt=""></p>
<p>其优点是：<code>零依赖</code>+<code>单文件</code>+<code>仅 5kb</code>+<code>快速反应</code>，根据作者的统计 13000 个适度大小的文件模糊搜索时间能保持在 1ms 以下。</p>
<h2>Windows Edeg 卸载</h2>
<p>微软并未在软件卸载程序中心提供<code>Edge</code>浏览器的卸载功能，因此我找到了下面这个程序来卸载浏览器：</p>
<p><a href="https://github.com/ShadowWhisperer/Remove-MS-Edge/">ShadowWhisperer/Remove-MS-Edge: Uninstall Microsoft Edge silently, through an executable or batch script.</a> </p>
<p>这是一个 windows edge 浏览器卸载工具，支持仅卸载 <code>edge</code> 的同时保存 <code>WebView</code>，以免某些依赖于<code>WebView</code>的应用出现问题。</p>
<h2>Velja</h2>
<p><a href="https://apps.apple.com/us/app/velja/id1607635845?mt=12">Velja on the Mac App Store</a> 快捷设置 macOS 默认浏览器的软件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240531170246090.png" alt="image-20240531170246090"></p>
<h2>Command X</h2>
<p><a href="https://sindresorhus.com/command-x">Command X — Sindre Sorhus</a> macOS 模拟 windows 使用<code>command</code>+<code>x</code>组合键剪切文件</p>
<h2>Quick ChatGPT</h2>
<p><a href="https://sindresorhus.gumroad.com/l/quickgpt">QuickGPT</a> Velja 和 Command X 的作者的另一个免费应用，调用了官方的接口，封装了一个 UI，配合系统快捷键可以快速切换和显示 ChatGPT，很好用。</p>
<h2>Notion 风格的头像生成应用</h2>
<p><a href="https://notion-avatar.vercel.app/zh">Notion 风格头像制作</a></p>
<h2>Pic Smaller</h2>
<p><a href="https://txx.cssrefs.com/">Pic Smaller – Compress JPEG, PNG, WEBP, AVIF, SVG and GIF images intelligently</a> 国人作者开发的一款开源的图片压缩应用，数据都在客户端，压缩操作也不经过服务器，压缩效果可以微调。</p>
<h2>极客时间电子书分享</h2>
<p><a href="https://github.com/it-ebooks-0/geektime-books">it-ebooks-0/geektime-books: :books: 极客时间电子书</a>：一个<code>github</code>上的电子书分享仓库。</p>
<h2>⌘+K</h2>
<p>很多应用都有内部的资源检索功能支持，如果你也需要编写类似的应用，可以考虑：</p>
<p><a href="https://cmdk.paco.me/">Fast, composable, unstyled command menu for React — ⌘K</a> </p>
<p>这是一个无样式组件，提供了强大的内容搜索逻辑控制，我们只需要为它添加自己喜欢的样式就好。</p>
<p>如果你使用<code>React</code>，那么也可以无缝使用：<a href="https://react-cmdk.com/">react-cmdk | Build your dream command palette</a> 这个带默认样式的组件</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240530202352404.png" alt="image-20240530202352404"></p>
<p>如果你使用<code>vue</code>，那么也有对应的封装库支持：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240530202327090.png" alt="image-20240530202327090"></p>
<h2>最后</h2>
<blockquote>
<p>非常期待读者的点赞和支持，或多或少我都能从中得到鼓励❤️</p>
</blockquote>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[时不我待，荒废可耻]]></title>
            <link>https://i5lin.top/blog/post/2261752519</link>
            <guid>2261752519</guid>
            <pubDate>Wed, 24 Apr 2024 16:53:28 GMT</pubDate>
            <description><![CDATA[我是一只飞回来的鸽子 🕊]]></description>
            <content:encoded><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/9870E7BD-9F76-4340-BD74-15EFE91579FB_1_105_c.jpeg" alt="9870E7BD-9F76-4340-BD74-15EFE91579FB_1_105_c"></p>
<p>OK！继续来分享上<code>N</code>周接触到了一些讯息！</p>
<h2>Synergy</h2>
<p><a href="https://symless.com/synergy"><a href="https://symless.com/synergy">Synergy - Share one mouse &amp; keyboard across computers</a></a>：免费的局域网内的跨设备键鼠共享软件，在不同的设备上安装这个软件，再通过很简单的地址配置即可在局域网内共享键盘鼠标和剪贴板。</p>
<p>我终于可以在自己的笔记本键盘上直接操作另外一台笔记本了，省去了买对拷线的钱和在另一台电脑上操作鼠标键盘、复制内容的麻烦。</p>
<p><img src="https://assets-global.website-files.com/5cb7274cc3cc0c1bc1771305/6476f4e878f4f4bae77fc713_screenlayout.gif" alt=""></p>
<p>如需下载，可以前往：<a href="https://github.com/DEAKSoftware/Synergy-Binaries"><a href="https://github.com/DEAKSoftware/Synergy-Binaries">DEAKSoftware/Synergy-Binaries: Download the latest stable Synergy binaries.</a></a> </p>
<h2>tailwind-merge</h2>
<img src="https://github.com/dcastil/tailwind-merge/raw/v2.3.0/assets/logo.svg" style="width: 100px" />

<p><a href="https://github.com/dcastil/tailwind-merge"><a href="https://github.com/dcastil/tailwind-merge">dcastil/tailwind-merge: Merge Tailwind CSS classes without style conflicts</a></a>：用于合并 Tailwind CSS 类，且在 JS 中不会产生样式冲突。</p>
<p>简单举个例子来说明为什么推荐了解这个库。</p>
<blockquote>
<p>使用 TypeScript 和 TailwindCSS</p>
</blockquote>
<p>我们首先来编写一个按钮组件：</p>
<pre><code class="language-react">import { PropsWithChildren } from &#39;react&#39;

interface ButtonProps extends PropsWithChildren {
  className?: string
}
export default function Button({ className, children }: ButtonProps) {
  return &lt;button className={`rounded rounded-md p-2 ${className}`}&gt;{children}&lt;/button&gt;
}
</code></pre>
<p>上述的例子可以给按钮一些默认的样式，以及添加自定义的类名来实现更多样式功能。但是也存在一些问题，例如：</p>
<ul>
<li>没有处理 <code>undefined</code>的特殊情况</li>
<li>仅在语法层面对传入的值进行类型标记，不够严谨</li>
<li>传入的类名会和默认的类名同时存在，产生代码冗余甚至是样式冲突。假设传入的 className 为 <code>rounded-lg</code>，最终无效的<code>rounded-md</code>也会生成到最终的样式表中去。为何我们喜欢<code>TailwindCSS</code>？或许有一点，就是重复利用类名的机制能让样式表非常轻巧。</li>
</ul>
<p>利用<code>tailwind-merge</code>我们可以非常方便地解决这个问题：</p>
<pre><code class="language-typescript">import { twMerge } from &#39;tailwind-merge&#39;

twMerge(&#39;px-2 py-1 bg-red hover:bg-dark-red&#39;, &#39;p-3 bg-[#B91C1C]&#39;)
// → &#39;hover:bg-dark-red p-3 bg-[#B91C1C]&#39;
</code></pre>
<p>如上所示，<code>twMerge</code>函数为我们实现了属性合并和去重的逻辑，甚至是能将一些复杂的类名简化，例如：</p>
<pre><code class="language-typescript">twMerge(&#39;left-0 top-0 right-0 bottom-0&#39;)
// 最终变成 inset-0
</code></pre>
<blockquote>
<p>即使是经验丰富的开发者，也可能会在编写 tailwindcss 类名的时候写出复杂的代码，或许自动对类名进行简化的 <code>eslint</code> 插件会是一个很好的选择。</p>
</blockquote>
<p>与此同时，<code>clsx</code>这个库也经常被大家使用于类名逻辑处理。</p>
<pre><code class="language-react">import { PropsWithChildren } from &#39;react&#39;
import clsx from &#39;clsx&#39;

interface ButtonProps extends PropsWithChildren {
  className?: string
}
export default function Button({ className, children }: ButtonProps) {
  return &lt;button className={clsx(&#39;rounded rounded-md p-2&#39;, className)}&gt;{children}&lt;/button&gt;
}
</code></pre>
<p><code>clsx</code>能帮我们处理空字符串和<code>undefined</code>传值的问题，甚至我们可以给<code>className</code>一个更好的类型定义来充分发挥<code>clsx</code>的能力。</p>
<pre><code class="language-react">import { ClassValue, clsx } from &quot;clsx&quot;
import { twMerge } from &quot;tailwind-merge&quot;

export function cn(...inputs: ClassValue[]) {
return twerge(clsx(inputs))
}
</code></pre>
<blockquote>
<p>PS:  推荐用 <a href="https://github.com/tailwindlabs/prettier-plugin-tailwindcss"><a href="https://github.com/tailwindlabs/prettier-plugin-tailwindcss">tailwindlabs/prettier-plugin-tailwindcss: A Prettier plugin for Tailwind CSS that automatically sorts classes based on our recommended class order.</a></a> 插件对 tailwindcss 类名进行排序，亦或是<a href="https://marketplace.visualstudio.com/items?itemName=heybourn.headwind"><a href="https://marketplace.visualstudio.com/items?itemName=heybourn.headwind">Headwind - Visual Studio Marketplace</a></a> 这个 vscode 插件来自动排序。</p>
</blockquote>
<p>快将这个函数放到你的武器库中去吧！</p>
<h2>useAnimations</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/El170D.png" alt="img"></p>
<p><a href="https://react.useanimations.com/"><a href="https://react.useanimations.com/">UseAnimations – React micro-animations library</a></a> 提供少数动画图标，每一个都有交互动画，优美有趣且实用，但是数量很少。</p>
<h2><a href="https://fontsource.org/">Fontsource</a></h2>
<p><a href="https://fontsource.org/">Fontsource</a> （字体资源包）项目简化了使用 Google Fonts 和其他开源字体的使用。它提供了 npm 模块，你可以为要使用的字体安装，非常方便。</p>
<h2>React type animation</h2>
<p><a href="https://react-type-animation.netlify.app/"><a href="https://react-type-animation.netlify.app/">React Type Animation</a></a> 是一个非常漂亮的 <code>React</code>文字输入动画库，你可以轻松用来创建打字机效果的文字描述动画。</p>
<h2>IOS 开发教程</h2>
<p><a href="https://cs193p.sites.stanford.edu/2023"><a href="https://cs193p.sites.stanford.edu/2023">斯坦福大学的 IOS 开发教程</a></a>，图文并茂，在世界互联网的任何一个角落即可免费学习世界顶尖大学的开发教程。</p>
<h2>React email</h2>
<p><a href="https://react.email/"><a href="https://react.email/">React Email</a></a>： 如果你需要为应用添加邮件相关的功能，那么这个库绝对值得了解一下。<code>React email</code>支持组合官方提供的一系列基础<code>React</code>组件渲染成<code>HTML</code>文本，因此我们可以非常方便地使用<code>React</code>设计发送给用户的邮件内容，此外官方文档也写得非常齐全，绝对是开箱即用。</p>
<blockquote>
<p><code>vue</code>也有类似的库，唯一需要注意的是部分 HTML 支持度不完整，例如图片格式不支持 SVG 等。</p>
</blockquote>
<p>在后端发送邮件，可以参考官方提供的以下方案：</p>
<ul>
<li>Resend</li>
<li>Nodemailer</li>
<li>SendGrid (推荐)</li>
<li>AWS SES</li>
<li>...</li>
</ul>
<h2>Earthly</h2>
<p><a href="https://earthly.dev/"><a href="https://earthly.dev/">Earthly - Make Builds Super Simple</a></a>：本地 CI/CD 开源工具，简洁易用。</p>
<h2>timeago.js</h2>
<p><a href="https://github.com/hustcc/timeago.js/tree/master">hustcc/timeago.js: :clock8: timeago.js is a tiny(2.0 kb) library used to format date with `*** time ago` statement.</a> </p>
<p>仅 <code>2kb</code> 的相对日期计算库，可以方便的计算某个时间到现在的相对时间，充足的测试用例可以让你放心使用。</p>
<h2>开源能力查询</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240424233750220.png" alt="image-20240424233750220"></p>
<p><a href="https://gitroll.io/"><a href="https://gitroll.io/">GitRoll | Learn your candidate&#39;s real coding skills in minutes.</a></a> 通过扫描目标用户的 <code>github</code> 代码，分析用户的开源能力信息。</p>
<p><strong>&quot;听说你在简历上写着热衷开源？&quot;</strong>，这下可以直接看看实力了。</p>
<h2><a href="https://www.hyperui.dev/">Hyper UI</a></h2>
<p><a href="https://www.hyperui.dev">Hyper UI</a> 分享了一系列基于<code>tailwindcss</code>的组件和源代码，可供开发者快速实现一些 UI 效果。</p>
<h2>最后</h2>
<p>好久没有记录一些内容了，坚持一件事真的很难，不过歇息了一阵子依然可以再出发。好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[前端 icon 图标解决方案]]></title>
            <link>https://i5lin.top/blog/post/2122658339</link>
            <guid>2122658339</guid>
            <pubDate>Wed, 07 Feb 2024 10:10:00 GMT</pubDate>
            <description><![CDATA[图标是 web 应用中常见的视觉元素之一，一直以来我都在寻找合适自己的图标解决方案，今天来介绍一下我最常用的一个方案。]]></description>
            <content:encoded><![CDATA[<p>图标是 web 应用中常见的视觉元素之一，一直以来我都在寻找合适自己的图标解决方案，今天来介绍一下我最常用的一个方案：<code>tailwindcss + icon plugin</code> !</p>
<img width="994" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/01f318ef-0ddf-446b-aa83-062fdbcd3cce">


<h2>Tailwindcss</h2>
<blockquote>
<p>如果你已经很熟悉<code>tailwindcss</code> ，可以跳过 😂</p>
</blockquote>
<p>在图标之前，先介绍一下<code>tailwindcss</code>: <a href="https://tailwindcss.com/"><a href="https://tailwindcss.com/">Tailwind CSS - Rapidly build modern websites without ever leaving your HTML.</a></a></p>
<p>使用这个工具，开发者只需要写某些类名即可，每一个类名都会在构建时编译到最终的样式表中。</p>
<p>这就意味着我们可以在整个项目中随处写类名，最后只会有一个类名及其样式存在于打包的样式表中。</p>
<p>看看下面这个例子：</p>
<pre><code class="language-bash">&lt;figure class=&quot;md:flex bg-slate-100 rounded-xl p-8 md:p-0 dark:bg-slate-800&quot;&gt;
  &lt;img class=&quot;w-24 h-24 md:w-48 md:h-auto md:rounded-none rounded-full mx-auto&quot; src=&quot;/sarah-dayan.jpg&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;512&quot;&gt;
  &lt;div class=&quot;pt-6 md:p-8 text-center md:text-left space-y-4&quot;&gt;
    &lt;blockquote&gt;
      &lt;p class=&quot;text-lg font-medium&quot;&gt;
        “Tailwind CSS is the only framework that I&#39;ve seen scale
        on large teams. It’s easy to customize, adapts to any design,
        and the build size is tiny.”
      &lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;figcaption class=&quot;font-medium&quot;&gt;
      &lt;div class=&quot;text-sky-500 dark:text-sky-400&quot;&gt;
        Sarah Dayan
      &lt;/div&gt;
      &lt;div class=&quot;text-slate-700 dark:text-slate-500&quot;&gt;
        Staff Engineer, Algolia
      &lt;/div&gt;
    &lt;/figcaption&gt;
  &lt;/div&gt;
&lt;/figure&gt;
</code></pre>
<p>你可以通过类名写几乎所有样式，<code>tailwindcss</code> 支持良好的媒体查询功能和主题和自定义样式。</p>
<p>最重要的是 <code>tailwindcss</code> 具有良好的插件系统和生态，官方的功能对动画的支持比较薄弱，但是在社区里存在<a href="https://www.tailwindcss-animated.com/"><a href="https://www.tailwindcss-animated.com/">Tailwind CSS Animated</a></a> 这样的插件，我们可以比较方便的用来写基础的动画。</p>
<blockquote>
<p>只要对组件进行良好的拆分，其实最终的类名也不会太长，况且我们还可以组合预处理器来使用。</p>
</blockquote>
<p>如果你需要更好的动画，则可以使用专业的动画库来实现相应的需求，例如：</p>
<ul>
<li><a href="https://www.framer.com/motion/"><a href="https://www.framer.com/motion/">Documentation | Framer for Developers</a></a></li>
<li><a href="https://gsap.com/docs/v3/GSAP/"><a href="https://gsap.com/docs/v3/GSAP/">GSAP | GSAP | Docs &amp; Learning</a></a></li>
<li><a href="https://animejs.com/"><a href="https://animejs.com/">anime.js • JavaScript animation engine</a></a></li>
<li><a href="https://www.react-spring.dev/"><a href="https://www.react-spring.dev/">react-spring</a></a></li>
<li><a href="https://threejs.org/"><a href="https://threejs.org/">Three.js – JavaScript 3D Library</a></a>（杀手级）</li>
</ul>
<p>每一个动画库都非常强大，或许选择其中一个进行深度使用就好。</p>
<h2>Icon</h2>
<p>我们可以使用<code>tailwindcss</code> 的插件 <a href="https://github.com/iconify/iconify/tree/main/plugins/tailwind"><a href="https://github.com/iconify/iconify/tree/main/plugins/tailwind">iconify/plugins/tailwind at main · iconify/iconify</a></a> 和 <a href="https://icones.js.org/"><a href="https://icones.js.org/">Icônes</a></a> 配合解决图标需求。</p>
<p>在按官方文档安装好插件之后，直接在 <a href="https://icones.js.org/"><a href="https://icones.js.org/">Icônes</a></a> 上搜索关键词就好。</p>
<p>在之前，我长期使用<a href="https://react-icons.github.io/react-icons/"><a href="https://react-icons.github.io/react-icons/">React Icons</a></a>作为图标解决方案，上面的图标种类非常齐全（仅部分截图）：</p>
<img width="785" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/e9730ee8-0377-4673-8804-0c4ba145db3b">


<p>而在我切换到<code>Vue</code> 技术栈之后，就无法再用这一个库了，机缘巧合下找到了<a href="https://icones.js.org/"><a href="https://icones.js.org/">Icônes</a></a>，这个站点是托尼老师开发的，资源非常丰富（部分截图）：</p>
<img width="1099" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/8a0c00ab-b648-47c9-9c55-64e1be33ce57">


<p>相比之前的库，这里有更多的资源，包括一些我很喜欢的动画图标。</p>
<blockquote>
<p><a href="https://react.useanimations.com/"><a href="https://react.useanimations.com/">UseAnimations – React micro-animations library</a></a> 少量的动画图标推荐</p>
</blockquote>
<p>话说回来，使用<a href="https://icones.js.org/"><a href="https://icones.js.org/">Icônes</a></a>再配合上作者开发的<a href="https://marketplace.visualstudio.com/items?itemName=antfu.iconify"><a href="https://marketplace.visualstudio.com/items?itemName=antfu.iconify">Iconify IntelliSense - Visual Studio Marketplace</a></a>插件，我们可以在<code>vscode</code> 里直接预览图标的效果，举个例子：</p>
<img width="398" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/62147a18-5831-469a-8d05-146b7980bf20">


<p>最后，使用<code>tailwindcss + icon 插件</code> 已经能满足我大多数关于样式和图标的需求。</p>
<p>在一些特殊的样式需求下，我还是可以用预处理器去写样式。在一些特殊的图标动画需求下，我们也可以使用专业的动画库，甚至是 Lottie 来实现动画效果（<a href="https://lottiefiles.com/"><a href="https://lottiefiles.com/">LottieFiles: Download Free lightweight animations for website &amp; apps.</a></a>）</p>
<img width="1031" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/65665f00-aee2-4251-8adf-5847412db987">


<p>相较于<code>gif</code> 方案，后者体积可以变得非常小，也提供了很多控制机制来满足用户的交互需求。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[工具推荐：高效的开发者工具 He3]]></title>
            <link>https://i5lin.top/blog/post/2116380682</link>
            <guid>2116380682</guid>
            <pubDate>Sat, 03 Feb 2024 09:22:17 GMT</pubDate>
            <description><![CDATA[Hello，大家好 ！今天给大家分享一款开发工具箱 `He3`。

`He3` 是一款开放、高效的开发者工具箱，到目前为止已经集成了超过 `500+`工具。

![image-20240203154816467](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240203154816467.png)
]]></description>
            <content:encoded><![CDATA[<p>Hello，大家好 ！今天给大家分享一款开发工具箱 <code>He3</code>。</p>
<p><code>He3</code> 是一款开放、高效的开发者工具箱，到目前为止已经集成了超过 <code>500+</code>工具。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240203154816467.png" alt="image-20240203154816467"></p>
<p>笔者第一次接触这个产品的时候，他们的产品还处于早期阶段，甚至还在招聘开发人员，官网和产品都做得比较粗糙，但是核心的几个功能已经完备了。</p>
<p>在配置新电脑的时候，我想起这个工具，于是进入了他们的官网准备下载客户端，无意间发现他们<code>升级了</code>，让我眼前一亮，这也是我重新分享这个工具的原因。</p>
<p><img src="https://he3app.com/section/bg01.png" alt=""></p>
<p>对于开发人员来说，我很满意他们以下的几个为我所用的核心功能：</p>
<h3>JSON 相关</h3>
<ul>
<li><code>JSON</code> 转 <code>TypeScript</code> 类型定义：日常开发中，我需要将后端同事的接口实例的数据重新定义为前端可用的接口类型，这个功能大大提高了我的效率。</li>
<li><code>JSON</code>格式比较：在某些场景下我需要对比两个 JSON 数据结构，这个功能非常有用，我不在需要其他独立的文件比较工具就能做简单的处理。</li>
<li><code>JSON</code>查看器</li>
</ul>
<p>此外，新版本还支持了一系列跟<code>JSON</code>相关的功能供用户选用。</p>
<h3>其他方向</h3>
<ul>
<li><p>文本处理</p>
</li>
<li><p>编解码和加密解密</p>
</li>
<li><p>图像处理</p>
<ul>
<li>证件照编辑</li>
<li>图片转图标</li>
<li>图片裁剪</li>
<li>水印</li>
<li>背景消除</li>
<li>格式转换</li>
<li>压缩</li>
</ul>
</li>
<li><p>颜色选择、转换</p>
</li>
<li><p>网络管理</p>
<ul>
<li>端口管理</li>
<li>短链接生成</li>
<li>用户代理解析器</li>
<li>等等</li>
</ul>
</li>
<li><p>音频处理（省去了我单独使用 FFMPEG 处理的需求）</p>
<ul>
<li>合并</li>
<li>压缩</li>
<li>转GIF</li>
<li>截取</li>
<li>调速</li>
<li>格式转换</li>
<li>提取音频</li>
</ul>
</li>
<li><p>日期时间处理</p>
</li>
<li><p>图床</p>
</li>
<li><p>文件共享</p>
</li>
<li><p>AI：做得非常全，但是功能并不出彩</p>
</li>
</ul>
<blockquote>
<p>此应用无广告，预计其主要收入来自于会员订阅，很多需要额外资源的功能（例如图床）都需要积分，每个月免费用户自动获得 100 积分，对我来说还是足够了</p>
</blockquote>
<h3>最后</h3>
<p><code>He3</code>支持多语言，其定价对于国内用户来说感觉还是不便宜的，尤其是最抠门（贫穷）的国内普通开发者来说。</p>
<p>此外，很开心开发团队还设置了<code>GitHub</code>讨论组，用于收集用户意见和建议，我们可以很轻松地联系上开发团队，并建言献策，我想这也是这个工具变得越来越好的原因之一。</p>
<p>好了，我们下次见。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[某种意义上来说工作提供了收入，身份和意义，失业的创伤]]></title>
            <link>https://i5lin.top/blog/post/2070872891</link>
            <guid>2070872891</guid>
            <pubDate>Mon, 08 Jan 2024 16:57:44 GMT</pubDate>
            <description><![CDATA[某种意义上来说工作提供了收入，身份和意义，失业的创伤。]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<p><img src="https://de4965e.webp.li/blog-images/2024/08/9e9036eafa0ceff5ffac052bb8530cf3.png" alt=""></p>
<blockquote>
<p>封面图：江苏·秋冬·红色的枫叶</p>
</blockquote>
<p>🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊</p>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>perplexity.ai</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240108230502068.png" alt="image-20240108230502068"></p>
<p><code>Perplexity.ai</code> 是一个聊天机器人式的<code>搜索引擎</code>，利用人工智能技术以自然语言提供问题的答案。它由大型语言模型提供支持，旨在帮助研究人员、作家、艺术家、音乐家和程序员等各种专业人士完成<code>回答问题</code>、<code>生成文本</code>、<code>撰写创意内容</code>和<code>总结文本</code>等任务。</p>
<p>最近还拿到了融资，发展得很好。</p>
<h2>Devv</h2>
<p><img src="https://github.com/devv-ai/devv/raw/main/assets/devv-twitter-bio.png" alt=""></p>
<p><a href="https://devv.ai/zh">Devv</a> 号称最懂程序员的新一代 <code>AI</code> 搜索引擎，见到挺多开发同行都提到这个引擎对代码的解释会比 ChatGPT 官方的回答细腻一些，作者是国人，支持一下！</p>
<h2>FireFox 多账户容器</h2>
<p><a href="https://support.mozilla.org/en-US/kb/containers">Multi-Account Containers | Firefox Help</a>：火狐用户可以在扩展商店搜索此插件，此插件深度支持一个多账户容器模式，它允许用户在同一浏览器窗口中创建多个容器，每个容器可以独立存储特定网站的 Cookie 和站点数据，从而实现在不同容器中登录同一网站的不同账号，或者将不同类型的网页活动分开。</p>
<p>也就是说用户可以更好地管理其在线活动，避免不同网站之间的数据共享，同时也能够更轻松地切换不同的在线身份和账号。笔者用这个模式同时创建了一个日常 youtube 账户和一个纯英文环境的 youtube 账户。</p>
<h2>产品 UI 创意借鉴</h2>
<p>前段时间在设计我的 Chrome 插件 <code>TabX</code> 的时候，看着自己的 UI 却想不出优化的点，属实是创意枯竭了。于是我立马去问了问千里之外的友人：“你经常去哪抄袭人家的设计？”</p>
<p>答曰：</p>
<ul>
<li><code>Behance</code>: <a href="https://www.behance.net/">Search Projects :: Photos, videos, logos, illustrations and branding :: Behance</a></li>
<li><code>Pinterest</code></li>
<li><code>Dribble</code></li>
</ul>
<p>如果你需要借鉴一下他人的设计，这其实也是可以的。</p>
<h2>青石 bluestone</h2>
<p><a href="https://www.bluemd.me/">Bluestone - markdown editing and sharing tools</a> 一款所见即所得的 markdown 编辑器，集成了 Mermaid 图形与 Katex 公式，支持明亮和暗黑风格，另外的亮点在于你可以使用这个工具配合其教程轻松将编辑的文本推送到远程，分享给其他人。</p>
<p>这个编辑器目前处于高速发展阶段，相比于付费产品<code>typora</code>来说，功能还是需要好好打磨和迭代，如果你需要一款免费的所见即所得的 <code>markdown</code>编辑器，可以体验体验。</p>
<h2>Electron Playground</h2>
<p><img src="https://github.com/tal-tech/electron-playground/raw/master/resources/readme/01.gif" alt=""></p>
<p><a href="https://github.com/tal-tech/electron-playground">tal-tech/electron-playground: This is a project to quickly experiment and learn electron related APIs</a> 一个快速尝试和学习<a href="https://github.com/electron/electron">electron</a>的项目，对electron的api进行了归纳和总结，对常用的业务功能做了demo演示。</p>
<p>我们可以学习、体验、调试和编辑代码，以此来掌握<code>Electron</code>开发的技术点。</p>
<h2>Vue TSX Admin</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20240108234140678.png" alt="image-20240108234140678"></p>
<p><a href="https://github.com/manyuemeiquqi/vue-tsx-admin">manyuemeiquqi/vue-tsx-admin: About a modern Vue Admin. It is based on Vue3 and TSX，It&#39;s flexible</a>，适用于需要快速创建<code>Vue3+TS</code>后台系统的场景。</p>
<h2>Picview</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20231205231916866.png" alt="image-20231205231916866"></p>
<p><a href="https://apps.apple.com/us/app/picview-image-photo-browser/id6452016140?mt=12">Picview - Image Photo Browser on the Mac App Store</a> 是一款 MacOS 预览看图应用，界面和交互非常精美。</p>
<h2>react-color</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20231218221946301.png" alt="image-20231218221946301"></p>
<p><a href="https://casesandberg.github.io/react-color/">React Color</a> 颜色选择器组件，功能非常完整。</p>
<h2>React-colorful</h2>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20231218224201399.png" alt="image-20231218224201399"></p>
<p><a href="https://omgovich.github.io/react-colorful/">react-colorful</a> 相比上面的<code>React color</code>组件，这个仅<code>2.8kb</code>大小，并且没有任何依赖项，缺点是功能少了些，但是也能满足较轻的颜色选择需求。</p>
<h2>Icon Horse</h2>
<p><a href="https://icon.horse">Icon Horse</a> 是一个图标解析服务，用户提供一个域名，他们返回此域名的 LOGO，如果不存在则返回默认 Logo 图标，这对于需要在应用产品开发中使用其他应用图标的场景，确实非常方便，开发者可以不用考虑自己去解决高质量应用图标的资源问题。</p>
<p>ps：免费月请求 1000 个图标，其他方案略贵（对于苦哈哈独立开发者而言）。</p>
<h2>Gemini Openai Proxy</h2>
<p><a href="https://github.com/zhu327/gemini-openai-proxy">Gemoni 转 OpenAI</a>：这是一个开源的谷歌 Gemini API 转 OpenAI 协议的网络代理服务，我们可以轻松使用 Docker 部署在本地或服务器上，然后在某些需要使用 OpenAI 的应用上配置这个服务的接口地址来使用 AI 相关的功能，比如我非常喜欢用<code>ChatGPT Translation</code> 翻译英文内容。如果使用遇到问题，还是需要看看文档。</p>
<h2>暴论 😂</h2>
<ul>
<li>代码注释是一种道歉，为未选择更清晰的名称或更合理的参数而道歉，为代码无法维护而道歉，为不使用知名算法而道歉，为编写&quot;聪明&quot;代码而道歉，为没有良好的版本控制系统而道歉，为未完成代码编写工作而道歉，为留下漏洞或代码中的缺陷而道歉。</li>
</ul>
<h2>最后</h2>
<p>周一鸽了，周二补上。</p>
<blockquote>
<p>非常佩服那些能坚持不懈，从不拖更的作者 😂</p>
</blockquote>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Biome 代替 prettier]]></title>
            <link>https://i5lin.top/blog/post/2022631263</link>
            <guid>2022631263</guid>
            <pubDate>Sun, 03 Dec 2023 17:19:25 GMT</pubDate>
            <description><![CDATA[hello 大家好~今天继续给大家带来我的新周刊内容。

<img width="1029" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/84d5b7eb-f87a-4269-b21d-05ffc4f660a3">


> 封面图：江苏·秋冬·红色的枫叶

OK！继续来分享上一周接触到]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<img width="1029" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/84d5b7eb-f87a-4269-b21d-05ffc4f660a3">


<blockquote>
<p>封面图：江苏·秋冬·红色的枫叶</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h3>CSS 技巧：高度自适应过度</h3>
<p>笔者在这里分享一个<code>CSS</code>高度过度动画的小技巧：在鼠标<code>hover</code>在某个元素上时，显示其子元素文本，同时添加一个动画效果。</p>
<blockquote>
<p>原文：<a href="https://dev.to/francescovetere/css-trick-transition-from-height-0-to-auto-21de?ref=dailydev"><a href="https://dev.to/francescovetere/css-trick-transition-from-height-0-to-auto-21de?ref=dailydev">🧙‍♂️ CSS trick: transition from height 0 to auto! - DEV Community</a></a></p>
</blockquote>
<p>举个例子：</p>
<pre><code class="language-html">&lt;div class=&quot;accordion&quot;&gt;
  &lt;div class=&quot;accordion-title&quot;&gt;Hover me!&lt;/div&gt;
  &lt;div class=&quot;accordion-body&quot;&gt;
    &lt;div&gt;
      &lt;p&gt;Lorem ipsum ...&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>你或许尝试过如下<code>CSS</code>样式来添加&quot;动画&quot;:</p>
<pre><code class="language-css">.accordion-body {
  height: 0;
  transition: 500ms height ease;
}

.accordion:hover .accordion-body {
  height: auto;
}
</code></pre>
<p>但是这个属性是无法实现动画的，如果你能确定容器的高度，那么可以使用<code>maax-height</code>属性来添加动画过度效果：</p>
<pre><code class="language-css">.accordion-body {
  max-height: 0;
  transition: 500ms max-height ease;
}

.accordion:hover .accordion-body {
  max-height: 200px;
}
</code></pre>
<p>最大高度的设定能触发渐变效果，鼠标<code>hover</code>的时候确实可以让高度实现渐变。</p>
<p>但是，很多时候我们无法确定内部元素的高度，最好的方案还是希望忽视其内容高度。我们可以使用<code>CSS Grid</code>属性来解决这个问题：</p>
<pre><code class="language-css">.accordion-body {
  display: grid; 
  grid-template-rows: 0fr;
  transition: 250ms grid-template-rows ease;
}

.accordion:hover .accordion-body {
  grid-template-rows: 1fr;
}

.accordion-body &gt; div {
  overflow: hidden;
}
</code></pre>
<p>Chrome 在去年这个时候发布的<code>v107</code>版本上支持了<code>grid-template-rows</code>的动画过渡支持，如果你想要在生产上使用这个特性，可能需要考虑一下兼容性。</p>
<blockquote>
<p>实在有这样的需求的话，也可以使用<code>JS</code>来实现。</p>
</blockquote>
<h3>Biome</h3>
<img width="1187" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/3078d9d8-bdc5-490f-b7f7-c4f4d711cc1d">


<p>前几天<code>algora</code>发起了使用<code>Rust</code>重写<code>prettier</code>工具的挑战，最终的赢家便是<code>Biome</code>!</p>
<p><a href="https://biomejs.dev/"><a href="https://biomejs.dev/">Biome</a></a> 是一款基于<code>Rust</code>语言开发的前端工具链，完美替代<code>prettier+eslint</code>。</p>
<p>你是否觉得<code>eslint+prettier</code>处理代码的速度变得难以忍受？不妨将其切换到<code>Biome</code>上来试试。</p>
<h3>Vienna</h3>
<p><a href="https://www.vienna-rss.com/#"><a href="https://www.vienna-rss.com/#">ViennaRSS – The Free and Open Source RSS/Atom Reader for macOS</a></a>免费开源的<code>RSS</code>阅读器，我用来作为<code>Readkit</code>的平替。</p>
<h3>Comprehensive Rust</h3>
<p><a href="https://google.github.io/comprehensive-rust/index.html"><a href="https://google.github.io/comprehensive-rust/index.html">Welcome to Comprehensive Rust 🦀 - Comprehensive Rust 🦀</a></a> 这是一份来自google安卓团队的免费<code>Rust</code>开发教程。</p>
<p>推荐给具有一定编程经验且并且打算学习<code>Rust</code>的朋友。</p>
<h3>Daily.dev</h3>
<p><a href="https://app.daily.dev/"><a href="https://app.daily.dev/">daily.dev | Where developers grow together</a></a> 开发者信息聚合应用，用户可以接收官方或者社区用户分享的技术讯息，主要内容都来源于国外，喜欢学习新知识的开发者应该会很喜欢。</p>
<h3>Web3.0 资讯整理</h3>
<p><a href="https://github.com/wangschang/web3.0"><a href="https://github.com/wangschang/web3.0">wangschang/web3.0: web3.0知识整理 web3.0知识 web3.0学习资料</a></a></p>
<h3>最后</h3>
<p>笔者上周感染了流感，目前还没完全恢复，大家别放松，尤其是家里有小孩的。</p>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaScript Class 浅解]]></title>
            <link>https://i5lin.top/blog/post/2004818507</link>
            <guid>2004818507</guid>
            <pubDate>Tue, 21 Nov 2023 17:39:12 GMT</pubDate>
            <description><![CDATA[在 2015 年的时候，class 才正式随着 ES6 的发布加入到了 JavaScript 家族中来。]]></description>
            <content:encoded><![CDATA[<p>在 2015 年的时候，<code>class</code>才正式随着<code>ES6</code>的发布加入到了<code>JavaScript</code>家族中来。</p>
<p>在写这个内容的时候，笔者对<code>class</code>的使用经验寥寥无几。因此，本文既是分享，也是学习。</p>
<p><img src="https://images.unsplash.com/photo-1534787238916-9ba6764efd4f?q=80&w=2531&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt=""></p>
<h2>起源</h2>
<blockquote>
<p>面向对象编程（Object-oriented programming，简称 OOP）是一种软件编程范式，它是一种基于对象和类的编程方法。</p>
</blockquote>
<p><code>类(class)</code>是面向对象编程中的重要概念，简单来说，开发者用<code>class</code>来创建对象的结构和行为的定义。</p>
<p>类的一些重要概念和特点包括：</p>
<ol>
<li><strong>封装（Encapsulation）</strong>：类允许将相关的数据和方法封装在一起，以实现对数据的隐藏和保护。通过访问修饰符（如私有、公共、受保护等），可以控制对类的成员的访问权限。</li>
<li><strong>继承（Inheritance）</strong>：类可以通过继承机制派生出子类，子类可以继承和扩展父类的属性和方法。继承支持代码的重用和创建层次结构。</li>
<li><strong>多态（Polymorphism）</strong>：多态允许对象在不同的上下文中表现出不同的行为。通过方法的重写和重载，可以在父类引用的基础上调用不同子类的方法。</li>
</ol>
<p>在<code>ES6</code>规范发布之前，<code>JavaScript</code>是没有<code>class</code>这个正式的概念的。但是语言规范的制定者和社区开发者们都需要<code>OOP</code>这样的编程范式来应对自己的需求。</p>
<p>在类出现在规范上之前，开发者创建对象的方式有很多种，并且都有自己各自的问题。我们会花一点时间逐一讨论这些方案。</p>
<h3>工厂函数</h3>
<p>首先是<code>工厂函数</code>创建对象：</p>
<pre><code class="language-js">function createPerson(name, age) {
  let o = new Object()
  o.name = name
  o.age = age
  o.sayName = function() {
    console.log(this.name)
  }
  return o;
}
const p1 = createPerson(&#39;Lily&#39;, 24);
const p2 = createPerson(&#39;Juice&#39;, 20)
</code></pre>
<p>利用工厂函数创建对象的不足在于<code>无法判断新创建的对象的类型</code>。</p>
<h3>构造函数</h3>
<p>在<code>JavaScript</code>中存在<code>构造函数</code>的概念，用于创建特定类型的对象。</p>
<p>一个典型的构造函数即一个以大写字母开头命名的函数，函数体内使用<code>this</code>来设置返回对象的属性，不需要显式创建对象和指定<code>return</code>对象，这也是跟工厂函数的差别之一：</p>
<pre><code class="language-js">function Person(name, age) {
  this.name = name
  this.age = age
  this.getAge = function() {
    console.log(this.age)
    return this.age
  }
}

// 通过构造函数创建对象
const p1 = new Person(&#39;July&#39;, 18);
const p2 = new Person(&#39;Rose&#39;, 18);
</code></pre>
<p>在很多初级 JavaScript 开发面试的时候有一道经典面试题，面试官可能会问使用<code>new</code>操作费创建对象会执行那些操作。</p>
<p>这个问题的答案如下：</p>
<ul>
<li>在内存中创建一个新对象</li>
<li>新对象的内部属性<code>[[prototype]]</code>被赋值给了构造函数的<code>prototype</code>属性</li>
<li>构造函数的<code>this</code>指向了新创建的对象</li>
<li>执行构造函数体内的逻辑（通常是给新创建的对象添加属性和方法）</li>
<li>如果构造函数返回非空对象，则返回此对象。否则，返回新创建的对象。（通常我们不会指定<code>return</code>返回值，默认返回的是新对象）</li>
</ul>
<p>如上所示的示例，<code>p1</code>存在以下属性连接：</p>
<pre><code class="language-js">p1.constructor === Person
</code></pre>
<p>显然，我们可以通过<code>constructor</code>来确定对象的类型是<code>Person</code>。</p>
<p>但是，大多数情况下你可能会看到开发者使用<code>instanceof</code>来确定对象的类型：</p>
<pre><code class="language-js">console.log(p1 instanceof Person); // true
</code></pre>
<p>构造函数创建对象解决了工厂函数无法确定对象类型的问题，但是还是有缺点：<code>每次创建的对象都会添加构造函数里定义的方法</code>。上述例子中创建的<code>p1</code>和<code>p2</code>对象都具有名为<code>getAge</code>的函数方法，二者虽然在定义的代码上看是相同的，实际却不等。</p>
<p>为了弥补构造函数这个瑕疵，我们可以利用<code>JavaScript</code>的原型模式来解决问题。</p>
<h3>原型模式</h3>
<p>我们知道，构造函数也是函数。每一个函数都有一个<code>prototype</code>属性，这个属性是一个对象，此对象上的属性和方法可以被所有由此构造函数创建的对象实例所共享。</p>
<blockquote>
<p>更多原型模式的知识推荐阅读《JavaScript 高级程序设计（第四版）》</p>
</blockquote>
<pre><code class="language-js">function Person() {}
Person.prototype.name = &#39;Rose&#39;
Person.prototype.getName = function() {
  console.log(this.name)
}
let p1 = new Person()
p1.getName(); // Rose
let p2 = new Person()
p2.getName(); // Rose
</code></pre>
<p>原型的关系如图所示：</p>
<p><img src="https://blog.ismeoh.com/usr/uploads/2023/10/4119007437.png" alt="img"></p>
<p>因此，<code>p1</code>和<code>p2</code>执行<code>getName</code>方法输出的是构造函数的<code>prototype（原型对象）</code>里共享的属性<code>name</code>。</p>
<p>原型是有层级的，构造函数的原型对象也是对象，因此也有原型。上述例子中，<code>Person</code>函数的原型对象的原型就是顶层对象的原型<code>Object.prototype</code>，因此<code>p1</code>对象可以调用<code>p1.toString()</code>方法。</p>
<p>这个方法源于<code>Object.prototype</code>原型对象，当我们给<code>p1</code>添加上<code>toString()</code>方法之后：</p>
<pre><code class="language-js">p1.toString = function() {
  console.log(&#39;p1&#39;)
}
</code></pre>
<p>它在调用时会先从自身搜索这个方法，不存在则往原型对象上搜索共享方法，直到<code>Object.prototype</code>对象为止。</p>
<p>上述例子我们主动添加了<code>toString()</code>方法，则后续调用时会执行此方法输入<code>p1</code>。</p>
<h3>原型继承</h3>
<p>很多面向对象语言中的继承包含接口继承和实现继承，而<code>JavaScript</code>中的函数没有类型签名，因此接口继承无从谈起。<code>JavaScript</code>中的继承即实现继承，主要由原型链的机制来实现。</p>
<blockquote>
<p>代码示例来源于《JavaScript 高级程序设计》</p>
</blockquote>
<p>我们来看如下的代码：</p>
<pre><code class="language-js">function SuperType() {
  // 设置 this 的属性
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
}

function SubType() {
  this.subProperty = false;
}

// 构造函数不使用默认原型，而是设置为 SuperType 的实例对象
// 补充：默认原型就是 Object.prototype
SubType.prototype = new SuperType();

SubType.prototype.getSubTypeValue = function() {
  return this.subProperty;
}

// 创建实例
let instance = new SubType();
console.log(instance.getSuperValue()); // 输出 true
</code></pre>
<p>如图所示：</p>
<img width="943" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/fd43ce22-79e4-441d-bd3d-b7eefc88ec01">


<p><code>SubType</code>构造函数创建的实例对象继承了<code>SuperType</code>的原型上的方法，因此可以调用<code>getSuperValue()</code>，并且在原型链上搜索<code>property</code>的时候，先从自身搜索、再从原型搜索。而原型恰好是<code>SuperType</code>的实例，因此原型上存在<code>property</code>属性。</p>
<p><code>JavaScript</code>的继承由此展开。</p>
<h3>原型继承的缺陷</h3>
<p>首先原型继承之后，继承的属性在不同的实例中是共享的。其次，子类型实例化的时候无法给父类型的构造函数传参。再次，子构造函数可以重新通过字面量的方式设置原型对象，从而会让之前的继承断裂。</p>
<h4>思索</h4>
<p>为了在创建实例的时候给父类型的构造函数传参，有人提出了一个“没什么用的”方案：</p>
<pre><code class="language-js">function SuperType(name) {
  this.name = name;
  this.colors = [&#39;red&#39;];
};

function SubType(name) {
  SuperType.call(this, name)
}

let instance = new SubType(&#39;Rose&#39;)
instance.colors.push(&#39;aliceblue&#39;)
console.log(instance.colors); // red, aliceblue
console.log(instance.name); // Rose

let instance2 = new SubType(&#39;Jay&#39;)
console.log(instance.colors); // red
console.log(instance.name); // Jay
</code></pre>
<p>不错吧，利用<code>call</code>函数可以给父类型构造函数传参了，实例也能通过父类型的属性初始化自己的属性，并且不会影响其他实例。</p>
<p>但是，这种被称为<code>盗用构造函数</code>的模式实例化的对象却无法使用父类型构造函数原型上的方法，因此很多人觉得这玩意你看了笑笑就好。</p>
<h3>原型式继承</h3>
<p>来看看这个函数：</p>
<pre><code class="language-js">function createObject(obj) {
  function F(){}
  F.prototype = obj
  return new F();
}
</code></pre>
<p>当我们传入一个对象的时候，返回值就是一个新的对象，这个新对象是<code>createObject</code>函数内临时构造函数<code>F</code>的实例，并且由于我们指定了这个实例的原型对象为传入的对象，那么最终返回的对象实例的原型就是传入的对象。</p>
<p>这在某种程度上也是一种继承方式，并且这种继承方式不需要我们定义构造函数。需要注意的是，这种方式所创建的对象会共享传入作为原型的对象，当你真的需要基于一个对象去快速创建新对象，并且需要共享这个原型对象的属性的话，这种方式确实很适合你。</p>
<h3>组合继承</h3>
<p>为了解决盗用构造函数模式的缺点，有人提出了<code>组合继承</code>的实现方案：</p>
<blockquote>
<p>组合什么？当然是组合原型继承和盗用构造函数模式继承的优点！</p>
</blockquote>
<pre><code class="language-js">function SuperType(name) {
  this.name = name
  this.color = [&#39;red&#39;]
}

SuperType.prototype.sayName = function() {
  console.log(this.name)
}

function SubType(name, age) {
  // 继承父类型 SuperType 的属性
  SuperType.call(this, name) // 第二次调用
  this.age = age
}
// 继承父类型原型上的方法
SubType.prototype = new SuperType() // 第一次调用

SubType.prototype.sayAge = function() {
  console.log(this.age)
}

let instance1 = new SubType(&#39;Rose&#39;, 18)
instance1.color.push(&#39;blue&#39;)
console.log(instance1.color) // red, blue
instance1.sayName() // Rose
instance1.sayAge() // 18

let instance2 = new SubType(&#39;Jay&#39;, 99)
console.log(instance1.color) // red 颜色是构造函数内创建的，独立的（当然实例的原型链上也有color，这个是共享的）
instance1.sayName() // Jay
instance1.sayAge() // 99
</code></pre>
<p>组合继承弥补了原型继承和盗用构造函数继承的缺点，因此被社区广泛接受和推广。</p>
<p><strong>但是</strong>，这种方式依然存在不足之处：<code>SuprtType()</code>被调用了两次。</p>
<p>后来，开发者们考虑到可以利用原型式继承去代替显式地创建<code>SuperType</code>的实例对象设置原型的方案。</p>
<pre><code class="language-js">function SuperType(name) {
  this.name = name;
  this.color = [&#39;red&#39;]
}

SuperType.prototype.sayName = function() {
  console.log(this.name)
}

function SubType(name, age) {
  SuperType.call(this, name)
  this.age = age
}

function inheritProperty(subType, superType) {
  let prototype = createObject(superType.prototype); 设置父类型的原型，创建一个对象作为原型对象
  prototype.constructor = subType; // 修复了原型上 constructor 的指向
  subType.prototype = prototype; // 设置子类型原型对象
}

inheritProperty(SubType, SuperType); // 通过原型式继承设置原型，而非显式通过 new SuperType 创建原型

// 增强原型
SubType.prototype.sayAge = function() {
  console.log(this.age)
}
</code></pre>
<p>如此一来即可只调用一次<code>SuperType</code>原型函数，并且最终<code>SubType</code>对象实例的<code>instanceof</code>依然有效。这</p>
<p>这就是<code>ES6</code>之前的继承最佳模式，也是那个时候开发者编写<code>OOP</code>范式代码的基础。</p>
<h3>ES6 Class</h3>
<p>在<code>ES6</code>发布之后，<code>Class</code>正式为类和面向对象编程提供了语言规范级别的定义，开发者们可以不必再处理冗长的继承逻辑代码，直接使用官方提供的新语法糖<code>Class</code>即可。</p>
<p>举个例子，首先是简单的类：</p>
<pre><code class="language-js">// 不可实例化的抽象基类，通过 new.target 控制使其无法通过 new 实例化，从而得到一个仅用于继承的基类
class Animal {
  // 使用 new 调用操作符创建类的实例的时候会调用这个构造函数（但这个构造函数是可选的，不包含构造函数的类定义也是合法的）
  constructor(name) {
    // 实例化的时候检测到 target 为 Animal 即抛出异常
    if (new.target === Animal) {
      throw new Error(&quot;Animal class cannot be instantiated.&quot;);
    }
    this.name = name;
  }

  // 访问器
  get getName() {
    return this.name;
  }

  // 实例方法
  makeSound() {
    console.log(&quot;Some generic sound&quot;);
  }

  // 静态方法
  static staticMethod() {
    console.log(&quot;Animal static method called&quot;);
  }

  // 生成器
  *generateSounds() {
    yield &quot;Sound 1&quot;;
    yield &quot;Sound 2&quot;;
  }

  // 迭代器
  [Symbol.iterator]() {
    let index = 0;
    const sounds = [&quot;Sound 1&quot;, &quot;Sound 2&quot;];
    return {
      next: () =&gt; ({
        value: sounds[index++],
        done: index &gt; sounds.length,
      }),
    };
  }
}
</code></pre>
<blockquote>
<p>Class 是特殊的函数：<code>typeof Animal</code>输出<code>function</code>，因此你想要将之定义在数组中、像其他对象或函数引用一样作为参数传递亦或是立即实例化、查看原型都是可以的，即使我们平时几乎不会这么做。</p>
</blockquote>
<p>为了实现多继承，使用<code>混入</code>机制：</p>
<pre><code class="language-js">// 混入实现多继承
const SoundMixin = {
  // 实例方法
  makeSound() {
    console.log(&quot;Mixin sound&quot;);
    // 使用 super 调用基类方法
    super.makeSound();
  }

  // 新的实例方法
  additionalMethod() {
    console.log(&quot;Mixin additional method&quot;);
  },

  // 新的静态方法
  staticMixinMethod() {
    console.log(&quot;Mixin static method&quot;);
  }
};
</code></pre>
<p>继续，添加一个子类，并且子类继承父类：</p>
<pre><code class="language-js">// 使用混入创建一个新类
class Dog extends Animal {
  constructor(name, breed) {
    // 派生类必须选择：1.调用 super 函数 2.显式 return 一个对象
    super(name);
    this.breed = breed;
  }

  // 重写父类方法
  makeSound() {
    console.log(&quot;Woof! Woof!&quot;);
    // 使用 super 调用基类方法
    super.makeSound();
  }

  // 新的实例方法
  fetch() {
    console.log(&quot;Fetching the ball&quot;);
  }
}
</code></pre>
<p>接着使用混入机制将混入的对象设置为类的原型，再来创建类的实例：</p>
<blockquote>
<p>super 只能在派生类（继承了其他类的类）构造函数和静态方法中使用，并且在 constructor 函数内先于<code>this</code>使用之前调用<code>super()</code>（等同于调用父类的构造函数）</p>
</blockquote>
<pre><code class="language-js">// 将混入的方法添加到子类
Object.assign(Dog.prototype, SoundMixin);

// 创建类的实例
const myDog = new Dog(&quot;Buddy&quot;, &quot;Golden Retriever&quot;);

// 调用实例方法
myDog.makeSound();                // 输出: Woof! Woof! \n Some generic sound
myDog.additionalMethod();         // 输出: Mixin additional method

// 调用静态方法
Dog.staticMethod();               // 输出: Animal static method called
Dog.staticMixinMethod();          // 输出: Mixin static method

// 使用访问器
console.log(myDog.getName);       // 输出: Buddy

// 使用生成器
for (const sound of myDog.generateSounds()) {
  console.log(sound);
}

// 使用迭代器
for (const sound of myDog) {
  console.log(sound);
}
</code></pre>
<blockquote>
<p>上述的代码示例涉及了类许多的知识点，但如果你想更加详细地了解类，欢迎阅读《JavaScript 高级程序设计》。</p>
</blockquote>
<h3>优化类相关的代码</h3>
<h4>方法链</h4>
<p>在创建类的实例方法定义时，推荐使用方法链模式：</p>
<blockquote>
<p>当链变长的时候，连续调用的代码会更加简洁和清晰，你可以在像<code>lodash</code>、<code>rxjs</code>这样的库上看到这样的模式。</p>
</blockquote>
<pre><code class="language-js">// 不推荐的写法
class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
  }

  setModel(model) {
    this.model = model;
  }

  setColor(color) {
    this.color = color;
  }

  save() {
    console.log(this.make, this.model, this.color);
  }
}

const car = new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;);
car.setColor(&quot;pink&quot;);
car.save();
</code></pre>
<p>推荐优化：</p>
<pre><code class="language-js">class Car {
  constructor(make, model, color) {
    this.make = make;
    this.model = model;
    this.color = color;
  }

  setMake(make) {
    this.make = make;
    // NOTE: Returning this for chaining
    return this;
  }

  setModel(model) {
    this.model = model;
    // NOTE: Returning this for chaining
    return this;
  }

  setColor(color) {
    this.color = color;
    // NOTE: Returning this for chaining
    return this;
  }

  save() {
    console.log(this.make, this.model, this.color);
    // NOTE: Returning this for chaining
    return this;
  }
}

const car = new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;);
car.setColor(&quot;pink&quot;)
  .save();
</code></pre>
<h4>组合和继承的选择</h4>
<p>组合和继承各自有各自的优点，选择哪种模式取决于具体的场景，但是我们也有可以参考的点：</p>
<ul>
<li>继承侧重于二者具有<code>is-a(是一个....)</code>的关系，而非<code>has-a(有一个...)</code></li>
<li>当基类代码具有高度的可重用性时，继承会更好</li>
<li>当你希望通过修改一次基类即可让全局都能响应变更</li>
</ul>
<p>上述三点似乎有些抽象，让我们来看一个代码示例：</p>
<pre><code class="language-js">class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // ...
}

// Bad because Employees &quot;have&quot; tax data. EmployeeTaxData is not a type of Employee
// 使用继承并非良策：雇员有数据，而数据并不是一种雇员
class EmployeeTaxData extends Employee {
  constructor(ssn, salary) {
    super();
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}
</code></pre>
<p>优化代码：</p>
<pre><code class="language-js">class EmployeeTaxData {
  constructor(ssn, salary) {
    this.ssn = ssn;
    this.salary = salary;
  }

  // ...
}

class Employee {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  setTaxData(ssn, salary) {
    // 直接在设置数据的时候，组合不同对象的实例
    this.taxData = new EmployeeTaxData(ssn, salary);
  }
  // ...
}
</code></pre>
<h4>单一职责</h4>
<p>一个类应该只有一个引起它变化的原因，如果一个类负责太多不同的事情，那么当其中某个功能发生变化的时候，就可能导致整个类需要修改，这使得代码更加脆弱、难以维护和理解。</p>
<p>将类设计得简洁、保持单一性，有利于减少修改类的逻辑的次数，这样能够降低引入错误的风险，对于阅读代码的人来说也更有好处。</p>
<p>举个反面例子：</p>
<pre><code class="language-js">class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
</code></pre>
<p>优化一下，将验证内容分离出去：</p>
<pre><code class="language-js">class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
</code></pre>
<p>当我们需要修改验证逻辑的时候，就不会修改任何<code>UserSettings</code>的内容了，这在代码变得复杂之后，效果尤为明显。</p>
<h4>打开和关闭原则</h4>
<p>这是面向对象设计中的&quot;开闭原则&quot;（Open/Closed Principle）的表述。Bertrand Meyer指出，软件实体（如类、模块、函数等）应该对扩展开放，但对修改关闭。理解这一原则主要包括以下几个方面：</p>
<ol>
<li><p><strong>对扩展开放（Open for Extension）：</strong> 意味着系统的设计应该允许在不修改现有代码的情况下引入新功能。新的功能可以通过添加新的代码、新的类、或者新的模块来实现，而不需要修改已经存在的代码。</p>
</li>
<li><p><strong>对修改关闭（Closed for Modification）：</strong> 意味着一旦一个软件实体（如类）被创建并投入使用，就不应该再对其进行修改。这样可以确保已有的代码在添加新功能时不会受到影响，从而提高系统的稳定性和可维护性。</p>
</li>
</ol>
<p>具体来说，这一原则的目的是为了避免在引入新功能时对已有的代码进行修改，因为这样的修改可能引入错误，破坏已有的功能，或者导致不稳定性。相反，通过允许扩展现有系统，可以保持系统的稳定性，并且更容易维护。</p>
<p>一个常见的实践是通过使用抽象接口和多态性来实现开闭原则。通过定义接口或抽象类，系统的不同部分可以通过实现这些接口或继承这些抽象类来扩展功能，而无需修改已有的代码。这样的设计使得系统更具弹性，更容易适应变化。</p>
<p>举个例子：</p>
<pre><code class="language-js">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &quot;ajaxAdapter&quot;;
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &quot;nodeAdapter&quot;;
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === &quot;ajaxAdapter&quot;) {
      return makeAjaxCall(url).then(response =&gt; {
        // transform response and return
      });
    } else if (this.adapter.name === &quot;nodeAdapter&quot;) {
      return makeHttpCall(url).then(response =&gt; {
        // transform response and return
      });
    }
  }
}

function makeAjaxCall(url) {
  // request and return promise
}

function makeHttpCall(url) {
  // request and return promise
}
</code></pre>
<p>上面的例子里，让开发者需要添加新的网络适配器的时候，就必须修改基础的<code>HttpRequester</code>类的逻辑，让我们来优化一下：</p>
<pre><code class="language-js">class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = &quot;ajaxAdapter&quot;;
  }

  request(url) {
    // request and return promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = &quot;nodeAdapter&quot;;
  }

  request(url) {
    // request and return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then(response =&gt; {
      // transform response and return
    });
  }
}
</code></pre>
<p>在适配器中提供相同的<code>request</code>方法，从而提高了扩展性，又不需要修改基础类的逻辑。</p>
<h4>里式替换</h4>
<p>Liskov Substitution Principle（LSP）是面向对象设计中 SOLID 原则的一部分，强调了子类型（子类）应该能够替代其基类型（基类）而不引起问题。LSP的存在有几个重要原因：</p>
<ol>
<li><p><strong>可替代性（Substitutability）：</strong> LSP确保了在程序中的任何需要基类型的地方都可以安全地使用子类型，而不需要了解具体的子类型。这提高了代码的可复用性和灵活性。</p>
</li>
<li><p><strong>一致性和可预测性：</strong> 当子类型可以替代基类型时，程序的行为更为一致和可预测。如果在使用基类型的地方使用子类型，程序的行为应该与基类型的预期行为一致，而无需考虑具体的子类型。</p>
</li>
<li><p><strong>简化设计和理解：</strong> LSP鼓励设计者创建简单一致的类层次结构。通过确保子类型可以替代基类型，我们避免了在使用这些类型时需要进行过多的条件判断或特例处理。这样的设计更易于理解和维护。</p>
</li>
<li><p><strong>降低耦合度：</strong> 当子类型可以替代基类型时，系统的各个部分之间的耦合度降低。这意味着可以更轻松地对系统进行修改和扩展，而不会引入意外的行为或破坏现有的功能。</p>
</li>
<li><p><strong>便于测试：</strong> LSP有助于创建更容易测试的代码。如果子类型可以替代基类型，我们可以使用基类型的实例或模拟来进行测试，而不需要在测试时专门处理每个具体的子类型。</p>
</li>
</ol>
<p>总体而言，Liskov Substitution Principle在面向对象设计中的价值在于创建更为一致、可扩展和可维护的代码，提高代码的质量和可读性，同时减少引入错误的风险。</p>
<p>编写继承的代码时，子类如需新增功能，则尽可能避免新功能方法名与父类方法重名，以免让父类方法调用时出错。</p>
<p>准确地说，继承复用的关键在于不影响原功能，子类应该能够替代基类而不引起错误！</p>
<p>举个例子：</p>
<pre><code class="language-js">class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  // 正方形特有的行为
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}
</code></pre>
<p>在这个例子中，<code>Square</code> 类继承自 <code>Rectangle</code> 类，因为正方形可以被视为一种特殊情况的长方形。然而，由于正方形要求宽度和高度始终相等，<code>Square</code> 类覆盖了 <code>setWidth</code> 和 <code>setHeight</code> 方法以保持这一特性。</p>
<p>现在，让我们看一个使用这些类的情况：</p>
<pre><code class="language-js">function calculateArea(rectangle) {
  rectangle.setWidth(5);
  rectangle.setHeight(10);
  return rectangle.getArea();
}

const rectangle = new Rectangle(5, 10);
console.log(calculateArea(rectangle)); // 输出 50

const square = new Square(5);
console.log(calculateArea(square)); // 输出 25，而不是预期的 50
</code></pre>
<p>在这个例子中，<code>calculateArea</code> 函数期望一个长方形，但当我们将一个正方形传递给它时，由于正方形覆盖了 <code>setWidth</code> 和 <code>setHeight</code> 方法，导致最终计算的面积不符合预期。这就违反了 Liskov Substitution Principle。</p>
<p>推荐的写法如下：</p>
<pre><code class="language-js">class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach(shape =&gt; {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
</code></pre>
<h4>依赖反转原则</h4>
<p>依赖反转原则（Dependency Inversion Principle，DIP）是面向对象设计原则之一，提倡高层模块不应该依赖于底层模块，二者都应该依赖于抽象；而抽象不应该依赖于细节，细节应该依赖于抽象。这个原则有助于实现松耦合，提高代码的灵活性和可维护性。</p>
<p>先看一个正面例子：</p>
<pre><code class="language-js">// 定义抽象的消息发送器接口
class MessageSender {
  send(message) {}
}

// 实现具体的邮件发送器
class EmailSender extends MessageSender {
  send(message) {
    console.log(`Sending email: ${message}`);
  }
}

// 实现具体的短信发送器
class SmsSender extends MessageSender {
  send(message) {
    console.log(`Sending SMS: ${message}`);
  }
}

// 高层模块（业务逻辑）依赖于抽象
class NotificationService {
  constructor(messageSender) {
    this.messageSender = messageSender;
  }

  sendNotification(message) {
    this.messageSender.send(message);
  }
}

// 使用示例
const emailSender = new EmailSender();
const smsSender = new SmsSender();

const notificationServiceWithEmail = new NotificationService(emailSender);
notificationServiceWithEmail.sendNotification(&quot;Hello via email!&quot;);

const notificationServiceWithSms = new NotificationService(smsSender);
notificationServiceWithSms.sendNotification(&quot;Hello via SMS!&quot;);
</code></pre>
<p>再看一个反面例子：</p>
<pre><code class="language-js">// 高层模块直接依赖于底层模块的具体实现，违反了依赖反转原则
class NotificationServiceViolatingDIP {
  constructor() {
    this.emailSender = new EmailSender();
  }

  sendNotification(message) {
    this.emailSender.send(message);
  }
}

// 使用示例
const notificationServiceViolatingDIP = new NotificationServiceViolatingDIP();
notificationServiceViolatingDIP.sendNotification(&quot;Hello via email!&quot;);
</code></pre>
<p>如此一来，高层模块和邮件发送器耦合性很紧密，如果要扩展发送器类型则需要修改高层模块代码，相对正面例子来说灵活性和可维护性都有所降低。</p>
<h2>最后</h2>
<p>关于<code>JavaScript</code>类的分享就到这里了，下次我将分享一些关于测试的内容。</p>
<p>Bye.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[程序员逃不掉的加班]]></title>
            <link>https://i5lin.top/blog/post/2002671843</link>
            <guid>2002671843</guid>
            <pubDate>Mon, 20 Nov 2023 17:23:09 GMT</pubDate>
            <description><![CDATA[加班不断，周刊易断。]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<blockquote>
<p>质量 &gt; 数量</p>
</blockquote>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/5dd67be7-09ea-4843-b18b-7b175e6b1210" alt="image"></p>
<blockquote>
<p>封面图：毛孩子</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>Code Piper</h2>
<p><a href="https://apps.apple.com/cn/app/code-piper/id1669959741?mt=12">Mac App Store 上的“Code Piper”</a>是一款 MacOS 短信验证码复制工具。有时候我们在笔记本上需要输入手机验证码，切换、查看、复制粘贴手机或笔记本的验证码真的还不够方便，使用这个工具能让短信验证码自动提取到剪贴板，非常方便。</p>
<h2>Stackoverflow Design</h2>
<p><a href="https://stackoverflow.design/">Stacks</a>提供了在整个 <code>Stack Overflow</code> 中快速设计、构建和交付连贯体验所需的一切 - 从品牌和产品本身，到我们发送电子邮件和撰写文案的方式。读者可以从中了解到关于 <code>Stack Overflow</code>设计理念的方方面面。</p>
<h2>图拉鼎谈独立开发</h2>
<p><a href="https://www.usmacd.com/cn/tulading/">图拉鼎谈独立开发 | 安全代码</a></p>
<h2>布谷 TV</h2>
<p><a href="https://www.bugutv.org/">布谷TV | 4K电影下载-免费下载4K电影、美剧、演示片、蓝光原盘，超高清、无水印！</a></p>
<h2>最后</h2>
<p>上周说脱离<code>996</code>是假消息，还是得继续肝。</p>
<p>此外，不愿意卷的同事已经被送走了，就业环境太差了，祝福。</p>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[珍爱生命，远离 996]]></title>
            <link>https://i5lin.top/blog/post/1991192289</link>
            <guid>1991192289</guid>
            <pubDate>Mon, 13 Nov 2023 18:11:28 GMT</pubDate>
            <description><![CDATA[最近工作直接进入 996 的节奏，感觉心脏都不舒服了]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<p><img src="https://de4965e.webp.li/blog-images/2024/08/72cc7340c66fa1e6a47ef778f6eb3471.png" alt="玫瑰花对猫咪无害"></p>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>Kagi</h2>
<p><img src="https://cdn.sspai.com/2023/11/05/32f926a99d42b93c13ea59d19610411b.png" alt=""></p>
<p><a href="https://type.cyhsu.xyz/2023/11/kagi/">Kagi - neverland</a>：一篇关于新生收费搜索引擎<code>Kagi</code>的分享。搜索引擎付费？你确定？</p>
<p><strong>TL;DR</strong></p>
<p><strong>The Good:</strong></p>
<ul>
<li>整洁有序、反内容农场、高度可定制的搜索结果</li>
<li>草根引擎中少见可接受的中文结果</li>
<li>完善而不招摇的 AI 功能</li>
</ul>
<p><strong>The Bad:</strong></p>
<ul>
<li>面对「生活日常」类检索的响应比较木讷</li>
<li>定价过高</li>
</ul>
<p><strong>The Ugly:</strong></p>
<ul>
<li>搜索引擎不是一个对小玩家友好的市场，能活多久除了实力也看运气</li>
</ul>
<p>...</p>
<blockquote>
<p>看完这篇文章之后，对于我这种每日都需要进行互联网搜索的用户来说，免费反而会阻碍我获取更有价值的知识，于是我立马分享给了我朋友。</p>
</blockquote>
<h2>Zod</h2>
<img src="https://zod.dev/logo.svg" style="width: 230px" />

<p><a href="https://zod.dev/">Zod</a> 是一个用于构建 JavaScript 和 TypeScript 应用程序的库，主要专注于运行时类型检查和验证。</p>
<p>它提供了一种声明式的方式来定义和验证数据结构，包括对象、数组、字符串等。Zod 是由 Vercel 团队开发的，旨在帮助开发者更轻松地处理数据验证和类型安全。</p>
<p>如果你使用<code>Node.js</code>开发<code>Web API</code>系统，那么这个库可以非常方便地为你提供数据结构验证功能。</p>
<p>并且，你可以在这里得到一些教程：<a href="https://www.totaltypescript.com/tutorials/zod">Zod Tutorial | Total TypeScript</a>！</p>
<h2>System Design 101</h2>
<p><img src="https://github.com/ByteByteGoHq/system-design-101/raw/main/images/banner.jpg" alt=""></p>
<p>用图文来传授系统设计相关的知识。</p>
<h2>最后</h2>
<p>好了，今天的分享较少，笔者参与的公司项目即将结束，终于快要能从 996 的日子逃出来了。大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[骑行使我快乐]]></title>
            <link>https://i5lin.top/blog/post/1977892714</link>
            <guid>1977892714</guid>
            <pubDate>Sun, 05 Nov 2023 17:52:04 GMT</pubDate>
            <description><![CDATA[
---
description: 大家好~今天继续给大家带来我的新周刊内容。
cover: https://github.com/Developer27149/blog/assets/23721611/3c5f8d90-980e-45c3-8e0e-f3921fed1fd8
---

hello 大家好~今天继续给大家带来我的新周刊内容。

![image](https://gi]]></description>
            <content:encoded><![CDATA[<hr>
<h2>description: 大家好~今天继续给大家带来我的新周刊内容。
cover: <a href="https://github.com/Developer27149/blog/assets/23721611/3c5f8d90-980e-45c3-8e0e-f3921fed1fd8">https://github.com/Developer27149/blog/assets/23721611/3c5f8d90-980e-45c3-8e0e-f3921fed1fd8</a></h2>
<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/3c5f8d90-980e-45c3-8e0e-f3921fed1fd8" alt="image"></p>
<blockquote>
<p>封面图：大耗子咪咪</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>编程字体预览</h2>
<p><a href="https://www.programmingfonts.org/">Programming Fonts - Test Drive</a>：支持 <code>132</code> 种编程字体效果预览，轻松找到一款你喜欢的字体。</p>
<h2>Verctorizer AI</h2>
<p><a href="https://vectorizer.ai/">Trace Pixels To Vectors in Full Color, Fully Automatically, Using AI - Vectorizer.AI</a> 将像素图转为全彩色矢量SVG 图片的 AI 工具。</p>
<h2>清华大学计算机系课程攻略</h2>
<p><a href="https://rekcarc-tsc-uht.readthedocs.io/en/latest/index.html">Welcome to THU-CST-Cracker! — THU-CST-Cracker documentation</a>：作者收集了自己在清华计算机大学生活的学习知识资源，在网上发布了这份课程攻略，内容非常丰富。考不上清华没关系，要不要跟着人家学学试试看？</p>
<h2>CanvasStudy</h2>
<p><a href="https://827652549.github.io/CanvasStudy/">CanvasStudy | HTML5 Canvas的中文系列学习教程，也可作为查阅工具，简单上手。</a></p>
<h2>Medium Parser</h2>
<p><a href="https://github.com/Xatta-Trone/medium-parser-extension">Xatta-Trone/medium-parser-extension: Unlock medium.com using google web cache</a> 一款支持跳过 Medium 会员检测的 Chrome 插件，能让你免费阅读 medium 的文章。</p>
<h2>Harmony</h2>
<p>[haydenbleasel/eslint-config-harmony: Unified, strict and opinionated editor configuration for modern React apps. <code>Harmony</code> 是现代 <code>TypeScript</code> 应用程序的 <code>ESLint</code> 配置。它旨在与 <code>Prettier</code> 和 <code>Stylelint</code> 一起使用。</p>
<h2>Knock</h2>
<p><a href="https://knock.app/">Knock | Notifications infrastructure for developers</a> Knock 是灵活、可靠的通知基础架构，可随您一起扩展。使用我们的 API 来吸引用户、支持跨渠道工作流并管理通知首选项。</p>
<h2>最后</h2>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaScript Function]]></title>
            <link>https://i5lin.top/blog/post/1972822593</link>
            <guid>1972822593</guid>
            <pubDate>Wed, 01 Nov 2023 17:46:44 GMT</pubDate>
            <description><![CDATA[给 JavaScript 开发者关于 JavaScript 函数的建议。]]></description>
            <content:encoded><![CDATA[<p><img src="https://github.com/Developer27149/blog/assets/23721611/e861d7e8-86d4-408f-9ef7-6862835e7751" alt="image"></p>
<h2>创建简明函数</h2>
<blockquote>
<p>声明：实际开发中的代码可能会更加复杂，后续的示例将尽可能简单。</p>
</blockquote>
<p>编写简明的 JavaScript 函数需要注重的有以下几点</p>
<ul>
<li>简明的函数名</li>
<li>结构良好的函数参数</li>
<li>简明的函数注释（可选）</li>
</ul>
<p>其中，函数名即变量名，因此我可以参考上一篇关于变量的命名建议来命名。其次，函数参数不宜超过 2 个，单一的函数参数易于测试。</p>
<p>超过两个函数参数就可以使用对象进行传参，并且使用<code>ES6</code>的解构语法进行解构。使用对象传参和对象解构能提高可读性，阅读者可以通过函数签名轻松了解函数参数。而在函数内，开发者也可以灵活地使选用传入的参数来处理自己的逻辑。</p>
<p>在函数解构的时候将会从传入的对象克隆其原始数据类型的属性，而对象和数组不会进行克隆，在使用的时候需要明确这一点，以免修改了外部的属性，从而引发难以察觉的<code>Bug</code>。</p>
<p>通过解构还有一个好处，那就是诸如<code>ESLint</code>此类工具可以检测开发者解构了未使用的变量，这对于优化代码可读性和整洁性很有帮助。</p>
<p>最后，推荐大家保持良好的代码注释。我们可以使用<code>JSDoc</code>来简单描述函数参数类型和函数功能，以便于后续阅读调用的函数时能提供良好的签名提示。</p>
<blockquote>
<p>使用 VSCode 可以安装 JSDoc 的插件，便于编写 Doc</p>
</blockquote>
<p>下面是一个例子：</p>
<pre><code class="language-js">// 不好的例子❌
function createMenu(title, body, buttonText, cancelable) {
  // ...
};
// 参数众多，在调用的时候就难以直白地理解其参数的含义
createMenu(&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;, true);

// 推荐的写法 ✅

/**
 * 创建菜单
 *
 * @param {Object} options - 选项对象
 * @param {string} options.title - 菜单标题
 * @param {string} options.body - 菜单内容
 * @param {string} options.buttonText - 按钮文本
 * @param {boolean} options.cancellable - 是否可取消
 * @returns {void}
 */
function createMenu({ title, body, buttonText, cancellable }) {
  // ...
}

// 即使不看函数签名，光从调用的时候传参的属性名我们就能了解到传如的参数的大致含义
createMenu({
  title: &quot;Foo&quot;,
  body: &quot;Bar&quot;,
  buttonText: &quot;Baz&quot;,
  cancellable: true
});
</code></pre>
<h2>单一原则</h2>
<blockquote>
<p>软件工程中最重要的准则之一就是“函数应该只做一件事”。</p>
</blockquote>
<p>功能越多的函数，其复杂度就越高，并且难以编写、测试和理解。当我们将函数单独隔离开来，让一个函数仅处理一件事，那么这个函数将会非常易于重构。如果你需要修改某个复杂流程中的某个函数的单一功能，那么修改功能单一的函数就能让复杂度降低到最小。</p>
<p>简单地说，单一功能的函数专注于解决一个具体的问题，并且具有清晰的输入和输出。</p>
<p>举个例子：</p>
<pre><code class="language-js">// 不推荐的写法 ❌
function emailClients(clients) {
  clients.forEach(client =&gt; {
    const clientRecord = database.lookup(client);
    if (clientRecord.isActive()) {
      email(client);
    }
  });
}

// 推荐的写法 ✅
function emailActiveClients(clients) {
  clients
    .filter(isActiveClient)
    .forEach(email);
}

function isActiveClient(client) {
  const clientRecord = database.lookup(client);
  return clientRecord.isActive();
}
</code></pre>
<p>这或许并不是一个很好的例子，但确实能够体现函数仅做一件事的理念。<code>isActiveClient</code>和<code>email</code>函数分别实现自己单一的功能：</p>
<ul>
<li><code>isActiveClient</code>:判断客户端是否可用</li>
<li><code>email</code>:发送邮件</li>
</ul>
<p>而<code>emailClients</code>函数将所有逻辑全部封装在一起，当我们需要修改逻辑的时候，就需要理解更多的上下文。</p>
<h2>函数应该仅有一层抽象</h2>
<p>来看这个例子，我们需要一个<code>parseBetterJSAlternative()</code>函数将代码进行解析和构建语法树进行更多的抽象处理：</p>
<pre><code class="language-js">// 不推荐 ❌
unction parseBetterJSAlternative(code) {
  const REGEXES = [
    // 若干正则表达式...
  ];
    
  // 语句拆分
  const statements = code.split(&quot; &quot;);
  const tokens = [];
  REGEXES.forEach(REGEX =&gt; {
    statements.forEach(statement =&gt; {
      // 遍历处理语句...
    });
  });

  const ast = [];
  tokens.forEach(token =&gt; {
    // 遍历 token，构建抽象语法树...
  });

  ast.forEach(node =&gt; {
    // 解析语法树...
  });
}
</code></pre>
<p>在上述函数中，函数体内需要处理多层抽象逻辑，接下来我们试试把多层抽象独立出去：</p>
<pre><code class="language-js">// 推荐 ✅
// 构建 tokens
function tokenize(code) {
  const REGEXES = [
    // ...
  ];

  const statements = code.split(&quot; &quot;);
  const tokens = [];
  REGEXES.forEach(REGEX =&gt; {
    statements.forEach(statement =&gt; {
      tokens.push(/* ... */);
    });
  });

  return tokens;
}

// 解析 tokens
function parse(tokens) {
  const syntaxTree = [];
  tokens.forEach(token =&gt; {
    syntaxTree.push(/* ... */);
  });

  return syntaxTree;
}

// 单层抽象函数实现
function parseBetterJSAlternative(code) {
  const tokens = tokenize(code);
  const syntaxTree = parse(tokens);
  syntaxTree.forEach(node =&gt; {
    // parse...
  });
}
</code></pre>
<p>相较而言，后者对多层抽象进行拆分，可以提高代码的可读性、降低代码的复杂性。</p>
<h2>去除重复代码</h2>
<blockquote>
<p>我们可以尽最大努力避免重复代码，即使我们现在很忙。</p>
</blockquote>
<p>重复代码是不好的，因为这意味着如果你需要更改某些逻辑，那么就会有多个地方需要更改，这是一件容易遗漏的事情。</p>
<p>重复代码的来源通常是我们需要处理若干件不同的事情，但这些需求里存在通用的逻辑，并且其存在某些特殊的差别让你“不得不”创建多段重复代码来实现这些需求。</p>
<p>为了去除重复代码，我们需要创建一个函数、模块或类来抽象其中的逻辑以应对不同需求的差异。</p>
<blockquote>
<p>尽管糟糕的抽象比重复的代码更加恶心，但还是推荐大家去尝试创建良好的抽象逻辑，不要重复编写代码，否则你或其他人可能会在需要修改的时候花费很大的力气。</p>
</blockquote>
<p>让我们来看看一个重复的代码示例：</p>
<pre><code class="language-js">// 不推荐 ❌
function showDeveloperList(developers) {
  developers.forEach(developer =&gt; {
    const expectedSalary = developer.calculateExpectedSalary();
    const experience = developer.getExperience();
    const githubLink = developer.getGithubLink();
    const data = {
      expectedSalary,
      experience,
      githubLink
    };

    render(data);
  });
}

function showManagerList(managers) {
  managers.forEach(manager =&gt; {
    const expectedSalary = manager.calculateExpectedSalary();
    const experience = manager.getExperience();
    const portfolio = manager.getMBAProjects();
    const data = {
      expectedSalary,
      experience,
      portfolio
    };

    render(data);
  });
}
</code></pre>
<p>接下来，我们将重复的逻辑抽离出来：</p>
<pre><code class="language-js">// 推荐 ✅
function showEmployeeList(employees) {
  employees.forEach(employee =&gt; {
    // 一致的逻辑
    const expectedSalary = employee.calculateExpectedSalary();
    const experience = employee.getExperience();
        // 通用的数据
    const data = {
      expectedSalary,
      experience
    };
        // 单独的属性
    switch (employee.type) {
      case &quot;manager&quot;:
        data.portfolio = employee.getMBAProjects();
        break;
      case &quot;developer&quot;:
        data.githubLink = employee.getGithubLink();
        break;
    }

    render(data);
  });
}
</code></pre>
<h2>使用 Object.assign 设置默认对象属性</h2>
<p>之前提及多个参数的函数建议优化成单一参数并且使用对象传参，这里我们继续来看一个参数是对象的函数例子：</p>
<pre><code class="language-js">// 不推荐 ❌
const menuConfig = {
  title: null,
  body: &quot;Bar&quot;,
  buttonText: null,
  cancellable: true
};

function createMenu(config) {
  config.title = config.title || &quot;Foo&quot;;
  config.body = config.body || &quot;Bar&quot;;
  config.buttonText = config.buttonText || &quot;Baz&quot;;
  config.cancellable =
    config.cancellable !== undefined ? config.cancellable : true;
}

createMenu(menuConfig);
</code></pre>
<p>上述代码使用<code>||</code>符号来设置初始值，可读性不佳。我们可以使用<code>Object.assign</code>函数来构建一个具有初始化值的新对象：</p>
<pre><code class="language-js">// 推荐 ✅
const menuConfig = {
  title: &quot;Order&quot;,
  // 参数不包含 body 属性
  buttonText: &quot;Send&quot;,
  cancellable: true
};

function createMenu(config) {
  // 克隆的同时，如果不传入某属性，则使用默认值
  const finalConfig = Object.assign(
    {
      title: &quot;Foo&quot;,
      body: &quot;Bar&quot;,
      buttonText: &quot;Baz&quot;,
      cancellable: true
    },
    config
  );

  // finalConfig: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}
  // ...
}

createMenu(menuConfig);
</code></pre>
<h2>不要使用 Flag 作为函数的参数</h2>
<p>接下来看一个使用<code>Flag(标志)</code>作为参数的函数例子：</p>
<pre><code class="language-js">// 不推荐 ❌
function createFile(name, temp) {
  if (temp) {
    fs.create(`./temp/${name}`);
  } else {
    fs.create(name);
  }
}
</code></pre>
<p>使用<code>Flag</code>参数则通常表示函数内部需要处理不同的参数值，这就意味着函数需要处理更多的逻辑问题，相较而言更推荐功能单一的函数：</p>
<pre><code class="language-js">// 简明且单一的函数是更推荐的写法 ✅
function createFile(name) {
  fs.create(name);
}

function createTempFile(name) {
  createFile(`./temp/${name}`);
}
</code></pre>
<p>在工作中我们需要处理的函数逻辑会更加复杂，与此同时功能单一的函数的好处就更加明显。</p>
<h2>消除副作用</h2>
<p>单一功能函数在执行过程中如果对外部的环境产生了可观察的影响，那么我们就可以称之为产生了<code>副作用</code>。</p>
<p>比如：</p>
<ul>
<li>修改外部变量</li>
<li>修改全局变量</li>
<li>发起网络请求</li>
<li>抛出异常</li>
<li>修改<code>DOM</code></li>
<li>写文件</li>
<li>...</li>
</ul>
<p>在软件开发中函数存在副作用是必不可少的，毕竟我们需要执行一些副作用的逻辑来实现需求。因此，我们可以尽可能地使用单个函数去处理单个的副作用。</p>
<p>接下来来看代码例子：</p>
<pre><code class="language-js">// 不推荐 ❌
function addToCart(item) {
  let cart = localStorage.getItem(&#39;cart&#39;); // 从本地存储中获取购物车数据
  if (cart) {
    cart = JSON.parse(cart);
    cart.push(item); // 修改购物车数据
  } else {
    cart = [item];
  }
  localStorage.setItem(&#39;cart&#39;, JSON.stringify(cart)); // 将购物车数据写回本地存储
  console.log(&#39;Item added to cart&#39;);
}

addToCart({ id: 1, name: &#39;Product A&#39;, price: 10 }); // 调用函数
</code></pre>
<p>在上述示例中，<code>addToCart</code> 函数用于将商品添加到购物车。函数首先从本地存储中获取购物车数据，然后将新商品添加到购物车数据中，最后将更新后的购物车数据写回本地存储。函数还在控制台输出添加商品到购物车的信息。</p>
<p>该函数存在多个副作用。首先，它修改了本地存储的购物车数据，即全局状态。其次，它依赖于本地存储中的数据进行操作。此外，函数还使用 <code>console.log</code> 方法在控制台输出信息。</p>
<p>为了减少副作用并提高函数的可测试性和可维护性，可以将本地存储的读写操作封装成独立的函数，并将其作为依赖传递给 <code>addToCart</code> 函数：</p>
<pre><code class="language-js">// 推荐 ✅
function getCartFromLocalStorage() {
  const cart = localStorage.getItem(&#39;cart&#39;);
  return cart ? JSON.parse(cart) : [];
}

function saveCartToLocalStorage(cart) {
  localStorage.setItem(&#39;cart&#39;, JSON.stringify(cart));
}

function addToCart(item, getCart, saveCart) {
  let cart = getCart();
  cart.push(item);
  saveCart(cart);
  console.log(&#39;Item added to cart&#39;);
}

addToCart(
  { id: 1, name: &#39;Product A&#39;, price: 10 },
  getCartFromLocalStorage,
  saveCartToLocalStorage
);
</code></pre>
<p>在这个修改后的示例中，我们将本地存储的读写操作封装成了独立的函数 <code>getCartFromLocalStorage</code> 和 <code>saveCartToLocalStorage</code>。然后，我们修改了 <code>addToCart</code> 函数的签名，使其接受这两个函数作为参数。</p>
<blockquote>
<p>在上述代码示例中，我们还可以继续抽象出通用的<code>localStorage</code>读取和存储的函数，后续可以更好地复用。</p>
</blockquote>
<p>这样，函数内部不再直接操作全局状态，而是通过传递的函数来获取和保存购物车数据。这样做可以减少副作用，使函数更加可控、可测试和可维护。</p>
<h2>不轻易给内置对象的原型添加函数</h2>
<p>在<code>JavaScript</code>中，我们可以给内置对象的原型赋值以增强其灵活性，举个例子：</p>
<pre><code class="language-js">// 不推荐 ❌
Array.prototype.diff = function diff(comparisonArray) {
  const hash = new Set(comparisonArray);
  return this.filter(elem =&gt; !hash.has(elem));
};
</code></pre>
<p>上述代码为数组原型添加了一个<code>diff</code>函数，如此一来开发者便可以在不同的地方直接调用这个函数。这是一个非常灵活的机制，但或许过于灵活了。</p>
<p>这样的代码通常在某些新特性的<code>polyfill</code>代码中出现，并不推荐我们在日常的开发中添加这样的函数，同样的运行环境中可能存在不同的人开发的代码功能，编写这样的全局函数可能会带来难以预测的问题。</p>
<h2>封装条件</h2>
<p>看示例：</p>
<pre><code class="language-js">// 不推荐 ❌
// 如果请求正在发送中，并且当前列表为空
if(request.isLoading === true &amp;&amp; list.length === 0) {
  // ...
}
</code></pre>
<p>如上所示是非常常见的逻辑条件判断的代码，更推荐的做法是可以将这类条件封装成起来使用：</p>
<pre><code class="language-js">// 推荐 ✅
const shouldShowSpinner = (request, list) =&gt; {
  return request.isLoading &amp;&amp; isEmpty(list)
}

if(shouldShowSpinner(request, list)) {
  //...
}
</code></pre>
<h2>避免否定条件</h2>
<p>不好的例子❌：</p>
<pre><code class="language-js">function isClientNotPrepare(client) {
  // ...
}
if(!isClientNotPrepare(client)) {
  // ...
}
</code></pre>
<p>推荐的做法✅:</p>
<pre><code class="language-js">function isClientPrepare(client) {
  // ...
}
if(isClientPrepare(client)) {
  // ...
}
</code></pre>
<h2>删除不再使用的代码</h2>
<p>不再使用的代码跟重复的代码一样糟糕，尽管删除这些遗留无用的代码吧，如果你确实需要这些代码，那么你还是可以从代码版本管理工具中找到它们。</p>
<p>不推荐的代码 ❌</p>
<pre><code class="language-js">function oldRequestModule(url) {
  // ...
}

function newRequestModule(url) {
  // ...
}

const req = newRequestModule;
inventoryTracker(&quot;apples&quot;, req, &quot;www.inventory-awesome.io&quot;);
</code></pre>
<p>推荐将<code>oldRequestModule</code>函数清理掉。</p>
<h2>减少回调函数</h2>
<p>JavaScript 函数应该避免回调地狱，这是因为回调地狱会导致代码难以理解、调试和维护。</p>
<p>假设我们有一个需求：从服务器获取用户信息，然后根据用户信息获取其订单列表，最后获取每个订单的详细信息。如果使用回调函数来实现，可能会出现回调地狱的情况。</p>
<p>以下是代码示例：</p>
<pre><code class="language-js">getUserInfo(function(userInfo) {
  getOrderList(userInfo.userId, function(orderList) {
    orderList.forEach(function(order) {
      getOrderDetails(order.orderId, function(orderDetails) {
        // 处理订单详细信息
        console.log(orderDetails);
      });
    });
  });
});
</code></pre>
<p>在上面的代码中，每个异步操作都有一个回调函数，而且这些回调函数嵌套在一起，形成了回调地狱。这使得代码难以阅读和理解，而且在处理错误和异常时也变得困难。</p>
<p>为了避免回调地狱，可以使用一些现代的 JavaScript 技术，例如 Promise、async/await 或使用异步库（如 async.js 或 Bluebird）来处理异步操作。</p>
<p>下面是使用 Promise 和 async/await 改写上述代码的示例：</p>
<pre><code class="language-js">getUserInfo()
  .then(function(userInfo) {
    return getOrderList(userInfo.userId);
  })
  .then(function(orderList) {
    return Promise.all(orderList.map(function(order) {
      return getOrderDetails(order.orderId);
    }));
  })
  .then(function(orderDetailsList) {
    orderDetailsList.forEach(function(orderDetails) {
      // 处理订单详细信息
      console.log(orderDetails);
    });
  })
  .catch(function(error) {
    // 处理错误
    console.error(error);
  });
</code></pre>
<p>使用 async/await：</p>
<pre><code class="language-js">async function processOrders() {
  try {
    const userInfo = await getUserInfo();
    const orderList = await getOrderList(userInfo.userId);
    const orderDetailsList = await Promise.all(orderList.map(async function(order) {
      return await getOrderDetails(order.orderId);
    }));

    orderDetailsList.forEach(function(orderDetails) {
      // 处理订单详细信息
      console.log(orderDetails);
    });
  } catch (error) {
    // 处理错误
    console.error(error);
  }
}

processOrders();
</code></pre>
<p>相较之下，使用<code>async/await</code>语法糖是最简洁的，笔者也比较推荐大家保持<code>async/await</code>语法糖的代码风格。</p>
<h2>最后</h2>
<p>好了，关于函数的分享就到此为止了，后续笔者会继续分享<code>class</code>的建议。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JavaScript variable suggestions for rookie]]></title>
            <link>https://i5lin.top/blog/post/1968808775</link>
            <guid>1968808775</guid>
            <pubDate>Mon, 30 Oct 2023 16:47:58 GMT</pubDate>
            <description><![CDATA[给 JavaScript 初级开发者关于变量的一些建议]]></description>
            <content:encoded><![CDATA[<img width="295" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/433603f0-6583-44ab-a195-a89768b36e17">

<h2>含义明确且可发音朗读的变量名</h2>
<p>举个例子，我们需要一个变量保存当前的日期</p>
<pre><code class="language-js">// 不够好的命名
// momentjs 提供的格式化函数，将给定特殊的字符串匹配模式传入生成一个与之匹配的字符串
const yyyymmdstr = moment().format(&quot;YYYY/MM/DD&quot;); 

// 推荐的命名
const currentDate = moment().format(&quot;YYYY/MM/DD&quot;);
</code></pre>
<h2>可搜索、可重用的名称</h2>
<p>在我们的编程生涯中，阅读代码有时候甚至比编写代码花费更多的时间。编写可读性高、易于搜索和重用的代码非常重要。</p>
<p>举个例子，我们需要在半小时之后执行某个函数：</p>
<pre><code class="language-js">const fn = () =&gt; {}
// 不推荐的写法
setTimeout(fn, 1800)
// 稍微好一些的代码
setTimeout(fn, 60 * 30)
// 推荐写法
const HALF_HOUR = 60 * 30; // 具有明确意义、可读性高、易于搜索，甚至推荐使用模块来保存项目中的这些常量
setTimeout(fn, HALF_HOUR);
</code></pre>
<h2>避免隐式代码</h2>
<blockquote>
<p>显式大于隐式 </p>
</blockquote>
<p>常见的<code>forEach</code>函数用法：</p>
<pre><code class="language-js">const locations = [&#39;SuZhou&#39;, &#39;WuXi&#39;]
// 便捷的写法
locations.forEach(i =&gt; {
  doSomething();
  ...
  ...
  doOther();
  ...
  useLocation(i); // 当上下文间隔稍长时，`i` 将变得不够清晰
});

// 推荐的写法
locations.forEach(location =&gt; {
  ...
  ...
  useLocation(location); // 坚持显式的代码
});
</code></pre>
<h2>不添加不必要的内容</h2>
<p>如果你的类名或对象名能告诉你一些信息，那么不要在类或对象内的变量名里重复描述：</p>
<pre><code class="language-js">// 不推荐的写法
const Car = {
  carMake: &quot;Honda&quot;,
  carColor: &quot;Red&quot;,
};

// 推荐的写法
const Car = {
  make: &quot;Honda&quot;, 
  color: &quot;White&quot;
};
</code></pre>
<h2>默认参数</h2>
<p>默认参数通常比变量通过条件、短路的机制来设置默认值更加简明。并且，在多数编辑器内也能提供更好的提示说明。</p>
<pre><code class="language-js">// 不推荐的写法
function createMicrobrewery(name) {
  const breweryName = name || &quot;Hipster Brew Co.&quot;;
  // ...
};

// 推荐的写法，需要注意是仅当传入的参数是 undefine 时，默认参数才会生效
// 其他 falsy 值（&#39;&#39; / NaN / false / 0 / null）依然会作为参数的值，此时默认参数无效
function createMicrobrewery(name = &quot;Hipster Brew Co.&quot;) {
  // ...
}
</code></pre>
<p>下一章《Function》</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[大闸蟹清蒸很好吃]]></title>
            <link>https://i5lin.top/blog/post/1967119416</link>
            <guid>1967119416</guid>
            <pubDate>Sun, 29 Oct 2023 19:12:17 GMT</pubDate>
            <description><![CDATA[第一次吃大闸蟹，这滋味简直回味无穷啊！]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<blockquote>
<p>苏州的大闸蟹真好吃啊！</p>
<p>首先去买两只大闸蟹，首选青背百肚黄毛的大闸蟹。其次准备生姜切丝、大蒜切丝，热水半开后捆绑放入开蒸一分钟，然后开盖将之翻肚皮放置，撒上之前的生姜大蒜丝，给每只大闸蟹肚子淋上一勺黄酒或白酒，中火十分钟后再熄火焖上三分钟。这三分钟期间可以小块生姜切碎配上两勺醋和一勺生抽搅拌做酱料。</p>
</blockquote>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/c27d919e-2266-4dfe-a383-1911caaa2142" alt="image"></p>
<blockquote>
<p>封面图：大耗子咪咪</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h2>重生之我是土耳其人</h2>
<p><a href="https://zblogs.top/how-to-subscribe-to-turkey-icloud/">[最新教程] 国内用户订阅土耳其区 iCloud+ 攻略 - Justin写字的地方</a>：这篇博客分享了作者如何创建土耳其苹果账户并且进行充值，订阅了低价的<code>icloud</code>空间共享给国区家庭用户的教程。如果你需要较多的苹果<code>icloud</code>存储空间，可以考虑考虑这个方法。</p>
<p>最新消息：土耳其区的<code>icloud</code>订阅价是国区的一半。</p>
<blockquote>
<p>最最新消息，算了还是闲鱼厉害（啥都有，真的省钱）</p>
</blockquote>
<h2>Logo 图片下载</h2>
<img width="773" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/d49aa32c-ab7e-4ee4-ab90-d3c133f8ce7d">


<p><a href="https://wangchujiang.com/logo/">logo</a>：这个站点是<code>github</code>用户<code>@jaywcjlove</code>开发的静态应用，你可以在这里下载到国内和国际大厂的<code>Logo</code>图片（jpg/svg/png）</p>
<h2>useHooks</h2>
<p><img src="https://camo.githubusercontent.com/2b5ff3204ef3998bf00ae07b1571ae81bc5b5ae10c7e0e09e67f3aa285116903/68747470733a2f2f757365686f6f6b732e636f6d2f6d6574612f6f672e6a7067" alt=""></p>
<p><a href="https://usehooks.com/">useHooks – The React Hooks Library</a>: 国外著名前端开发教学产品团队 <code>ui.dev</code> 开源的<code>React hooks</code>合集，包含了前端开发工作中常见的功能钩子，简直是居家旅行必备神器。无论你是想快速运用到项目里，让你的同事眼前一亮，亦或是学习其源代码，增强自己的技术，都是不可错过绝佳机会。</p>
<h2>Omnigroup</h2>
<p><img src="https://www.omnigroup.com/assets/img/icons/omnidisksweeper-mac@2x.png" alt="img"></p>
<p><a href="https://www.omnigroup.com/">The Omni Group</a>的产品：<code>OmniDiskSweeper</code>！一款很好用的<code>MacOS</code>磁盘大文件检索工具，方便我们清理这些文件。</p>
<img width="1124" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/484604ad-03e5-44de-bbd1-590874e6185e">


<p>除此之外，其团队还开发了以下一系列方向的产品：</p>
<img width="1228" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/58e57018-a275-4ec0-93a4-32674b6449ef">

<p>有兴趣的可以了解一下。</p>
<h2>抖音美好体</h2>
<p><img src="https://cdn.zxki.cn/tc/2023/10/26/cf2ce8b93eb64.png" alt=""></p>
<blockquote>
<p> 抖音公开了自己产品内广泛使用的<code>抖音美好体</code>字体，免费商用。</p>
</blockquote>
<p>抖音美好体包含 6763 个中文字符，682 个西文及数字符号，执行国家 GB2312-80 简体中文编码字符标准。作为品牌标准字体，抖音美好体将会率先用于抖音及其子品牌中，助力品牌视觉形象的统一，提升品牌的官方性、权威感。</p>
<h2>zhlint</h2>
<p><a href="https://github.com/zhlint-project/zhlint">zhlint-project/zhlint: A linting tool for Chinese language.</a>：中文和英文内容混合的格式检查工具，可以使用<code>npm</code>全局安装使用。</p>
<h2>Youtube AD Block Script</h2>
<p>最近油管更新了对广告拦截插件的应对策略，旧的插件会被检测到。笔者在<a href="https://www.reddit.com/r/youtube/comments/17hdbpo/solution_for_youtube_ads/">(5) Solution for YouTube ads : youtube</a>这里搜索到了新的解决方案。</p>
<blockquote>
<p>chrome-extension://dhdgffkkebhmkfjojejmpbldmpobfkfo/ask.html?aid=41aad3e7-0ffb-48fa-b2c4-9a41ad9ff238</p>
</blockquote>
<p>在油猴搜索&quot;Remove Adblock thing&quot;安装即可，对了，记得卸载之前的<code>Youtube Adblock</code>插件。</p>
<h2>整洁的 JavaScript 代码</h2>
<p><img src="https://camo.githubusercontent.com/af72fb10accee2e9a59efec2a0b436242fad5bb2a00ca11494e7c759834625cc/68747470733a2f2f7777772e6f736e6577732e636f6d2f696d616765732f636f6d6963732f7774666d2e6a7067" alt=""></p>
<p><a href="https://github.com/ryanmcdermott/clean-code-javascript%EF%BC%9A%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E5%88%86%E4%BA%AB%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E6%9C%89%E5%8A%A9%E4%BA%8E%E7%BC%96%E5%86%99%E6%95%B4%E6%B4%81%E7%9A%84">https://github.com/ryanmcdermott/clean-code-javascript：这个仓库分享了一系列有助于编写整洁的</a> <code>JavaScript</code> 代码的经验教训。</p>
<h2>OpenAI 书籍</h2>
<p>我用夸克网盘分享了「OpenAI：GPT 最佳实践中文大白话版本_未来力场编译.pdf」，点击链接即可保存。打开「夸克APP」在线查看，支持多种文档格式转换。</p>
<p>链接：<a href="https://pan.quark.cn/s/2db01eae1f56">https://pan.quark.cn/s/2db01eae1f56</a></p>
<h2>ChatGPT API 水龙头</h2>
<p><a href="https://faucet.openkey.cloud/">https://faucet.openkey.cloud/</a> 支持每 24 小时免费领取一个<code>$1</code>的令牌用于开发测试<code>AI</code>产品</p>
<blockquote>
<p>评论区有人说负载过高，笔者没有亲自注册申请过，仅提供消息</p>
</blockquote>
<h2>智能合约入门</h2>
<p><a href="https://github.com/slowmist/SlowMist-Learning-Roadmap-for-Becoming-a-Smart-Contract-Auditor">https://github.com/slowmist/SlowMist-Learning-Roadmap-for-Becoming-a-Smart-Contract-Auditor</a></p>
<h2>最后</h2>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[特殊的周刊，失败的经验]]></title>
            <link>https://i5lin.top/blog/post/1957473494</link>
            <guid>1957473494</guid>
            <pubDate>Mon, 23 Oct 2023 15:44:45 GMT</pubDate>
            <description><![CDATA[今天分享的是一份我的特殊周刊。]]></description>
            <content:encoded><![CDATA[<p>今天分享的是一份我的特殊周刊。</p>
<img width="893" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/ce509ac2-369f-4b6c-bee6-a57cb9502921">



<p>学生时代见到台上某些人在分享自己的一些观念、经历、成果等等，无一例外都是些能“激励人心”的东西。谢谢分享，那些激励至少能在我身上发挥三分钟到三天时间的效果。</p>
<p>我一直觉得让自己保持自律是一件反人类的事情，对我来说，给自律做事的人献上掌声简直是最自然不过的事情，而那些能保持自律成自然的人，我更是由衷地佩服（无论对方在自律做什么事，无论什么事）。</p>
<p>或许像笔者这样的普通人，有时候需要的并不是更多“激励人心”的东西，而是反过来。</p>
<p>今天，我来分享一些最近自己没有坚持做完而半途而废的项目（小玩具）或学习经历。</p>
<blockquote>
<p>此刻在听《Speechless》Dan + Shay (网易云音乐)</p>
</blockquote>
<h2>Rust CLI</h2>
<p>Rust 是新世代的系统级编程语言，我或许可以学习一下，未来可以给自己写一些系统小应用。</p>
<p>某个时间点，我看到<a href="https://github.com/sharkdp/bat/blob/master/doc/logo-header.svg"><a href="https://github.com/sharkdp/bat/blob/master/doc/logo-header.svg">sharkdp/bat: A cat(1) clone with wings.</a></a>这样的 CLI 工具，它完全由<code>Rust</code>开发。相对于老旧传统的<code>cat</code>命令来说，简直华丽无比。或许我可以学习<code>Rust</code>，然后把自己那么喜欢的<code>Terminal</code>小工具都给重新写一遍！</p>
<p>...</p>
<p>不知道被什么耽搁了，终止于<code>Rust</code>官方教程<code>Control flow</code>章节。</p>
<p>到底被什么耽搁了，我不记得了。</p>
<p>Holy  💩</p>
<h2>岚软</h2>
<p>笔者喜欢接触新奇有趣的软件，因此也算是接触到了很多很棒的软件，如果我将之分门别类，做成一个开放的 Web 门户应用如何？</p>
<p>这将会帮助到笔者自己收集和整理自己的软件&quot;后花园&quot;，还可以让需要用的人自取。能分享好用、开源的应用给其他人也不错。</p>
<p>说干就干，做了一段时间之后我发现“说干就干”简直毫无意义。这个项目应该更有价值，它至少应该有完整的<code>UI</code>设计图！</p>
<p>Holy  💩 </p>
<p>我得去学学<code>Figma</code>，设计不求人！谢谢前同事老范推荐的课程，至少我没有对不起你的信任，课程大纲我看了，很赞。</p>
<p>在厦门的时候我打算花点时间学<code>Figma</code>，然后就没有然后了。</p>
<p>我好像被我的懒惰耽搁了，当然还有加班。</p>
<p>Holy  💩 不管了，界面丑就丑吧，又不是不能用。</p>
<p>于是乎我继续用<code>Next.js</code>去写后端，看上了<code>ORM</code>和<code>MongoDB</code>，吭哧吭哧写了一段时间又觉得<code>Next.js</code>的后端能力简直辣鸡！</p>
<p>为什么不趁此机会去学学<code>Ruby</code>呢！好像国外<code>Ruby</code>的工作机会还挺多的。</p>
<p>我现在的<code>Ruby</code>笔记还在，但我什么也不记得了。</p>
<p>Holy  💩</p>
<h2>Twitter 插件</h2>
<p>当初<code>Twitter</code>还叫<code>Twitter</code>，我被某些神秘推文疯狂轰炸，仿佛中文圈都是那股势力在活跃。除了我之外 ，还有很多人也有相同的困扰（或许是少数，毕竟说不定大家都喜欢）。</p>
<p>于是乎我决定写一个<code>Chrome</code>插件去自动屏蔽那些账户，其实还算顺利。我将主站的请求抽丝剥茧得到了伪装请求的所有数据，此时我需要一个后台来提供订阅服务。简而言之，大家可以订阅自己喜欢的组织，信任组织里的朋友能在神秘内容下遵守自己的原则，大家共同出力！</p>
<p>最终依靠“人工”来实现智能，批量屏蔽大家都不喜欢的东西。（我甚至还反向支持了大家订阅一个大家都喜欢的内容组织，来共享自己喜欢的账号 ）。</p>
<p>但是，到了部署和测试的时候，插件还需要时间和精力来实现一些功能，部署也需要服务器等等。</p>
<p>Holy  💩 你知道我要说什么，我也不知道为什么会半途而废。</p>
<h2>NBA 快讯</h2>
<p><code>PWA</code>很棒，<code>NBA</code>很棒。</p>
<p>某讯体育简直是<code>AI</code>写手和广告天堂，毫无可信度的自媒体和无底线的管理机制。。。</p>
<p>为什么不自己每天花点时间去收集自己喜欢的信息，用<code>PWA</code>来承载，做点什么出来呢！</p>
<p>Holy  💩 从没开始</p>
<h2>Vim 坚持</h2>
<p><img src="https://github.com/ecosse3/nvim/raw/master/.screenshots/6-alpha.png" alt="Dashboard"></p>
<p>vim 是程序员的浪漫，vim 是编辑器之神。</p>
<p>Holy  💩 坚持多次都中途转向<code>VSCode</code>，我有罪。</p>
<h2>Canvas 学习</h2>
<p>工作上需要使用<code>Canvas</code>去实现一些动画，因此我打算系统性学习一下<code>Canvas</code>的知识。</p>
<p>Holy  💩 996 让我头皮发麻，连周刊都停下来了。</p>
<h2>翻译 PlasmoDoc</h2>
<p>群友打赏支持我翻译和分享<code>PlasmoDoc</code>的知识，没想到我收红包还不办事。</p>
<p>Holy  💩 在路上，我记得这件事。</p>
<h2>Chrome Extension 系列</h2>
<ul>
<li>IPassword 密码管理器（密码东西其实没有那么简单，我被卡住了咽喉</li>
<li>Flashing Download 代替 Chrome 垃圾下载功能，但是我却想加上后端支持，让用户能直接搜索软件和让下载某些东西变得更方便（我说的是油管那些），但后端又成了拦路虎，再后来 Chrome 新版本支持了一个不错的下载管理器 Holy  💩</li>
<li>TodoList 万恶之源，写是时候觉得应该把之前写得很多的数据存储的工具函数整理成库，但是被什么耽搁了？？？于是乎。。。</li>
<li>ADBlocker 分析网络请求实现广告拦截 Holy  💩 </li>
<li>Chrome 插件快速管理器（没时间</li>
<li>...</li>
</ul>
<h2>Blog 重构</h2>
<p>基于<code>Github</code>的博客始终少了些什么，到底少了什么？不够稳定，速度也很慢，访问还需要魔法。</p>
<p>Holy  💩</p>
<p>少了内容，少了应对备案的决心。</p>
<h2>最后</h2>
<p>哎，叹息。</p>
<p>好了，今天的分享就先到这里，大家下周见，绝对不🕊</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[建议独自在外生活的你养一只猫]]></title>
            <link>https://i5lin.top/blog/post/1890879678</link>
            <guid>1890879678</guid>
            <pubDate>Mon, 11 Sep 2023 16:37:55 GMT</pubDate>
            <description><![CDATA[hello 大家好~今天继续给大家带来我的新周刊内容。

如果你长时间独自在外生活，那么就养一只猫吧。


![](https://github.com/Developer27149/blog/assets/23721611/80ea2283-9ca1-4573-8325-f17fa5a26b08)



> 封面图：我的小闪电⚡



OK！继续来分享上一周接触到了一些]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<p>如果你长时间独自在外生活，那么就养一只猫吧。</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/80ea2283-9ca1-4573-8325-f17fa5a26b08" alt=""></p>
<blockquote>
<p>封面图：我的小闪电⚡</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h3>ImageOptim</h3>
<p><img src="https://imageoptim.com/ImageOptim-app.png" alt="Simple drag&#39;n&#39;drop interface"></p>
<p><a href="https://imageoptim.com/howto.html" title="ImageOptim — better Save for Web">ImageOptim — better Save for Web</a>：支持 <code>MacOS</code>本地压缩图片，压缩率很高。</p>
<h3>Hello 算法</h3>
<p><img src="https://www.hello-algo.com/index.assets/conceptual_rendering.png" alt="img"></p>
<p><a href="https://www.hello-algo.com/" title="Hello 算法">Hello 算法</a>开源了 🎉，这是一本通俗易懂的数据结构和算法入门书，非常适合初学者。此外，还提供各种代码示例语言的<code>PDF</code>文件下载。</p>
<h3>Vssue</h3>
<p><img src="https://vssue.js.org/logo.png" alt="hero"></p>
<p><a href="https://vssue.js.org/" title="Vssue">Vssue</a> 一个基于<code>Vue</code>和<code>Github</code>的评论系统插件，可以很方便地集成到你的博客中去。</p>
<p>效果预览如下，有一种清新的感觉。</p>
<p><img src="https://files.mdnice.com/user/9850/aaf2dde6-0f0f-4e19-a51e-d9f1f642c3ce.png" alt=""></p>
<h3>Yesicon</h3>
<p><a href="https://yesicon.app/" title="Yesicon - 精选全球高品质、开源、免费的矢量图标库">Yesicon - 精选全球高品质、开源、免费的矢量图标库</a>，资源齐全，质量上乘，使用也非常方便。</p>
<p>举个例子：</p>
<p><img src="https://files.mdnice.com/user/9850/0b9017f4-2c67-47ce-b878-cbd0ca33e2c6.png" alt=""></p>
<p>随机选择一个资源，其配合的技术栈非常全面，我相信你可以轻松找到你的技术栈对应的使用方案，易用性拉满。</p>
<h3>Web 音视频技术专题</h3>
<p><a href="https://hughfenghen.github.io/tag/WebAV/" title="WebAV Tag | 风痕 · 術&amp;思">WebAV Tag | 风痕 · 術&amp;思</a>：这一系列包含了作者对于音视频 Web 开发的经验分享，相关从业者可以看看。</p>
<h3>PDF 在线工具</h3>
<img width="1156" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/7851de57-4b6b-425e-99fc-7f8ca27172c5">


<p><a href="https://www.pdftool.org/zh" title="PDFTool：隐私保护与 PDF 合并和 PDF 签名等无缝 PDF 修改的完美结合">PDFTool：隐私保护与 PDF 合并和 PDF 签名等无缝 PDF 修改的完美结合</a>，此应用支持<code>PWA</code>模式，因此可以下载并且离线使用。</p>
<h3>Figma 新手系列教学 - 草帽sMao</h3>
<p><img src="https://files.mdnice.com/user/9850/8220c17c-2d12-45c2-8bc5-b5eb014fd6b5.png" alt=""></p>
<p><a href="https://www.craft.me/s/dbj8QJkuZ5ruTB" title="Figma 新手系列教学">Figma 新手系列教学</a>: 作者在<code>bilibili</code>发布了一系列的<code>Figma</code>教程，有兴趣的可以关注一下。</p>
<blockquote>
<p><a href="https://www.craft.do/" title="Craft – The Future of Documents">Craft – The Future of Documents</a>：上述作者的描述内容发布在<code>Craft</code>上面，看起来颜值很高的样子。</p>
</blockquote>
<h3>深入架构原理和落地实践</h3>
<p><a href="https://www.thebyte.com.cn/" title="深入架构原理与实践 | 深入架构原理与落地实践">深入架构原理与实践 | 深入架构原理与落地实践</a>：开源的架构小书，目前作者还在写。已经写好的部分包含以下章节：</p>
<ul>
<li>云原生技术概论</li>
<li>深入Linux内核网络及实践</li>
<li>构建足够快的网络服务</li>
<li>负载均衡原理和网关架构应用实践</li>
<li>分布式系统理论和应用实践</li>
<li>容器技术原理概论和应用实践</li>
<li>容器编排系统 Kubernets</li>
<li>服务治理变革 ServiceMesh</li>
<li>GitOps 的落地与实施</li>
<li>架构可观测性</li>
<li>Serverless 架构</li>
<li>FinOps 云成本管理</li>
</ul>
<h3>Radix For Vue</h3>
<p><a href="https://www.radix-vue.com/" title="Radix Vue | Unstyled, accessible components for building high‑quality design systems and web apps in Vue">Radix Vue | Unstyled, accessible components for building high‑quality design systems and web apps in Vue</a>：有人在<code>X</code>上说<code>Radix</code>真好，我要放弃<code>Vue</code>去写<code>React</code>了。接着，著名网友尤小右就在其下评论推荐了这玩意。</p>
<p><code>Radix</code>是一款无样式设计系统，其提供了众多包含了很多刚需逻辑的常用组件，我们可以轻松将之引入到我们的项目中来，其内置的逻辑能大大减少我们的开发量。</p>
<h3>Quick Reference</h3>
<p><img src="https://user-images.githubusercontent.com/1680273/201931931-d8559417-0a15-46af-a009-ec1e56e5b778.png" alt=""></p>
<p><a href="https://wangchujiang.com/reference/" title="Quick Reference &amp; Quick Reference">Quick Reference &amp; Quick Reference</a> 是一个为软件开发人员提供编程知识快速整理分享的站点，你可以在这里找到特定领域编程知识的内容总览和关键知识示例、方便大家的技术栈查询。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Canvas 101]]></title>
            <link>https://i5lin.top/blog/post/1884432121</link>
            <guid>1884432121</guid>
            <pubDate>Wed, 06 Sep 2023 17:13:28 GMT</pubDate>
            <description><![CDATA[学习 html canvas 技术]]></description>
            <content:encoded><![CDATA[<h1>Canvas</h1>
<p>通过<code>HTML</code>的<code>canvas</code>元素和<code>JavaScript</code>，我们可以在浏览器环境下绘制各种图形、创建动画、数据可视化，照片处理和实时视频处理等功能。</p>
<h2>Basic Example</h2>
<p>HTML canvas element exmaple:</p>
<pre><code class="language-html">&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>JavaScript:</p>
<pre><code class="language-js">const canvas = document.querySelector(&#39;#canvas&#39;) // 获取元素
const ctx = canvas.getContext(&#39;2d&#39;) // 获取 2D 上下文
</code></pre>
<blockquote>
<p>Canvas.getContext(): 返回一个canvas 元素上的绘制上下文对象（如果不支持此功能则返回<code>null</code>)</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext"><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext">HTMLCanvasElement: getContext() method - Web APIs | MDN</a></a></p>
<p>不同的获取<code>context</code>的参数，决定了绘图上下文的能力来源。我们通常会使用浏览器的<code>2d</code>上下文，亦或是选择基于<code>webgl</code>的增强上下文，具体选择什么取决于你的需求。</p>
<p>不同的基础能力也有不同的调优配置，具体可以参考文档。</p>
</blockquote>
<h2>Basic usage of canvas</h2>
<p>默认的<code>canvas</code>元素高<code>300px</code>，宽<code>150px</code>，我们可以通过元素属性和<code>CSS</code>来修改其宽高样式，所有绘制的内容都会在这个元素内部渲染，并且这些内部渲染的图形不会受到<code>Canvas</code>上的<code>CSS</code>影响。</p>
<h3>绘制</h3>
<p>看图如下：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes/canvas_default_grid.png" alt="Canvas grid with a blue square demonstrating coordinates and axes."></p>
<p><code>Canvas</code>的坐标系，其原点为<code>canvas</code>元素的左上角，接下来我们开始绘制基础图形（复杂的图形都可以拆解为基础图形，我们在开发的时候可以多多思考如何将复杂问题拆解为简单的子问题，逐一解决）。</p>
<p><code>Canvas</code>仅支持两种原始图形：</p>
<ul>
<li>Rectangles 矩形</li>
<li>Paths 路径（多点成线）</li>
</ul>
<p>其他的图形都是通过组合以上的原始图形形成的。</p>
<h4>绘制矩形</h4>
<p>绘制矩形的核心<code>API</code>如下：</p>
<ul>
<li><code>fillRect(x, y, width, height)</code> 填充矩形</li>
<li><code>strokeRect(x, y, width, height)</code> 绘制矩形的外部轮廓</li>
<li><code>clearRect(x, y, width, height)</code> 清除矩形区域数据，将其完全变得透明。</li>
</ul>
<p>看看这个例子：</p>
<pre><code class="language-js">function draw() {
  const canvas = document.getElementById(&quot;canvas&quot;);
  if (canvas.getContext) {
    const ctx = canvas.getContext(&quot;2d&quot;);

    ctx.fillRect(25, 25, 100, 100);
    ctx.clearRect(45, 45, 60, 60);
    ctx.strokeRect(50, 50, 50, 50);
  }
}
draw()
</code></pre>
<p>这个函数将会绘制如下所示的图形：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes/canvas_rect.png" alt=""></p>
<p>我们可以清楚看到矩形填充区、清理出来的透明矩形区和内部的轮廓边。</p>
<h4>绘制路径</h4>
<blockquote>
<p>路径就是一系列的<code>点</code>的组合，不同的路径连接组合起来就是不同的图形。</p>
</blockquote>
<p>绘制路径的时候，我们会使用到如下绘制函数：</p>
<ul>
<li><code>beginPath()</code> 创建一个路径，创建路径之后就可以在上面绘制了</li>
<li><code>closePath()</code> 关闭路径，添加一条笔直的线到路径的起点上</li>
<li><code>stroke()</code> 绘制图形的边框，绘制线时，仅绘制线的边框，需要手动移动到起始点或者调用<code>closePath()</code>来收拢图形绘制区域</li>
<li><code>fill()</code> 绘制图形并且填充其内部区域，会自动根据点位进行收拢，例如起始点+两次<code>lineTo()</code>即可在<code>fill()</code>的时候绘制其内部区域，形成一个三角形</li>
</ul>
<p>此外，开始一个路径之后即可调用以下函数进行绘制（就像手持画笔那样）：</p>
<ul>
<li><code>moveTo(x, y)</code> 移动画笔到目标坐标<code>(x, y)</code></li>
<li><code>lineTo(x, y)</code> 绘制直线到目标坐标<code>(x, y)</code></li>
</ul>
<p>其中，<code>beginPath</code>函数是创建一条路径的开始。下面是一个简单的绘制三角形的函数示例：</p>
<pre><code class="language-js">function draw() {
  const canvas = document.getElementById(&quot;canvas&quot;);
  if (canvas.getContext) {
    const ctx = canvas.getContext(&quot;2d&quot;);

    ctx.beginPath(); // 开始路径
    ctx.moveTo(75, 50); // 移动画笔到坐标 75, 50
    ctx.lineTo(100, 75); // 绘制直线到坐标 100, 75
    ctx.lineTo(100, 25); // 再次绘制
    ctx.fill(); // 填充画布区（自动围拢成的三角形）
  }
}
</code></pre>
<p>效果如下所示：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes/triangle.png" alt=""></p>
<p>绘制直线和矩形相对来说还算简单，接下来我们简单看看如何绘制曲线（弧线）和圆形。</p>
<h4>绘制弧线和圆</h4>
<p>绘制弧线和圆的主要<code>API</code>如下所示：</p>
<ul>
<li><code>arc(x, y, radius, startAngle, endAngle, counterckickwise)</code> 默认为顺时针绘制，绘制之后画笔就会停留在最后的坐标上，因此经常需要配合<code>moveTo</code>方法移动画笔</li>
<li><code>arcTo(x1, y1, x2, y2, radius)</code> 绘制弧线以连接两个切线。简单来说我们首先定义起点坐标和终点坐标，接着需要绘制两个点之间的一条弧线。</li>
</ul>
<p>绘制弧线的<code>API</code>是<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc"><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc">arc(x, y, radius, startAngle, endAngle, counterclockwise)</a></a>：关键属性即：坐标（决定了圆心位置）、半径、起始角度、是否逆时针绘制。</p>
<p>通过上述几个关键点，我们就可以绘制出想要的弧线。接下来，我们来看这个绘制弧线和圆形组成的微笑画面：</p>
<p><img src="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes/canvas_smiley.png" alt=""></p>
<p>这个图形是由外圆和双眼圆形、笑脸半圆弧线的嘴巴组成的。我们一步步来绘制：</p>
<pre><code class="language-js">function draw() {
  const canvas = document.getElementById(&quot;canvas&quot;);
  if (canvas.getContext) {
    // 针对高设备像素比的屏幕，修正宽高以免画面模糊
    const {width, height} = canvas.getBoundingClientRect();
    const radio = window.devicePixelRatio || 1;
    canvas.width = width * radio;
    canvas.height = height * radio;
    const ctx = canvas.getContext(&quot;2d&quot;);
    // 开始路径
    ctx.beginPath();
    // 绘制外圆，设定圆心坐标 (75, 75)
    // 设定半径、起始角度和逆时针绘制
    ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
    // 绘制结束之后，画笔会停在 (125, 75)
    ctx.moveTo(110, 75); // 将画笔移动到左边 10 像素的位置，继续准备绘制嘴巴
    ctx.arc(75, 75, 35, 0, Math.PI, false); // Mouth (clockwise) // 圆心保持一致，修改半径和起始角度，顺时针绘制好嘴巴
    ctx.moveTo(65, 65); // 移动到左边眼睛去绘制眼睛
    ctx.arc(60, 65, 5, 0, Math.PI * 2, true); // Left eye
    ctx.moveTo(95, 65); // 移动到右边眼睛坐标去绘制
    ctx.arc(90, 65, 5, 0, Math.PI * 2, true); // Right eye
    ctx.stroke();
  }
}
draw()
</code></pre>
<p>在绘制的时候想象成自己正在拿着画笔，逐一确定起始点的位置。</p>
<p>最后我们只需要绘制描边即可。</p>
<p>绘制圆形较为简单，下面通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo"><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arcTo">CanvasRenderingContext2D: arcTo() method - Web APIs | MDN</a></a>的例子，绘制弧线。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[分享我日常在用的谷歌插件]]></title>
            <link>https://i5lin.top/blog/post/1879166613</link>
            <guid>1879166613</guid>
            <pubDate>Sun, 03 Sep 2023 17:01:00 GMT</pubDate>
            <description><![CDATA[hello 大家好~今天继续给大家带来我的新周刊内容。

这一周接触的讯息较少，因此周刊稍微分享一下我自己在用的谷歌插件吧！

![闪电](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230903235837463.png)





> 封面图：我的小闪电⚡还挺喜欢新的猫抓板的嘛！

]]></description>
            <content:encoded><![CDATA[<p>hello 大家好~今天继续给大家带来我的新周刊内容。</p>
<p>这一周接触的讯息较少，因此周刊稍微分享一下我自己在用的谷歌插件吧！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230903235837463.png" alt="闪电"></p>
<blockquote>
<p>封面图：我的小闪电⚡还挺喜欢新的猫抓板的嘛！</p>
</blockquote>
<p>OK！继续继续！作为一个<code>Chrome 插件</code>重度使用者和开发者，今天我就来分享分享我自己在用的 chrome 插件！排名不分先后！</p>
<h3>扩展管理器（Extension Manager）</h3>
<p><img src="https://lh3.googleusercontent.com/i1quYLmDyiU7N5ES24UQEj74GRSnnMn7eBRwXLBfUK6zwaqWDzmmRAPH6YI7ih0aVKXdH9giVh5W7OjDs4sGdor_=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco?authuser=1" title="扩展管理器（Extension Manager） - Chrome 应用商店">扩展管理器（Extension Manager） - Chrome 应用商店</a>：快速管理我的所有扩展程序，相对于谷歌官方的管理页面来说会更好用一些。</p>
<h3>Thunder下载管理器</h3>
<p><img src="https://lh3.googleusercontent.com/eG1yD5MBuubVjxv3D_U0qSaRYCJ3mOtGMZtWJ9_vasD5H5Vt5wh6nP8PC5J8MgdeVvyRMKniraUVFyaZSMVQdcfZ_w=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/thunder-download-manager/nllgadppmkoamdlocamdnmimkehhojai?authuser=1" title="Thunder下载管理器 - Chrome 应用商店">Thunder下载管理器 - Chrome 应用商店</a>：在谷歌优化自己的下载页面或提供自己的下载插件之前，这个插件一直是我主力在用的下载管理插件。界面简单而实用。</p>
<h3>篡改猴</h3>
<p><img src="https://lh3.googleusercontent.com/1bMLl6dpPsjuKLxnEp_7PING8wGO4pA9DlAoTreNS7TlqD-wS6zBzDABMfiAgd6TJVbWkeCl4sZWZdyCsyynHkPJeQ=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?authuser=1" title="篡改猴 - Chrome 应用商店">篡改猴 - Chrome 应用商店</a>：大名鼎鼎的油猴插件，你可以下载很多特定功能的开发者分享的插件，比如某些站点的视频下载。</p>
<h3>Adblock Plus - 免费的广告拦截器</h3>
<p><img src="https://lh3.googleusercontent.com/Tj35Pv-xR5Z87co1mOM2lCA61IywNAigZyXg6tjGzpj6jjKrrb_JLWI2L-oddSfkxOJsuwqAVG_6ZHXJC8rlSDMC4w=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb" title="Adblock Plus">Adblock Plus</a>：广告屏蔽插件，非常实用。</p>
<p>阻止 YouTube™ 广告、弹出窗口并抵御恶意软件！</p>
<p>享受没有恼人广告的网络世界。</p>
<p>Adblock Plus for Google Chrome 会阻挡：</p>
<ul>
<li>横幅</li>
<li>YouTube 视频广告</li>
<li>Facebook 广告</li>
<li>弹出窗口</li>
<li>所有其他显眼的广告</li>
</ul>
<h3>Copy as Markdown</h3>
<p><a href="https://chrome.google.com/webstore/detail/copy-as-markdown/fkeaekngjflipcockcnpobkpbbfbhmdn?authuser=1" title="Copy as Markdown - Chrome 应用商店">Copy as Markdown - Chrome 应用商店</a>：很好用的“将页面、图片、链接等资源复制为<code>markdown</code>内容”的插件。</p>
<p>如果你经常需要复制一些内容为<code>markdown</code>语法链接，那么非常推荐这个插件，确实非常好用。</p>
<h3>Copy As Plain Text</h3>
<p><img src="https://lh3.googleusercontent.com/eChfx438jjYU7al1WilBWM24dIt-PTNeCD3ZCyjsUaZC5M-zOobwJ0OsUOAVzGv9bpUwYFJU7Bl9_hf-150Uf3oY=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/copy-as-plain-text/eneajgkmdhmjmloiabgkpkiooaejmlpk?authuser=1" title="Copy As Plain Text - Chrome 应用商店">Copy As Plain Text - Chrome 应用商店</a>：有些页面复制文本后会添加一些不需要的格式或数据，这个插件在复制纯文本上还挺好用的。</p>
<h3>Erin</h3>
<p><a href="https://chrome.google.com/webstore/detail/erin/nobdiagkeelcndaijbdninbmjkdahggd?authuser=1" title="Erin - Chrome 应用商店">Erin - Chrome 应用商店</a>：我开发的新标签页插件，如果你对系统默认的新标签页或者某些广告很多的新标签页感到腻味，而恰好也喜欢壁纸和需要添加一些稍后阅读的页面，亦或是固定一些书签在新标签页下，那么或许你会喜欢这个插件。</p>
<p><img src="https://erin-homepage.vercel.app/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmain.b2070029.png&w=3840&q=75" alt=""></p>
<h3>Jiffy Reader</h3>
<p><a href="https://chrome.google.com/webstore/detail/jiffy-reader/lljedihjnnjjefafchaljkhbpfhfkdic?authuser=1" title="Jiffy Reader - Chrome 应用商店">Jiffy Reader - Chrome 应用商店</a>：听说将英文的前缀单词高亮，能提高阅读者的阅读理解速度。这个插件主要是提供这一功能，笔者尝试之后确实感觉在高亮了关键的英语前缀之后，自己对于英语语句的理解速度有了提升。</p>
<p><img src="https://lh3.googleusercontent.com/Mg6QxSuXburXCs1sRaO6gNOHYf1nXwVPIoCH77Qx7Yiuoz8W22VPldTvqyM84-qNRSGezVQp1Z0rksAr0etBCvJB=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<h3>JSON-handle</h3>
<p><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj?authuser=1" title="JSON-handle - Chrome 应用商店">JSON-handle - Chrome 应用商店</a>：支持 JSON 数据的预览和快速跳转修改、复制等操作。</p>
<p><img src="https://lh3.googleusercontent.com/Q7b4wi7gG4SJhFxT3n633dFHVcm1XNn7UUA87bblaUoT32aUQrn6VygY_vzH7W6yE2of4ypEzrJetlO9LDHzFzucoA=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p>作为一个<code>web</code>开发者，很多时候我们需要处理一些<code>JSON</code>数据，这个插件还是挺好的。</p>
<h3>LastPass: Free Password Manager</h3>
<p><img src="https://lh3.googleusercontent.com/IWUSDcCYEkA5luU2MB_ahrb9LG6XSCOcHpGpBEVf2Tse3d3X_cHPb4FasICIPRpC8xSWJF5ACrprIXVP3n1Zr7aP=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd?authuser=1" title="LastPass: Free Password Manager - Chrome 应用商店">LastPass: Free Password Manager - Chrome 应用商店</a>：著名的密码管理工具<code>LassPass</code>的浏览器插件版本，可以快速为你创建不同强度的密码。为你保存、自动填写、自动登录等等关于密码交互的功能。</p>
<blockquote>
<p>1Password 的平替！</p>
</blockquote>
<p>简单来说就是：<code>LastPass</code>可以保存您的密码，并在每台计算机和移动设备上提供安全访问。<code>LastPass</code>让您掌控在线生活，轻松保护您的关键信息，确保安全，并在您需要时随时随地访问。将所有密码、地址、信用卡等保存在您的安全保险库中，<code>LastPass</code>在您需要时会自动填写您的信息。</p>
<p>不要再浪费时间被锁在账户外或填写在线密码和表单了 -<code> LastPass</code>简化您的日常在线任务。</p>
<h3>uBlacklist</h3>
<p><img src="https://lh3.googleusercontent.com/eG7PFI8RdHYezHWXrVZkaGmQ0BPkKrRwgDe1VN-dcsuZPd7efH4DZ9ZgVfxQU0qndRu7lGCOo4NyYrO-MDfnIIY2MB8=w640-h400-e365-rj-sc0x00ffffff" alt="img"></p>
<p><a href="https://chrome.google.com/webstore/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe?authuser=1" title="uBlacklist - Chrome 应用商店">uBlacklist - Chrome 应用商店</a>：在谷歌的搜索结果中屏蔽特定的网站（比如<code>CSDN</code>）显示。</p>
<p>此浏览器扩展可以帮你在谷歌搜索结果中屏蔽一些你不想看到的网站。</p>
<p>你可以通过在搜索结果页面中直接屏蔽某个网站，也可以通过点击本扩展的图标将当前网站添加到黑名单。屏蔽规则同时支持「匹配模式」（比如 <em>://</em>.example.com/*）和「正则表达式」（比如 /example.(net|org)/）的语法。</p>
<p>本浏览器扩展还提供了黑名单的同步功能，可以通过 Google Drive 和 Dropbox 将黑名单列表在不同设备之间同步。除此之外，你还可以通过订阅一些公开的黑名单列表，随时获取最新的网站黑名单。</p>
<h3>Vimium</h3>
<p><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?authuser=1" title="Vimium - Chrome 应用商店">Vimium - Chrome 应用商店</a>：<code>Vim</code>用户神器，支持像使用<code>Vim</code>一样使用键盘控制浏览器页面。</p>
<blockquote>
<p>这个插件帮助我减少了鼠标的使用，强推！</p>
</blockquote>
<p>你可以轻松快速地跳转以及使用打开页面、查询所有 Tab 页面和书签、快速搜索、滚动切换等功能。</p>
<h3>酷时钟</h3>
<p><a href="https://chrome.google.com/webstore/detail/cool-clock/icegcmhgphfkgglbljbkdegiaaihifce?authuser=1" title="酷时钟 - Chrome 应用商店">酷时钟 - Chrome 应用商店</a>：这个插件非常的旧了，目前我唯一使用的功能就是通过它直接在浏览器地址栏右边查看时间，它会动态渲染一个时间数据成插件的<code>Icon</code>，在全屏下我可以通过这个插件快速了解还有多久下班。嘿嘿。</p>
<h3>问知乎</h3>
<p><a href="https://chrome.google.com/webstore/detail/%E9%97%AE%E7%9F%A5%E4%B9%8E/okcchoellbegnneigaicdalncakaemji?authuser=1" title="问知乎 - Chrome 应用商店">问知乎 - Chrome 应用商店</a>：通过在地址栏输入<code>z</code> 和空格设定搜索的内容转移到知乎的搜索页面上去（笔者曾经是知乎的重度用户，因此才开发这一插件）。</p>
<h3>TabX - 辅助管理浏览器标签页</h3>
<p><img src="https://files.mdnice.com/user/9850/667b5b5b-285c-4d9e-a265-a74cc3a6a29d.png" alt=""></p>
<p><a href="https://chrome.google.com/webstore/detail/tabx-%E8%BE%85%E5%8A%A9%E7%AE%A1%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%87%E7%AD%BE%E9%A1%B5/jomfeifdkncokmfdhinficpdhohfiifj?authuser=1" title="TabX - 辅助管理浏览器标签页 - Chrome 应用商店">TabX - 辅助管理浏览器标签页 - Chrome 应用商店</a>：快速管理和操作浏览器所有的标签页，支持搜索、状态区分、域名分类和简单的数据统计。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[当我们没有获得 60 分的满足时，我们很容易会去追寻 100 分的满足，而追寻 100 分的满足注定只会感受到深深的孤独感。]]></title>
            <link>https://i5lin.top/blog/post/1863556532</link>
            <guid>1863556532</guid>
            <pubDate>Wed, 23 Aug 2023 15:24:12 GMT</pubDate>
            <description><![CDATA[这一周特别想分享看圆桌派的时候听到的一句话，大致意思就是：“当我们没有获得 60 分的满足时，我们很容易会去追寻 100 分的满足，而追寻 100 分的满足注定只会感受到深深的孤独感。”


![image](https://github.com/Developer27149/blog/assets/23721611/afce26d7-27fc-4e44-a772-2e7ad94c1c4a)]]></description>
            <content:encoded><![CDATA[<p>这一周特别想分享看圆桌派的时候听到的一句话，大致意思就是：“当我们没有获得 60 分的满足时，我们很容易会去追寻 100 分的满足，而追寻 100 分的满足注定只会感受到深深的孤独感。”</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/afce26d7-27fc-4e44-a772-2e7ad94c1c4a" alt="image"></p>
<blockquote>
<p>封面图：我的小闪电⚡</p>
</blockquote>
<p>OK！继续来分享上一周接触到了一些讯息！</p>
<h3>Atropos</h3>
<p><img src="https://files.mdnice.com/user/9850/d688d4ef-8aae-483d-af8b-a4b8811bbda2.png" alt=""></p>
<p><a href="https://atroposjs.com/" title="Atropos - Stunning touch-friendly 3D parallax hover effects"><a href="https://atroposjs.com/">Atropos - Stunning touch-friendly 3D parallax hover effects</a></a> 绚丽的 3D 触摸 CSS 动画样式效果实现，不妨试试应用到你的产品中去试试看，效果非常棒！</p>
<h3>JavaScript设计模式与开发实践</h3>
<p>网友分享的<code>JavaScript设计模式与开发实践</code> .pdf: <a href="https://url04.ctfile.com/f/45908404-923787015-a48122?p=8628">https://url04.ctfile.com/f/45908404-923787015-a48122?p=8628</a> (访问密码: 8628)</p>
<h3>终端风格的博客</h3>
<p><img src="https://camo.githubusercontent.com/d01f4e514a31505e22e40b143b9f3a02686c3084cfe5672df5446d54849367de/68747470733a2f2f7465726d696e616c2e6465762e6175746f6d61642e6f72672f7368617265642f7465726d696e616c2d6461726b2d312e706e67" alt="img"></p>
<p><a href="https://github.com/marcantondahmen/automad-terminal" title="marcantondahmen/automad-terminal: A minimal Automad blog theme for terminal lovers"><a href="https://github.com/marcantondahmen/automad-terminal">marcantondahmen/automad-terminal: A minimal Automad blog theme for terminal lovers</a></a> 这个仓库存放了这个终端风格的站点的源代码，100% PHP 实现！</p>
<h3>Hypercolor</h3>
<p><a href="https://hypercolor.dev/" title="Gradients for Tailwind CSS | Hypercolor"><a href="https://hypercolor.dev/">Gradients for Tailwind CSS | Hypercolor</a></a> 基于<code>tailwindcss</code>一系列绚丽的 CSS 渐近背景色代码和示例，你喜欢的话甚至可以直接下载作为壁纸。</p>
<h3>better-sqlite3</h3>
<p><a href="https://github.com/WiseLibs/better-sqlite3" title="WiseLibs/better-sqlite3: The fastest and simplest library for SQLite3 in Node.js."><a href="https://github.com/WiseLibs/better-sqlite3">WiseLibs/better-sqlite3: The fastest and simplest library for SQLite3 in Node.js.</a></a></p>
<p>这是一个速度快+易用性极高的<code>nodejs</code>库，用户操作<code>SQLite3</code>数据库。其主要特点如下：</p>
<blockquote>
<p>SQLite 依然是小型数据存储的最佳选择之一</p>
</blockquote>
<ul>
<li>完整的事务支持</li>
<li>高性能、效率和安全性</li>
<li>易于使用的同步API（比异步API更好的并发性...是的，你没看错）</li>
<li>支持用户定义的函数、聚合、虚拟表和扩展</li>
<li>64位整数（可选）</li>
<li>工作线程支持（用于大型/缓慢查询）</li>
</ul>
<h3>React Tooltip</h3>
<p><img src="https://files.mdnice.com/user/9850/a404ca27-6400-49b2-892c-5e3965949f1c.png" alt=""></p>
<p><a href="https://react-tooltip.com/" title="Welcome | React Tooltip"><a href="https://react-tooltip.com/">Welcome | React Tooltip</a></a>开箱即用的<code>React</code>提示框组件，外观简洁，代码非常易用！</p>
<h3>安妮薇看看</h3>
<p><img src="https://files.mdnice.com/user/9850/de38af38-e3bb-4c45-83c0-a80f38970387.png" alt=""></p>
<p><a href="https://anyway.fm/now/" title="安妮薇看看 Anyway.Now • Anyway.FM 设计杂谈 • UI 设计师 JJ 和 Leon 主播的设计播客 Podcast"><a href="https://anyway.fm/now/">安妮薇看看 Anyway.Now • Anyway.FM 设计杂谈 • UI 设计师 JJ 和 Leon 主播的设计播客 Podcast</a></a>！通勤的时候听到的播客，主要是两个设计师做的一个播客节目，提供与设计行业相关的新闻资讯、网摘推荐以及专栏文章等内容。</p>
<p>如果你从事 UI 和交互设计相关工作，或许对你有所帮助。</p>
<h3>字体分享</h3>
<p><img src="https://files.mdnice.com/user/9850/ed71cba1-3592-4576-b08a-0c694db23caa.png" alt=""></p>
<blockquote>
<p>如果你自己的应用想要换一个可商用的中文字体，不妨看看以下两个基于黑体和仿宋的变体字体，非常优美。</p>
</blockquote>
<ul>
<li><a href="https://github.com/welai/glow-sans" title="welai/glow-sans: SHSans-derived CJK font family with a more concise &amp; modern look. 未来荧黑·未來熒黑·ヒカリ角ゴ：基于思源黑体改造，拥有粗度和宽度系列，更加简明现代的超大字体家族。"><a href="https://github.com/welai/glow-sans">welai/glow-sans: SHSans-derived CJK font family with a more concise &amp; modern look. 未来荧黑·未來熒黑·ヒカリ角ゴ：基于思源黑体改造，拥有粗度和宽度系列，更加简明现代的超大字体家族。</a></a></li>
<li><a href="https://github.com/TrionesType/zhuque" title="TrionesType/zhuque: 朱雀仿宋：开源正文仿宋字库计划"><a href="https://github.com/TrionesType/zhuque">TrionesType/zhuque: 朱雀仿宋：开源正文仿宋字库计划</a></a></li>
</ul>
<p><img src="https://files.mdnice.com/user/9850/3d23b7bb-bea3-476f-a09d-1a52412a9e1a.png" alt=""></p>
<h3>Windows 11 有线网络自动断开问题</h3>
<p>最近发现我女朋友的 windows11 网络会自动断开，我查到是升级了系统之后才出现的这种情况。于是，我在网上查了一些资料，发现 Windows 11 的网络适配器有一个客户端设置，支持休眠时自动关闭适配器客户端以节省电量。😂 提一嘴~</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
<p>ps: 🎉 <code>Erin</code> 获得了<code>382</code>个用户！继续加油，下一个开源插件<code>TabX</code>在路上了！</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Infuse 平替应用 Vidhub ]]></title>
            <link>https://i5lin.top/blog/post/1851524180</link>
            <guid>1851524180</guid>
            <pubDate>Tue, 15 Aug 2023 14:17:57 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 45 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![image](https://github.com/Developer27149/blog/assets/23721611/3a27084f-84f5-49fe-a3da-a172db82bd6c)



> 封面图：]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 45 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/3a27084f-84f5-49fe-a3da-a172db82bd6c" alt="image"></p>
<blockquote>
<p>封面图：咪咪</p>
</blockquote>
<p>以下是本周分享的内容：</p>
<h3>Vidhub</h3>
<p><img src="https://static1.appinn.com/images/202308/appinn-feature-images-2023-08-07t151641-474.jpg!o" alt=""></p>
<p>Vidhub 是一款可以挂载<code>SMB</code>、<code>WebDAV</code>、<code>谷歌云盘</code>、<code>阿里云盘</code>、<code>百度网盘</code>等云盘服务的资源管理软件，其主打视频管理和媒体播放功能，目前仅支持<code>MacOS</code>客户端，其他客户端正在开发中。</p>
<p><img src="https://static1.appinn.com/images/202308/appinn-2023-08-07-15-30-042x.jpg!o" alt=""></p>
<p>笔者体验挂载了阿里云盘，查阅文件和播放视频都很方便，目前可以作为免费版的<code>Infuse</code>食用 😂</p>
<h3>Million</h3>
<p><img src="https://raw.githubusercontent.com/aidenybai/million/main/.github/assets/banner.png" alt="[Million.js](https://million.dev/) Banner"></p>
<p><a href="https://million.dev/">Million.js</a> 使用和<code>React</code>不同的虚拟<code>DOM</code>算法，仅需在原<code>React</code>组件外包装一层<code>million/react</code>的<code>block</code>函数，即可加速组件更新效率 <code>70%</code>!</p>
<blockquote>
<p>Github stars 超 12k</p>
</blockquote>
<h3>Html2canvas</h3>
<img width="1072" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/69135ba2-4697-4810-9290-8e483b54be10">


<p><a href="https://html2canvas.hertzen.com/"><a href="https://html2canvas.hertzen.com/">html2canvas - Screenshots with JavaScript</a></a> 使用原生 JavaScript 对 DOM 元素节点进行截图操作，目前在 github 上有 28646 stars！</p>
<h3>阮一峰：TypeScript 教程</h3>
<p><img src="https://cdn.beekka.com/blogimg/asset/202308/bg2023080705.webp" alt=""></p>
<p><a href="https://wangdoc.com/typescript/"><a href="https://wangdoc.com/typescript/">TypeScript 教程 - 网道</a></a>：阮一峰发布了最新的 TypeScript 教程，欢迎 TypeScript 开发者学习。</p>
<h3>Web Browser Quiche</h3>
<p><a href="https://apps.apple.com/app/quiche-browser/id1668363952"><a href="https://apps.apple.com/app/quiche-browser/id1668363952">Web Browser Quiche on the App Store</a></a> IOS 极简移动端浏览器，极简爱好者强推。</p>
<h3>Distill</h3>
<p><a href="https://distill.io/"><a href="https://distill.io/">Monitor web for changes and get instant alerts</a></a> 网页监测服务，如果你需要一个服务来检测某些 web 页面的变更，那么这个应用会帮上忙。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Driverjs 快速创建新用户引导交互效果]]></title>
            <link>https://i5lin.top/blog/post/1838298983</link>
            <guid>1838298983</guid>
            <pubDate>Sun, 06 Aug 2023 18:23:24 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 44 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![](https://files.mdnice.com/user/9850/cc4bc766-cc9d-4e9e-8ff7-0720fb324572.png)



> 封面图：我的小闪电~



以下是本周分享]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 44 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://files.mdnice.com/user/9850/cc4bc766-cc9d-4e9e-8ff7-0720fb324572.png" alt=""></p>
<blockquote>
<p>封面图：我的小闪电~</p>
</blockquote>
<p>以下是本周分享的内容：</p>
<h3>Driverjs</h3>
<p><img src="https://files.mdnice.com/user/9850/29b35fda-2b3f-4c09-98af-8e66aa33cd44.png" alt=""></p>
<p><a href="https://driverjs.com/">Driver.js</a> 是一个用户提供产品用户引导交互效果的第三方 JavaScript 库，使用 TypeScript 编写并且无第三方依赖。如果你的产品需要做一个新手引导交互，或许可以考虑<a href="https://driverjs.com/">Driver.js</a>!</p>
<p>这个库的用法非常简单，直接使用<code>CDN</code>脚本或<code>npm</code>安装都可以，举个例子：</p>
<pre><code class="language-js">import { driver } from &quot;driver.js&quot;;
import &quot;driver.js/dist/driver.css&quot;;

const driverObj = driver({
  showProgress: true,
  steps: [
    { element: &#39;.page-header&#39;, popover: { title: &#39;Title&#39;, description: &#39;Description&#39; } },
    { element: &#39;.top-nav&#39;, popover: { title: &#39;Title&#39;, description: &#39;Description&#39; } },
    { element: &#39;.sidebar&#39;, popover: { title: &#39;Title&#39;, description: &#39;Description&#39; } },
    { element: &#39;.footer&#39;, popover: { title: &#39;Title&#39;, description: &#39;Description&#39; } },
  ]
});

driverObj.drive();
</code></pre>
<p>如此即可提供一个具有多个步骤的用户引导交互，其样式和动画笔者体验之后感觉还是不错的。</p>
<h3>Yazi</h3>
<p><a href="https://github.com/sxyazi/yazi">sxyazi/yazi: ⚡️ Blazing fast terminal file manager written in Rust, based on async I/O.</a> 基于<code>Rust Async I/O</code>开发的终端文件管理器！</p>
<p>支持终端搜索、文件预览、代码高亮等功能，速度很快，喜欢终端的朋友或许可以看看。</p>
<h3>Web Interface Guidelines</h3>
<p><a href="https://interfaces.rauno.me/">Web Interface Guidelines</a>：这份文档概述了构建一个良好（的网页）界面所需的细节，并且这是一个活跃的文档，根据学习经验定期更新。其中存在一些主观观念，但大多适用于所有网站。笔者在此真诚地分享这个文档给其他 web 开发者亦或是正在阅读的你。</p>
<h3>Vesper</h3>
<p><a href="https://marketplace.visualstudio.com/items?itemName=raunofreiberg.vesper">Vesper - Visual Studio Marketplace</a> 是一款暗色系的<code>VS Code</code>编辑器主题。</p>
<p><img src="https://cdn.rauno.me/vesper-og.png" alt=""></p>
<h3>Aplayer-react</h3>
<p><a href="https://aplayer-react.js.org/">aplayer-react – Nextra</a>：以<code>aplayer</code>为原型的<code>React</code>播放器组件实现，支持<code>SSR</code>。</p>
<p>作者将之应用到了自己的<code>Gatsby</code>博客中，效果如下：</p>
<p><img src="https://github.com/SevenOutman/aplayer-react/raw/master/screenshot.png" alt=""></p>
<p>对于开发者来说，我想我们或许可以从其源代码：<a href="https://github.com/SevenOutman/aplayer-react">SevenOutman/aplayer-react: The missing APlayer for your React applications</a> 之中学习到如何开发一个第三方的组件，以及一些良好的代码范式和编写方法。</p>
<h3>Ts-lib-starter</h3>
<p><a href="https://github.com/egoist/ts-lib-starter">egoist/ts-lib-starter: My minimal TypeScript library starter</a>：作者在 github 上分享了自己的最小化<code>TypeScript</code>库开发源代码，如果你对使用<code>TypeScript</code>开发一个库感兴趣，推荐阅读。</p>
<p>这个仓库的主要功能特色如下：</p>
<ul>
<li>使用<code>pnpm</code>管理包依赖</li>
<li>使用<code>semantic-release</code>管理自动版本发布</li>
<li>使用<code>tsup</code>打包<code>TypeScript</code>源代码</li>
<li>使用<code>Vitest</code>进行测试</li>
</ul>
<p>如果你对这部分知识感兴趣，欢迎和我一起阅读这个仓库的代码。</p>
<h3>MingCute Icon</h3>
<p><img src="https://files.mdnice.com/user/9850/4ea035ef-cff8-41a6-be32-d81b06cd9177.png" alt=""></p>
<blockquote>
<p>目前已经发布了 2400+ 免费 Icon 资源，支持下载<code>svg</code>或<code>png</code>文件，亦或是复制<code>svg</code>代码，并且支持一定的编辑功能。</p>
</blockquote>
<p><a href="https://www.mingcute.com/">MingCute Icon</a>是一个简单而精美的开源图标库。无论您是设计师还是开发人员，它都非常适合在Web和移动应用中使用。</p>
<h3>Get TT/X icons back</h3>
<p><a href="https://github.com/pionxzh/Get-Twitter-Icons-Back">pionxzh/Get-Twitter-Icons-Back: Restore the icon of Twitter. No more 𝕏.</a>!</p>
<p>众所周知，马斯克把<code>Logo</code>直接改了。于是乎有开发者写了这个油猴脚本来替换旧版<code>Logo</code>，如果你需要（眼不见为净），自取 😂</p>
<h3>书籍：经济旋涡</h3>
<p><a href="https://drive.google.com/file/d/1RdgJne7nLdr9x4Z5inywT_LWdfu12Nw7/view">https://drive.google.com/file/d/1RdgJne7nLdr9x4Z5inywT_LWdfu12Nw7/view</a> 谷歌云盘</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
<p>ps: 🎉 <code>Erin</code> 获得了<code>177</code>个用户~ 开心！</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[介绍我的新标签页插件：Erin]]></title>
            <link>https://i5lin.top/blog/post/1829450237</link>
            <guid>1829450237</guid>
            <pubDate>Mon, 31 Jul 2023 15:20:04 GMT</pubDate>
            <description><![CDATA[![](https://lh3.googleusercontent.com/LcAQ86qgz4NsdEhFLWzFZBmz4VPDyGiNRoVpEn3qA6o6iysSUuuztMrSwTJIcjHEyv-3PPGzZnoADm5o4oSIsOTzdw=w128-h128-e365-rj-sc0x00ffffff)

今天，我想介绍一下我的 chrome 浏览器插件：Erin ！

<]]></description>
            <content:encoded><![CDATA[<p><img src="https://lh3.googleusercontent.com/LcAQ86qgz4NsdEhFLWzFZBmz4VPDyGiNRoVpEn3qA6o6iysSUuuztMrSwTJIcjHEyv-3PPGzZnoADm5o4oSIsOTzdw=w128-h128-e365-rj-sc0x00ffffff" alt=""></p>
<p>今天，我想介绍一下我的 chrome 浏览器插件：Erin ！</p>
<img width="1398" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/a64823ca-cca2-4680-9988-2733e6764d7f">


<h3>前言</h3>
<p>很久以前，我发现每次打开新的浏览器标签页都会跳出一个导航网站，上面布满了各种各样毫无意义的“新闻、娱乐信息”，甚至慢慢地出现一些“一刀 999”的广告。</p>
<p>于是，我开始想办法清理掉这些东西。某一天，我发现朋友在用<code>Infinity</code>这个浏览器插件，界面非常干净。于是，我便果断安装了这个插件。</p>
<p>又过了一段时间，我开始了解到 chrome 浏览器扩展开发的知识，于是便开始想着编写自己的新标签页。</p>
<p>于是，我发布了最早的标签页插件：<a href="https://chrome.google.com/webstore/detail/%E5%B2%9A/pgbomeeopmblmenapfgbhjobohpnegil">岚</a>！尽管没有用户，并且功能非常简陋，代码也只是勉强达到<code>能跑</code>的程度而已。无论如何，那是我第一个上架的插件。后续我又重写了这个插件，但是以另一个名字发布&quot;<code>linlan</code>&quot;。令我没想到的是，这个插件居然有一个国外的用户给了五颗星😂，还留言了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230731230224227.png" alt="image-20230731230224227"></p>
<h3>Erin</h3>
<p>在体验过一段时间<code>Plasmo</code>这个浏览器扩展开发框架之后，我决定花点时间使用<code>React</code>重新开发新的 chrome 标签页插件：<a href="https://chrome.google.com/webstore/detail/erin/nobdiagkeelcndaijbdninbmjkdahggd">Erin</a>!</p>
<blockquote>
<p>做一个纯净的新标签页插件！</p>
</blockquote>
<p>其保留了之前的新标签页功能，例如：</p>
<ul>
<li>4k 壁纸展示和选择、下载、自定义上传、收藏等</li>
<li>搜索引擎切换和搜索建议</li>
<li>书签 Dock</li>
<li>当前时间 tips</li>
</ul>
<p>此外，还有朋友提出了新的需求：</p>
<ul>
<li>tabs 页面管理：方便查看所有窗口的页面以及不同页面的打开父子关系、批量操作等（很<code>开发者</code>的需求）</li>
</ul>
<p>此外，我还想支持：</p>
<ul>
<li>便签模式：展示日常记录便签，用后即删，支持<code>markdown</code>语法</li>
<li>copy as markdown </li>
<li>video for Picture in Picture (播放中的视频快速启用画中画模式)</li>
<li>图片自定义格式下载</li>
<li>稍后阅读记录（按标签）</li>
</ul>
<p>于是，我一步步加上了这些功能，并且发布上架到了 chrome 插件商店，并且还添加了一个用于介绍<code>Erin</code>的页面（需要一些魔法才能打开）：<a href="https://erin-homepage.vercel.app/">Erin - 极简的 chrome 新标签页插件</a></p>
<h3>最后</h3>
<p>这个插件我日常会用，后续或许会有一些新的功能加进来，亦或是增加用户系统等等。</p>
<p><strong>BTW</strong>，欢迎大家试用和提出建议~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[卓越的技艺需要刻意的练习]]></title>
            <link>https://i5lin.top/blog/post/1827977768</link>
            <guid>1827977768</guid>
            <pubDate>Sun, 30 Jul 2023 15:34:27 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 43 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![image-20230730214430988](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/21EiR3.jpg)



> 封面图：我的小闪电]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 43 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/21EiR3.jpg" alt="image-20230730214430988"></p>
<blockquote>
<p>封面图：我的小闪电穿过前司发的日历📅</p>
</blockquote>
<p>以下是本周分享的内容：</p>
<h3>WeekTodo</h3>
<img width="1398" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/5f0cc377-197f-4ed9-bdd1-9c7513490f30">


<p><a href="https://app.weektodo.me/">WeekToDo Planner</a>是一个开源的代办任务应用，其以一周为周期展示面板数据，不同日期的数据可以方便地拖动修改时间，动态修改状态、检索任务等等。</p>
<blockquote>
<p>这个应用的国际化做得非常好，支持众多语言。</p>
</blockquote>
<p>此外，还支持导入和导出数据，跨设备数据同步等。对于需要日常记录工作的朋友来说，还是非常实用的。</p>
<h3>React-hot-toast</h3>
<p><a href="https://react-hot-toast.com/">react-hot-toast - The Best React Notifications in Town</a>：号称最好的<code>React</code>通知组件，预览发现其<code>CSS</code>动画做得挺不错的，此外仅仅有<code>5kb</code>大小，还支持良好的异步逻辑，对于那些需要动态确定数据状态的场景很实用。</p>
<h3>JSZip</h3>
<p><a href="https://stuk.github.io/jszip/">JSZip</a>是一个 JavaScript 原生的库，提供简易清晰的<code>API</code>来支持<code>zip</code>文件压缩和解压缩的功能</p>
<h3>TinyVG</h3>
<p><img src="https://cdn.beekka.com/blogimg/asset/202303/bg2023032101.webp" alt=""></p>
<p><a href="https://tinyvg.tech/">TinyVG</a>SVG 图片格式的二进制版本，可以大大缩小 SVG 文件体积。</p>
<h3>Keypirinha</h3>
<p><a href="https://keypirinha.com/index.html">Keypirinha — Keypirinha</a> 是一款<code>Windows</code>下的文件、应用、浏览器书签快速搜索工具，类似<code>macOS</code>的<code>raycast</code>或<code>alfred</code>。</p>
<h3>Snipaste</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230730221306586.png" alt="image-20230730221306586"></p>
<p><a href="https://zh.snipaste.com/">Snipaste - 截图 + 贴图</a> 超强工具，跨平台支持得非常好。</p>
<h3>Trim Video</h3>
<p><a href="https://online-video-cutter.com/">Video Trimmer - Cut Video Online for Free - MP4, AVI, MPG, 3GP</a> 在线屏幕录制和剪切工具，支持 200M 大小以内的文件操作。</p>
<h3>MediaInfo</h3>
<p><a href="https://mediaarea.net/en/MediaInfo">MediaInfo</a>是一个方便的统一显示视频和音频文件最相关技术和标签数据的工具。</p>
<h3>网易云音乐自动签到</h3>
<p><a href="https://github.com/Developer27149/net163-automatic-daily-signin">Developer27149/net163-automatic-daily-signin</a>：复制<code>Cookie</code>到<code>Github</code>仓库，设置对应的密钥，在<code>github action</code>定期调用脚本进行签到。</p>
<h3>简洁的 TypeScript 之书</h3>
<blockquote>
<p>《Concise TypeScript Book》全面而简洁地概述了 TypeScript 的功能。它提供了清晰的解释，涵盖了该语言最新版本中的所有方面，从强大的类型系统到高级功能。无论您是初学者还是经验丰富的开发人员，本书都是增强您对 TypeScript 的理解和熟练程度的宝贵资源。</p>
</blockquote>
<p><a href="https://github.com/gibbok/typescript-book/blob/main/README-zh_CN.md">typescript-book/README-zh_CN.md at main · gibbok/typescript-book</a>翻译了国外这本开源的电子书籍，非常适合前端开发者阅读学习以提高<code>TypeScript</code>语言的熟练度。</p>
<h3>有趣的言论</h3>
<ul>
<li>如果一个人见面就询问你谋生的方式，那么对方大概率在评估对你的尊重程度</li>
<li>卓越的技艺需要刻意地练习</li>
</ul>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何共享和检索终端命令历史]]></title>
            <link>https://i5lin.top/blog/post/1817198918</link>
            <guid>1817198918</guid>
            <pubDate>Sun, 23 Jul 2023 16:47:48 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 42 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![248a9fde-b677-4de6-bce6-542e7580c823-min](https://github.com/Developer27149/blog/assets/23721611/09593590-f547-40]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 42 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/09593590-f547-4088-8c25-e5d683fae9a0" alt="248a9fde-b677-4de6-bce6-542e7580c823-min"></p>
<blockquote>
<p>封面图：我的小闪电穿过前司发的日历📅</p>
</blockquote>
<p>以下是本周分享的内容：</p>
<h3>Atuin</h3>
<img width="962" alt="image" src="https://github.com/Developer27149/blog/assets/23721611/013a124b-d040-4138-9397-cb49e82d6efd">

<p><a href="https://atuin.sh/"><a href="https://atuin.sh/">Magical Shell History | Atuin</a></a> 是一款基于<code>Rust</code>语言开发的命令行工具，可以同步、搜索、备份<code>shell</code>历史命令。如果你是一个<code>shell</code>重度用户，别错过这个应用~</p>
<p>支持如下<code>shell</code>:</p>
<ul>
<li>zsh</li>
<li>bash</li>
<li>fish</li>
<li>nushell</li>
</ul>
<p>如果你想要同步数据，那么需要使用命令行去注册一个账户，否则无法在不同的设备中共享数据。如果你有安全性的担忧，那么也可以自己部署一个服务。</p>
<h3>1Clipboard</h3>
<p>如果你希望能随时查找最近复制的文本、文件、图片等内容，或许你需要一个剪贴板工具。在<code>macOS</code>系统下，推荐使用<a href="https://maccy.app/"><a href="https://maccy.app/">Maccy - macOS clipboard manager</a></a>，不过这个工具仅有<code>macOS</code>版本。</p>
<p>在 Windows 下我找到了替代品：</p>
<p><a href="https://1clipboard.io/"><a href="https://1clipboard.io/">1Clipboard - A universal clipboard managing app that makes it easy to access your clipboard from anywhere on any device.</a></a>：跨平台的剪贴板管理工具，支持<code>Windows</code>和<code>macOS</code>系统。</p>
<p>此外，这个工具是基于<code>Electron</code>和<code>Angular</code>构建的开源项目，你可以在<a href="https://github.com/wiziple/1Clipboard"><a href="https://github.com/wiziple/1Clipboard">wiziple/1Clipboard: A universal clipboard managing app that makes it easy to access your clipboard from anywhere on any device.</a></a>访问这个仓库，不过目前作者正打算更新技术栈，后续应该会重新发布一个新的仓库。</p>
<h3>Umami</h3>
<p><a href="https://umami.is/"><a href="https://umami.is/">umami</a></a>是一个开源的网站数据分析工具，这是一个谷歌分析的替代方案，主打一个易用性和开源。</p>
<p><img src="https://cdn.fliggy.com/upic/ScreenFlow.gif" alt=""></p>
<h3>Final2x</h3>
<p><a href="https://github.com/Tohrusky/Final2x"><a href="https://github.com/Tohrusky/Final2x">Tohrusky/Final2x: 2^x Image Super-Resolution ☢️</a></a> 跨平台的图片处理工具，可以使用多个模型将图像超分辨率增强到任意大小，以提高图像的分辨率和质量，使其更清晰和更详细。目前，它支持几种模型，如RealCUGAN、RealESRGAN、Waifu2x和SRMD。</p>
<p><img src="https://camo.githubusercontent.com/31265fc29461c525ed134a59bc05307db39fd71fb3345e2b83dc29a5e80b31a2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30372f32302f685769345536424e65716175334d462e706e67" alt=""></p>
<p>如果你需要根据一些低画质的图片去搜寻高画质的版本，或许可以试试这个工具。</p>
<h3>⌘K</h3>
<p><img src="https://github.com/pacocoursey/cmdk/raw/main/website/public/og.png" alt=""></p>
<p><a href="https://cmdk.paco.me/"><a href="https://cmdk.paco.me/">Fast, composable, unstyled command menu for React — ⌘K</a></a>：快速、灵活、无样式的菜单搜索<code>React</code>组件，你可以将项目包装在其他组件中，甚至可以作为静态JSX。</p>
<p>使用这个无样式组件我们可以大大减少自己去设计、实现基础逻辑的编码时间，节省精力！</p>
<p>让我们把时间花在开发应用上来~</p>
<h3>Novu</h3>
<p><a href="https://novu.co/"><a href="https://novu.co/">Novu - The open-source notification infrastructure</a></a>：开源的通知基础设施系统，用于发送短信、邮件、Slack 和 PUSH 通知。</p>
<blockquote>
<p>你既可以使用对方提供的服务，也可以自己部署。</p>
</blockquote>
<p>在开发阶段使用免费额度即可，此外还给独立开发者提供了较多的免费服务。</p>
<p>如下所示是一个简单的邮件 SDK 示例：</p>
<pre><code class="language-js">import {Novu} from &#39;@novu/node&#39;;
const novu = new Novu(process.env.NOVU_API_KEY);
await novu.trigger(&#39;&lt;TRIGGER_NAME&gt;&#39;,
  {
    to: {
      subscriberId: &#39;&lt;UNIQUE_IDENTIFIER&gt;&#39;,
      email: &#39;john@doemail.com&#39;,
      firstName: &#39;John&#39;,
      lastName: &#39;Doe&#39;,
    },
    payload: {
      name: &quot;Hello World&quot;,
      organization: {logo: &#39;https://happycorp.com/logo.png&#39;,},
    },
  }
);
</code></pre>
<h3>IMageOptim</h3>
<p><img src="https://imageoptim.com/ImageOptim-app@2x.png" alt=""></p>
<p><a href="https://imageoptim.com/howto.html">ImageOptim — better Save for Web</a>：一个GUI界面的无损图像优化<code>macOS</code>工具。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[爸，我该怎么做？]]></title>
            <link>https://i5lin.top/blog/post/1810299734</link>
            <guid>1810299734</guid>
            <pubDate>Tue, 18 Jul 2023 16:34:09 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 41 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![image](https://github.com/Developer27149/blog/assets/23721611/f64e24d5-f69f-46fa-97e3-64de25581fda)




> 封面]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 41 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/f64e24d5-f69f-46fa-97e3-64de25581fda" alt="image"></p>
<blockquote>
<p>封面图：我的闪电</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>Dad,how do I?</h3>
<p><img src="https://adayimg.com/wp-content/uploads/2020/05/409bc0e770f6a3c46272697bbc1f12cc.jpg" alt=""></p>
<p><a href="https://www.youtube.com/@DadhowdoI/about"><a href="https://www.youtube.com/@DadhowdoI/about"> Dad, how do I? - YouTube</a></a>：这个频道有超过四百六十万人订阅。频道作者叫<code>Rob</code>，他在十四岁后就失去了父亲。</p>
<p>在疫情肆虐的日子里，他开设了这个频道，不断上传自己的影片，这些影片介绍了很多很多在学校里不会教导，但是在日常生活中却非常实用的技能，例如：</p>
<ul>
<li>刮胡子</li>
<li>做简餐</li>
<li>修水管</li>
<li>煎鸡蛋</li>
<li>换自行车轮胎</li>
<li>...</li>
</ul>
<p>这个频道起名为<code>Dad,How do I?</code>，就像一份赠予那些家庭破裂或失去父母的孩子的礼物，透过视频，通过一件件生活中的小事，代替父亲的角色，教导他们独立自强。</p>
<h3>File Nesting updater</h3>
<p><img src="https://gw.alipayobjects.com/zos/k/hr/gdcxks.png" alt=""></p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=antfu.file-nesting"><a href="https://marketplace.visualstudio.com/items?itemName=antfu.file-nesting">File Nesting Updater - Visual Studio Marketplace</a></a>：前端圈知名开发者托尼老师开发的<code>vscode</code>插件，可以将杂乱不堪的前端配置文件显示整齐一些。</p>
<p>注意：📢 这个插件仅仅是在编辑器文件目录区修改样式，并没有实际修改目录的结构。</p>
<p>如果你曾对前端诸多配置文件感到厌烦，并且你还是<code>vscode</code>用户，那么你或许可以尝试一下这个插件。</p>
<h3>Github readme stats</h3>
<p><a href="https://github.com/anuraghazra/github-readme-stats#show-more-languages">anuraghazra/github-readme-stats: :zap: Dynamically generated stats for your github readmes</a></p>
<p>如果你想在你的 README 中获取动态生成的 GitHub 统计信息，这个仓库可以帮到大忙！</p>
<h3>React-lines-ellipsis</h3>
<p><a href="https://github.com/xiaody/react-lines-ellipsis"><a href="https://github.com/xiaody/react-lines-ellipsis">xiaody/react-lines-ellipsis: Simple multiline ellipsis component for React.JS</a></a>：一款简单的<code>React</code>多行截断，显示查看更多按钮的组件。</p>
<h3>Compresspng</h3>
<p><a href="https://compresspng.com/zh/"><a href="https://compresspng.com/zh/">在线压缩PNG图像</a></a>：免费的在线图像压缩工具，相比 tinypng 5M 的文件大小限制，这个工具则仅限制最多一次上传 20 张图片，且无大小限制。</p>
<p>对于临时需要压缩一些大型截图非常有用，上传的数据会在一小时后清理掉。</p>
<p>同时也支持压缩：</p>
<ul>
<li>jpeg</li>
<li>gif</li>
<li>pdf</li>
</ul>
<h3>深入设计模式</h3>
<p><img src="https://refactoringguru.cn/images/patterns/content/index-design-patterns-2x.png" alt=""></p>
<p>图文并茂的<a href="https://refactoringguru.cn/"><a href="https://refactoringguru.cn/">免费在线学习代码重构和设计模式</a></a>！官方网站的书籍分享：</p>
<p>深入设计模式.pdf <a href="https://www.aliyundrive.com/s/H47VfoYs4NT">https://www.aliyundrive.com/s/H47VfoYs4NT</a> </p>
<h3>设计模式 - 语雀</h3>
<p><a href="https://www.yuque.com/ant-design/design-pattern"><a href="https://www.yuque.com/ant-design/design-pattern">设计模式</a></a>：语雀上的设计模式分析技术分享，完整地记录了产品设计中各种常见的需求和交互设计原理和方案，总共 26 个文档，近 4 万字。</p>
<p>对产品设计和用户交互有兴趣的朋友可以看看。</p>
<h3>Wormhole</h3>
<p><a href="https://wormhole.app/"><a href="https://wormhole.app/">Wormhole - 简单、私密的文件共享</a></a>：不限速、最大上传<code>10G</code>的文件，作者声称不会存储加密密钥，服务端无法解密上传的文件，也不关心用户上传的内容，并且这些内容将会在 24 小时后自动从服务器上删除。</p>
<p>如果你临时需要一个文件网络共享服务，可以使用<code>wormhole</code>！</p>
<h3>SendGrid</h3>
<p><a href="https://sendgrid.com/pricing/"><a href="https://sendgrid.com/pricing/">Pricing and Plans | SendGrid</a></a>：一天一百次免费额度的邮件服务<code>API</code>，轻度使用尚可。</p>
<p>同类型的还有<a href="https://elasticemail.com/"><a href="https://elasticemail.com/">Email Marketing Software. Mail Delivery API | Elastic Email</a></a>，网站做得很精美，宣传也不错。免费额度也是每天一百次。</p>
<h3>JS-Screen-Shot</h3>
<p><a href="https://www.kaisir.cn/js-screen-shot/"><a href="https://www.kaisir.cn/js-screen-shot/">js-screen-shot · likaia</a></a>：国人作者开发的原生 JavaScript 截图库，支持<code>commonjs</code>和<code>ESModule</code>以及<code>script</code>标签引入，创建实例后即可截图，支持<code>h2c</code>和<code>webrtc</code>两种模式。</p>
<p>此外，如果你是一个<code>vue3</code>用户，则可以直接使用其插件：<a href="https://www.npmjs.com/package/vue-web-screen-shot"><a href="https://www.npmjs.com/package/vue-web-screen-shot">vue-web-screen-shot - npm</a></a>。</p>
<h3>Railway</h3>
<p><a href="https://railway.app/"><a href="https://railway.app/">Railwayopen in new window</a></a> 是一个可免费使用的 Serverless 部署平台。我们可以快速的将自己的项目部署到 Railway 平台上，甚至可以部署一些常见的数据库服务。</p>
<p>目前来看，每个月具有 5 美元额度可用，部署一些小的服务没问题。</p>
<h3>岚</h3>
<p><a href="https://unsplash.com/collections/hkToSCaeZUE/%E5%B2%9A"><a href="https://unsplash.com/collections/hkToSCaeZUE/%E5%B2%9A">岚 | 72 best free wallpaper, background, outdoor and desktop photos on Unsplash</a></a>，我收藏的壁纸。</p>
<h3>最后</h3>
<p>咕咕咕...</p>
<p>鸽了两周，我离职又找到新的工作了，离开了上家公司之后歇了一段时间。后面就是跨省搬家来来回回之类的事情比较麻烦，不过总的来说非常开心，事情都办完了，还接了小闪电到家。</p>
<p>总之，周刊还是会继续发~</p>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 Excalidraw 绘制具有手绘风格的白板图]]></title>
            <link>https://i5lin.top/blog/post/1773363679</link>
            <guid>1773363679</guid>
            <pubDate>Sun, 25 Jun 2023 16:18:20 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 40 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![image-20230625235625020](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625235625020.png)
]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 40 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625235625020.png" alt="image-20230625235625020"></p>
<blockquote>
<p>封面图：6-18 大卖喵喵</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>Excalidraw</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625164041981.png" alt="image-20230625164041981"></p>
<p><a href="https://excalidraw.com/">Excalidraw</a> 是一款手绘风格的白板工具，上手极其容易，画风活泼。对于经常要阐述抽象概念的人非常友好，借助这款工具可以画出轻松活泼的图示，提高趣味性。</p>
<p>此外，<code>Excalidraw</code>官方支持<code>PWA</code>模式，我们可以直接安装到本地使用。</p>
<blockquote>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.excalidraw.com%2Fintroducing-excalidraw-plus%2F">excalidraw+</a>可完成团队、账号、数据在线存储等管理，你只需要为团队版付费。</p>
</blockquote>
<p>除了用来画图外，这款工具也适用于远程会议、上网课或者公众演示的场合。</p>
<h3>Day Progress</h3>
<p><a href="https://sindresorhus.com/day-progress">Day Progress — Sindre Sorhus</a>:展示在 MacOS 菜单栏中剩余的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/screenshot1.80cd3c2a.jpg" alt=""></p>
<p>亦或</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/screenshot2.053fd13d.jpg" alt=""></p>
<h3>CSS 技术揭秘与实战通关</h3>
<p>掘金小册推荐，<a href="https://s.juejin.cn/ds/yNoddg4/">CSS技术揭秘与实战通关</a>! 虾皮高级前端技术专家 Chokcoco 编写的，质量非常高。另外，她还发了五折优惠码:<code>MUaL03Ap</code>~</p>
<blockquote>
<p><a href="https://s.juejin.cn/ds/yNoddg4/">https://s.juejin.cn/ds/yNoddg4/</a> 这是推广链接，点击购买小册的话也算是支持我了~</p>
</blockquote>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/5a1c0036-2580-4146-84bc-37fedb30971a" alt="image"></p>
<h3>Wechat Repair Tool</h3>
<p>通常在微信内打开链接默认会打开微信浏览器，如果你想改变这个行为，使用默认的浏览器打开链接，那么你可以这样做：</p>
<ul>
<li>在用户输入框内输入：<code>:recover</code>打开修复工具</li>
<li>勾选右下角配置区域的选项：<code>使用默认浏览器打开链接</code></li>
</ul>
<h3>Rapid API</h3>
<p><a href="https://paw.cloud/">RapidAPI for Mac – The most advanced API tool for Mac</a>：<code>RapidAPI for Mac</code> 是一个全功能的<code> HTTP</code> 客户端。它有一个漂亮的本地 macOS 界面来组合请求、检查服务器响应、生成客户端代码和导出 API 定义。</p>
<p>配合<a href="https://rapidapi.com/hub">API Hub - Free Public &amp; Open Rest APIs | Rapid</a>服务的真实世界<code>API</code> 食用更佳，大多数服务都提供免费额度，我们可以用来实现最基础的功能。</p>
<h3>Swift Programming Language 中文版</h3>
<p>苹果<code>Swift</code>语言的官方文档如下：</p>
<ul>
<li>原版：<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/">The Swift Programming Language (5.9 beta) | Documentation</a></li>
<li>中文版：<a href="https://github.com/SwiftGGTeam/the-swift-programming-language-in-chinese">SwiftGGTeam/the-swift-programming-language-in-chinese: 中文版 Apple 官方 Swift 教程《The Swift Programming Language》</a></li>
</ul>
<h3>矢量图下载站</h3>
<p><a href="https://www.manypixels.co/gallery">Free to Use Clip Art Images &amp; Vector Illustrations | ManyPixels</a>：免费使用艺术图片和矢量图，2500+ 的免费资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625171921866.png" alt="image-20230625171921866"></p>
<h3>Monica - 随时随地聊天</h3>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625185751711.png" alt="image-20230625185751711"></p>
<p><a href="https://monica.im/desktop#installation">Monica | 您的 ChatGPT AI 智能助理</a>：现在已经出了桌面<code>APP</code>了，支持<code>MacOS</code>和<code>Windows</code>！</p>
<h3>Flash 保存计划</h3>
<blockquote>
<p>魔塔！</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230625172555937.png" alt="image-20230625172555937"></p>
<p><a href="https://flash.zczc.cz/">Flash 保存计划</a>：是一个flash游戏发烧友创建的站点，收藏了很多八零后九零后喜闻乐见的flash游戏，想玩一下的都可以用浏览器访问去寻找一下少年的记忆。</p>
<h3>蜘蛛侠之纵横宇宙</h3>
<p><a href="https://movie.douban.com/subject/30391186/">蜘蛛侠：纵横宇宙 (豆瓣)</a>：电影推荐，真好看啊！18 年出了前作<a href="https://movie.douban.com/subject/26374197/">蜘蛛侠：平行宇宙 (豆瓣)</a>，强推先看平行宇宙！</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何使用多个 github 账户在本地推送代码]]></title>
            <link>https://i5lin.top/blog/post/1764743198</link>
            <guid>1764743198</guid>
            <pubDate>Tue, 20 Jun 2023 06:36:48 GMT</pubDate>
            <description><![CDATA[从零开始在你的电脑上配置多个 github 账户。]]></description>
            <content:encoded><![CDATA[<p><img src="https://images.unsplash.com/photo-1647166545674-ce28ce93bdca?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1470&q=80" alt=""></p>
<p>Hello，大家好。今天给大家分享一下，如何在自己的电脑上配置多个<code>github</code>账户，这样有多个账户的朋友就可以很方便地在本地互不干扰地推送代码了。</p>
<h2>账号设置</h2>
<p>前置步骤如下：</p>
<ul>
<li>前往<code>github</code>注册两个账号</li>
<li>安装<code>git</code>到本地</li>
<li>生成<code>ssh</code>密钥</li>
</ul>
<p>注册账户和安装<code>git</code>不需多言，假设我们现在注册了两个账户<code>User1</code>和<code>User2</code>，二者的注册邮箱分别是<code>user1@qq.com</code>和<code>user2@qq.com</code>。然后打开终端，我们从生成<code>ssh</code>密钥开始：</p>
<pre><code class="language-bash"># 输入命令后一直按回车即可，如果你对这些参数有疑惑，可以查找搜索引擎解释~
ssh-keygen -t rsa -b 4096 -C &quot;user1@qq.com&quot; -f ~/.ssh/user1
ssh-keygen -t rsa -b 4096 -C &quot;user2@qq.com&quot; -f ~/.ssh/user2
</code></pre>
<p>如上操作即可生成两个对应账户可用的密钥文件：</p>
<ul>
<li><code>~/.ssh/user1</code> 和 <code>~/.ssh/user1.pub</code></li>
<li><code>~/.ssh/user2</code> 和 <code>~/.ssh/user2.pub</code></li>
</ul>
<p>在生成密钥后，我们需要逐一将之复制到<code>github</code>的<a href="https://github.com/settings/keys">SSH and GPG keys</a>配置中去。</p>
<p>我们可以逐一登录账户，并且进入<a href="https://github.com/settings/keys">SSH and GPG keys</a>这个页面下，点击<code>New SSH key</code>按钮，再填写一个有助于你记忆这个密钥的信息的标题，<code>Key type</code>默认选择<code>Authentication Key</code>即可。</p>
<p>随后，将我们的密钥文件：<code>~/.ssh/user1.pub</code>的内容（<strong>注意这个密钥需要对应用户名user1</strong>，稍后复制的是<code>user2.pub</code>）复制到<code>Key</code>区域内即可。</p>
<p>📢：推荐执行以下命令复制密钥，以免复制的时候带上其他字符。（当然，你也可以通过<code>cat</code>命令查看密钥再复制，或是用文本编辑器打开密钥文件再复制）如下命令行操作如果有问题，可以用最简单的<code>cat</code>命令查看密钥，再用鼠标复制。</p>
<pre><code class="language-bash"># macOS
tr -d &#39;\n&#39; &lt; ~/.ssh/user1.pub | pbcopy
# Linux
xclip -sel clip &lt; ~/.ssh/user1.pub
# Windows
cat ~/.ssh/user1.pub | clip
</code></pre>
<p>如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230620130115497.png" alt="image-20230620130115497"></p>
<p><strong>然后退出登录，切换另一个账户继续上面的操作，注意别复制错了密钥文件</strong>。</p>
<h2>ssh 配置</h2>
<p>首先，我们切换到<code>.ssh</code>目录下并且编辑配置文件：</p>
<pre><code class="language-bash">cd ~/.ssh
# 编辑配置文件
vim config
</code></pre>
<blockquote>
<p>你可以选择你擅长的编辑器来编辑配置文件，如果<code>config</code>文件不存在，则直接创建一个即可。</p>
</blockquote>
<p>接着编辑配置文件：</p>
<pre><code class="language-bash"># user1
Host github.com
  HostName github.com
  User git
  IdentityFile ~/.ssh/user1
  IdentitiesOnly yes

# user2
Host user2
  HostName github.com
  User git
  IdentityFile ~/.ssh/user2
  IdentitiesOnly yes
</code></pre>
<p>来解释一下这些配置字段：</p>
<ul>
<li>Host：SSH连接的别名，我们有多个账户，但为了方便起见我们可以将<code>user1</code>视为主号，这样我们可以直接配置<code>Host github.com</code>作为别名。在 github 仓库克隆<code>ssh</code>链接的时候，<code>github.com</code>就是默认的别名。</li>
<li>HostName：远程服务器的实际域名，显然我们需要统一设置为<code>github.com</code></li>
<li>User：连接到远程服务器时使用的用户名，对于大多数<code>Git</code>服务器来说都使用<code>git</code>作为用户名，不建议修改这个字段。当然，你想修改也是可以的，最终的身份鉴别还是根据<code>ssh</code>密钥来处理的</li>
<li>IdentityFile：密钥文件路径（注意别填写成<code>.pub</code>结尾的公钥）</li>
<li>IdentitiesOnly：仅使用<code>IdentityFile</code>指定的配置文件密钥，忽略<code>ssh-agent</code>提供的密钥。</li>
</ul>
<blockquote>
<p>ssh-agent 是一个辅助程序，用于管理和缓存<code>SSH</code>私钥，它允许您在需要时轻松地通过缓存的密钥进行身份验证，而无需每次都手动输入密码。这在使用多个 SSH 密钥和连接到多个远程服务器时非常实用。</p>
</blockquote>
<h2>git 配置</h2>
<p>在配置好<code>github</code>的公钥和<code>ssh config</code>的私钥后，我们继续配置<code>git</code>的内容。</p>
<p>首先，当我们再使用 <code>Git</code> 向 <code>GitHub</code> 推送更改时，如果您没有在本地 <code>Git</code> 环境中设置全局用户名和电子邮件地址，就会出现配置全局用户信息的提示。这是因为 Git 需要知道在提交更改时应该使用哪个用户身份。我们可以配置一个全局的用户信息：</p>
<pre><code class="language-bash">git config --global user.name &quot;user1&quot;
git config --global user.email &quot;user1@qq.com&quot;
</code></pre>
<p>配置了全局用户名和邮箱之后，在用主号操作<code>github</code>的仓库时就可以省去配置对应的用户信息。</p>
<p>并且结合之前的<code>config</code>配置，我们默认<code>Host</code>使用了<code>github.com</code>别名，那么我们就可以直接在<code>github</code>仓库下通过默认的<code>ssh</code>链接来克隆仓库了。</p>
<p>而如果我需要克隆另一个账户的代码，并且以另一个账户为身份去推送代码，那么就可以在复制<code>github</code>的<code>ssh</code>链接时修改别名。</p>
<p>举个例子：</p>
<pre><code class="language-bash"># 默认
git clone git@github.com:user2/test.git
# 修改别名为 ~/.ssh/config 的别名
git clone git@user2:user2/test.git
</code></pre>
<p>如此一来，克隆到本地的<code>test</code>仓库将会存在一个<code>.git</code>目录，此目录下的<code>config</code>文件就是仓库的<code>git</code>配置文件。</p>
<p>其内部会记录一个<code>[remote &quot;origin&quot;]</code>字段，其中的<code>url</code>将会保存好这个别名和仓库的归属人和仓库名信息。</p>
<p>为了让我们在这个项目下使用<code>push</code>等操作时能让<code>git</code>正确识别到所用的<code>github</code>账户。</p>
<p>我们可以执行一下命令：</p>
<pre><code class="language-bash"> git config --local user.name &quot;user2&quot;
 git config --local user.email &quot;user2@qq.com&quot;
</code></pre>
<p>如此一来，<code>git</code>就会将这个仓库下推送代码等操作所使用的账户信息写到<code>.git/config</code>文件中。</p>
<p>最后，我们就可以随时在不同的仓库下使用我们想要的账户去提交代码了。</p>
<h2>最后</h2>
<p>因为笔者前几天创建了两个<code>github</code>的账户来做一些事情，才有这个需求。因此，查了一些参考的文档和文章，如果能帮到大家，也是一件好事。</p>
<p>📢：如果这个配置有什么错漏，欢迎指正。</p>
<h2>参考</h2>
<ul>
<li><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh">Connecting to GitHub with SSH</a></p>
</li>
<li><p><a href="https://gist.github.com/Jonalogy/54091c98946cfe4f8cdab2bea79430f9">Handling Multiple Github Accounts on MacOS</a></p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[保持好奇心使人年轻]]></title>
            <link>https://i5lin.top/blog/post/1763425181</link>
            <guid>1763425181</guid>
            <pubDate>Mon, 19 Jun 2023 12:19:59 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 39 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀



![image-20230619201757304](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230619201757304.pn]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 39 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230619201757304.png" alt="image-20230619201757304"></p>
<blockquote>
<p>封面图：喵喵喵</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>Vercel AI SDK</h3>
<p><a href="https://sdk.vercel.ai/docs"> Vercel AI SDK</a>：Vercel 公司开发的一个基于<code>openai</code>的编程 SDK ，用户可以轻松使用这个 SDK 来搭建后端和前端服务，构建基于<code>openai</code>的第三方应用。</p>
<p>并且，开发者可以直接<code>fork</code>github 上的<a href="https://github.com/vercel-labs/ai">vercel-labs/ai: Build AI-powered applications with React, Svelte, and Vue</a>这个仓库，在<code>vercel</code>后台构建应用来体验一个最简化版本的<code>openai</code>服务，与<code>chatGPT 3.5</code>模型进行对话。</p>
<blockquote>
<p>免费版不稳定，而且通常国内没法正常访问。</p>
</blockquote>
<p>使用这个仓库构建的应用不需要我们提供<code>api token</code>，如果是本地构建或自己搭建则需要在配置文件里提供<code>token</code>，并且官方提供了以下几个模板项目供大家参考：</p>
<ul>
<li><a href="https://github.com/vercel-labs/ai/tree/main/examples/next-openai">ai/examples/next-openai at main · vercel-labs/ai · GitHub</a></li>
<li><a href="https://github.com/vercel-labs/ai/tree/main/examples/sveltekit-openai">ai/examples/sveltekit-openai at main · vercel-labs/ai · GitHub</a></li>
<li><a href="https://github.com/vercel-labs/ai/tree/main/examples/next-huggingface">ai/examples/next-huggingface at main · vercel-labs/ai · GitHub</a></li>
<li><a href="https://github.com/vercel-labs/ai/blob/main/examples/nuxt-openai/README.md">ai/examples/nuxt-openai/README.md at main · vercel-labs/ai · GitHub</a></li>
</ul>
<p>如上所示，覆盖了<code>React</code>、<code>Vue</code>、<code>Svelte</code>三个主流前端开发框架。</p>
<h3>JSer Dev 博客</h3>
<p><a href="https://jser.dev/">JSer.dev</a>：宝藏博主，全英文博客。内容非常值得初中级Web 开发者学习。</p>
<h3>JSer Dev QuickCode 75</h3>
<blockquote>
<p>让我们面对现实，算法问题在求职面试中仍然很重要，所以我在<code>LeetCode</code>上进行练习。</p>
<p>我没有时间去攻克所有的问题，所以<code>Grind 75</code>是我想要专注的问题列表。但是仍然需要大量时间来练习。当我们完成这个列表后，我们可能会开始遗忘，至少对我来说是这样。</p>
</blockquote>
<p><a href="https://jser.dev/2023-05-21-quick-code-75/">Introducing QuickCode 75 - a companion app for Grind 75</a>：浅层算法核心的 75 道题。</p>
<h3>DoDD</h3>
<p><a href="https://chrome.google.com/webstore/detail/dodd/kgneifofomjghckaeelmgmmpaiaodpmi?hl=en-GB">DoDD</a>:基于好友的 TODO List 应用开发的 Chrome 浏览器插件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230619201446191.png" alt="image-20230619201446191"></p>
<p>忽略里面头像展示不了的问题，这家伙突然不返回头像了，不关我事。</p>
<h3>v2ex-jobs</h3>
<p><a href="https://github.com/Developer27149/v2ex-jobs">Developer27149/v2ex-jobs: 一个chrome浏览器插件，随时查看最新的v2ex工作招聘咨询，支持按需检索</a></p>
<h3>爱发电</h3>
<p><a href="https://afdian.net/">爱发电 · 连接创作者与粉丝的会员制平台</a>：笔者看到尤雨溪在这里发布了赞助支持的信息。</p>
<p>要吃饭的嘛~支持一下开源社区的创作者们。如果你是一个开源创作者，或许可以在这里发布你的讯息，让得益于你的作品的人有一个简单的渠道支持一下你。</p>
<p>我觉得这是一件好事😂</p>
<h3>EasyDict</h3>
<p>跟我一样贫穷？买不起<code>bob</code>翻译？</p>
<p>那就用<code>EasyDict</code>代替。</p>
<p><img src="https://raw.githubusercontent.com/tisfeng/ImageBed/main/uPic/icon_512x512-1671278252.png" alt=""></p>
<p><a href="https://github.com/tisfeng/Easydict">tisfeng/Easydict: 一个简洁优雅的翻译词典 macOS App。开箱即用，支持离线 OCR 识别，支持有道词典，🍎苹果系统翻译，DeepL，谷歌，百度和火山翻译。A concise and elegant Dictionary and Translator macOS App for looking up words and translating text.</a></p>
<h3>Raycast 翻译</h3>
<p><a href="https://www.raycast.com/isfeng/easydict#install">Raycast Store: Easy Dictionary</a>：EasyDict 的 Raycast 插件版本，如果你是重度的 Raycast 用户，这个翻译插件足以代替其他翻译工具。</p>
<h3>Raycast 修改哈希值</h3>
<p><a href="https://www.raycast.com/isfeng/modify-hash">Raycast Store: Modify Hash</a>：快速修改文件哈希值、文件加密和解密。有时候我们需要将一些文件放到云盘上，为了避免直接被服务商查看到内容，或者根据 MD5 值快速查询、校验等你不想被关照的一切。</p>
<h3>ModernFlyouts</h3>
<p><a href="https://modernflyouts-community.github.io/">ModernFlyouts</a>是一款 Windows 下的音量控制软件，可以代替默认的系统音量配置 UI，颜狗必备。</p>
<blockquote>
<p><a href="https://www.microsoft.com/en-us/p/modernflyouts-preview/9mt60qv066rp&mode=mini">你甚至可以从 Microsoft 商店下载~</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/image-20230618010240529.png" alt="image-20230618010240529"></p>
<h3>糖果梦 AI</h3>
<p><a href="https://ai.tgmeng.com/auth/register?inviteCode=GWXKZ54R9">糖果梦AI</a>：国内可用的 AI 服务，除此之外还有Midjourney绘图服务。</p>
<h3>Github 学生认证</h3>
<p><a href="https://githubedu.com/">Github 学生认证</a>：Github 学生认证可以免费使用 Github copilot 和一些其他服务，诸如 <code>tech</code>域名、<code>name</code>域名、<a href="https://githubedu.com/jetbrains">Jetbrains全家桶</a>等一系列服务，强烈推荐（也不能这么说，有钱还是支持一下正版吧各位）</p>
<blockquote>
<p>注意：不可避免的认证会有封号风险</p>
</blockquote>
<p><code>github copilot</code>绝对是开发者福音。</p>
<h3>AI 图片编辑应用</h3>
<p><a href="https://www.fotor.com/photo-editor-app/editor/text">AI图片编辑 - 使用AI智能优化照片 | Fotor</a>，如果你需要设计一些图片、广告内容、文章封面等等，这个应用或许可以帮上你。</p>
<h3>Pixlr E</h3>
<p><a href="https://pixlr.com/cn/e/">图像编辑器：Pixlr E-免费图像编辑工具</a></p>
<h3>Inter</h3>
<p><a href="https://rsms.me/inter/#features">Inter</a>是一种专为电脑屏幕精心设计的字体。Inter具有较高的<code>x</code>高度，以便于混合大小写和小写文本的可读性。<code>Inter</code>是一种具有多种<code>OpenType</code>功能的可变字体，例如上下文替代功能，可以根据周围字形的形状调整标点符号，斜杠零用于区分“<code>0</code>”和“<code>o</code>”，等宽数字等。</p>
<p>猎奇的朋友可以体验体验，开发者也可以将之换作自己的编辑器字体。</p>
<h3>VSCode Icon theme</h3>
<p><a href="https://github.com/miguelsolorio/vscode-symbols">miguelsolorio/vscode-symbols: A file icon theme for VS Code</a> ：一款新的<code>vscode</code>编辑器图标主题，颜狗们可以看看。</p>
<p><img src="https://github.com/misolori/vscode-symbols/raw/main/preview.png" alt=""></p>
<h3>TTime 翻译软件</h3>
<p><a href="https://ttime.timerecord.cn/">TTime官网 - 一款简洁、高效、高颜值的输入、截图、划词翻译软件</a>，堪比<code>EasyDict</code>和<code>Bob</code>~</p>
<h3>字幕库</h3>
<p><a href="https://zimuku.org/">字幕库(zimuku) -- 字幕下载网站</a>，我找电影字幕的时候看到的站点，资源非常全。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Rust simple tutorial step by step]]></title>
            <link>https://i5lin.top/blog/post/1762191930</link>
            <guid>1762191930</guid>
            <pubDate>Sun, 18 Jun 2023 09:05:02 GMT</pubDate>
            <description><![CDATA[再次学习 Rust 编程，我可能还是会半途而废]]></description>
            <content:encoded><![CDATA[<h1>Rust</h1>
<p><img src="https://regmedia.co.uk/2020/04/28/shutterstock_rust_logo.jpg?x=648&y=324&crop=1" alt=""></p>
<blockquote>
<p>why learning rust?</p>
</blockquote>
<p>Rust 具有极高的性能和内存安全保证，非常适合系统级编程。</p>
<h2>Day1</h2>
<p>打开<code>Rust</code>的世界：</p>
<pre><code class="language-rust">fn main() {
  println!(&quot;hello rust.&quot;);
}
</code></pre>
<p>如上所示，<code>fn</code>关键字标识了一个函数<code>main</code>，一个可执行的<code>Rust</code>程序有且只有一个<code>main</code>函数，并且是整个程序的入口。</p>
<p>函数名后的括号内可以定义可选的参数体，上述例子不需要参数因此为空。函数体则由<code>{}</code>括号括起来，<code>Rust</code> 花括号内是一个<code>Scope</code>（作用域）！</p>
<blockquote>
<p>Rust Scope 指的是定义在花括号内的变量和常量只在花括号内有效。离开花括号后就会被释放。</p>
</blockquote>
<p><code>println!</code>是一个内置<code>macro</code>（宏），用于打印信息到屏幕。根据官方文档的说法，<code>Rust</code>风格的代码，缩进使用的是四个空格，而非<code>tab</code>键。</p>
<blockquote>
<p>如果使用的是<code>println</code>，不加<code>!</code>则表示是调用函数，而非宏。宏和函数的差别，后续会细说。</p>
</blockquote>
<p>最后，单行语句使用<code>;</code>结尾，表示这一行表达式的结束。</p>
<p>在上述简单示例代码完成后，可以用<code>rustc main.rs</code>编译出一个<code>main</code>文件，在<code>Linux</code>或者<code>MacOS</code>上的终端，可以直接使用<code>./main</code>执行这个程序，最终输入：</p>
<pre><code class="language-bash">hello rust.
</code></pre>
<p>复杂的程序也是由若干个基础模块组合起来的，现在我们也算是打开了<code>Rust</code>的世界之门。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 shaku 编写更好的技术文章]]></title>
            <link>https://i5lin.top/blog/post/1753146105</link>
            <guid>1753146105</guid>
            <pubDate>Mon, 12 Jun 2023 16:47:58 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 38 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/561686587700_.pic-fotor-202306130372.jpg)

> 封面图：喵喵]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 38 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/561686587700_.pic-fotor-202306130372.jpg" alt=""></p>
<blockquote>
<p>封面图：喵喵喵</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>写出更好的技术文章：shaku</h3>
<p><a href="https://shaku-web.vercel.app/">shaku-web.vercel.app</a>：shaku 是一个基于<code>React</code>的 markdown 代码示例的库，使用这个库我们可以写出更易读、更优美的代码示例。</p>
<p>举个例子：</p>
<p>默认的<code>markdown</code>渲染：</p>
<pre><code class="language-markdown">```js annotate
const blog = &quot;https://jser.dev&quot;
//                    ^
//       [JSer.dev is the *homepage* for JSer.]
//       [Check it out! [jser.dev](https://jser.dev)]
// This is a normal comment
```
</code></pre>
<p>使用<code>shaku</code>后的渲染效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/NtOOSn.png" alt="image-20230611133949625"></p>
<p>上述<code>markdown</code>内容如果直接渲染成<code>html</code>，其效果是否远不如使用<code>shaku</code>后的示例？</p>
<p>作者利用特定的注释标识，重新设计了渲染逻辑和样式，让代码解释变得更加清晰、可读性大大提高。如果你也有自己的博客，或许可以试试这个库！</p>
<h3>Nextra</h3>
<p><a href="https://nextra.site/">Nextra – Next.js Static Site Generator</a>：基于<code>Next.js</code>的静态站点生成工具，此框架可以轻松生成多语言的页面、支持零配置的全文检索功能。</p>
<p>如果你需要部署一个静态博客或文档应用，非常推荐体验一下。</p>
<p><img src="https://nextra.site/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcard-1.4f54665c.png&w=3840&q=75" alt="img"></p>
<h3>Mailjet</h3>
<p>国外的一个电子邮件服务商，免费的账户提供每天 200 次，每个月发送 6000 封电子邮件的体验额度，并且提供一个邮件编辑器和一系列模板，让用户可以轻松构建自己的邮件内容。</p>
<p>此外，官方还提供了对开发者友好的<code>API</code>服务，支持一系列的开发语言代码示例。</p>
<blockquote>
<p>此外，官方还支持<code>SMS</code>短信服务，有需要的可以深入看看</p>
</blockquote>
<p>如果你需要开发自己的应用，需要做一些订阅、注册验证等功能，非常推荐使用这个站点的服务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/VKszTZ.png" alt=""></p>
<h3>Icônes</h3>
<p><a href="https://icones.js.org/">Icônes</a>：具有即时搜索功能的图标浏览应用，这个应用满足了我对<code>web</code>开发中的<code>svg</code>图标需求的方方面面。</p>
<p>免费、优秀的搜索功能、丰富的图标资源、支持自定义颜色、在线体验的图片 CDN 地址、专门支持各种框架的代码快速复制、易于下载和共享。</p>
<p><img src="https://github.com/antfu/icones/raw/main/screenshots/1.png" alt=""></p>
<h3>Monica</h3>
<p><a href="https://monica.im/">Monica - Your ChatGPT AI Assistant Chrome Extension</a>：笔者心中最好的<code>Chrome GPT</code>插件，安装完成之后甚至可以在国内直连使用。</p>
<p>这是我的邀请链接：<a href="https://monica.im/?c=RRYYYAEH">https://monica.im/?c=RRYYYAEH</a> 如果你有一些关于这个应用的问题，联系我。</p>
<blockquote>
<p>什么是<code>chatGPT</code>?</p>
<p>人工智能不是未来，ta 已经来了。</p>
<p>ChatGPT 是一种基于 GPT 技术的聊天机器人，可以模拟人类对话，回答用户的问题，提供各种服务。</p>
<p>ChatGPT 可以回答各种问题，如天气、新闻、体育、娱乐、历史、文化等等。此外，它还可以提供翻译、计算、提醒、定位等服务。ChatGPT 还可以与用户进行智能对话，帮助解决问题。</p>
</blockquote>
<p>国家化做得很好，支持多语言无缝切换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/c20Yms.png" alt=""></p>
<p>每一个设计都可以体会到开发者非常注重用户体验，在任何网页上选择任何文本，只需翻译、解释、总结或使用自己的提示，轻松处理。<img src="https://assets.monica.im/static/media/translate.ac6759fb680013851770.png" alt=""></p>
<p>除了处理文案，翻译等功能，每天还有三十次的免费提问对话额度。</p>
<blockquote>
<p>开通订阅功能更多一些，适合重度使用的用户</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/ajdRvr.png" alt=""></p>
<p>此外，还有更高的套餐：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/nhA0Lx.png" alt=""></p>
<p>相对于官方<code>20$</code>的价格来说，还是很有吸引力的。</p>
<p>如果我们选择用官方的服务，还需要免得非常多的麻烦事，例如支付、网络、账户风险等等问题。</p>
<p>无可奈何，世界上最大的两股力量都在防着我们。</p>
<h3>Hotkeys-js</h3>
<p><a href="https://github.com/jaywcjlove/hotkeys-js?search=1">hotkeys-js/ at master · jaywcjlove/hotkeys-js · GitHub</a>：原生 JavaScript 处理热键绑定逻辑在<code>web</code>开发中是非常常见的一个需求，尽管这部分的<code>API</code>并不复杂，每个开发者都可以根据文档来实现自己需要处理的需求。但是，我们还是可以借力使用一下<code>hotkeys-js</code>这把瑞士军刀。</p>
<pre><code class="language-bash">╭┈┈╮          ╭┈┈╮  ╭┈┈╮
┆  ├┈┈..┈┈┈┈┈.┆  └┈╮┆  ├┈┈..┈┈┈┈┈..┈┈.┈┈..┈┈┈┈┈.
┆     ┆┆  □  ┆┆   ┈┤┆    &lt; ┆  -__┘┆  ┆  ┆┆__ ┈┈┤
╰┈┈┴┈┈╯╰┈┈┈┈┈╯╰┈┈┈┈╯╰┈┈┴┈┈╯╰┈┈┈┈┈╯╰┈┈┈  ┆╰┈┈┈┈┈╯
                                  ╰┈┈┈┈┈╯
</code></pre>
<p>良好的封装、简洁的使用文档、无依赖纯原生、极小的体积、丰富的测试用例和兼容性优化。</p>
<p>怎能不爱？</p>
<blockquote>
<p><a href="https://github.com/JohannesKlauss/react-hotkeys-hook">JohannesKlauss/react-hotkeys-hook: React hook for using keyboard shortcuts in components.</a> 如果你是<code>react</code>开发者，甚至可以使用这个库来处理按键逻辑，其提供了一个非常<code>react</code>的钩子。</p>
</blockquote>
<h3>Mantine</h3>
<p><a href="https://mantine.dev/">Mantine</a>：一套完整的<code>React</code>UI 解决方案（功能极其丰富），超过 100 个自定义的组件和 50 个功能钩子，让你的<code>React</code>开发更加得心应手。</p>
<p>官方文档还提供了以下几个框架或工具的配合使用指南：</p>
<ul>
<li>NextJS</li>
<li>Vite</li>
<li>Create React app</li>
<li>Remix</li>
<li>Gatsby</li>
</ul>
<p>开发者可以根据自己的需要，定制安装依赖包。</p>
<h3>shadcn UI</h3>
<p><a href="https://ui.shadcn.com/">shadcn/ui</a>：极简冷淡风的 UI 组件，喜欢这种风格的朋友可以看看</p>
<h3>Radix</h3>
<p><a href="https://www.radix-ui.com/">Primitives – Radix UI</a>：无样式组件是未来。</p>
<p>如果我们从零开始设计一个下拉菜单，需要注意什么？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/HPDmpO.png" alt=""></p>
<ul>
<li>使用箭头键、Escape 和 Enter 快捷键，甚至可以通过输入提示来导航菜单。</li>
<li>支持可勾选项，项目可用于执行操作，也可作为复选框或单选按钮控件。</li>
<li>配置下拉菜单是否允许或阻止外部交互。</li>
<li>支持子菜单</li>
<li>当用户关闭下拉菜单或聚焦到外部元素时，精细控制焦点行为。</li>
<li>实现正确的语义和行为，使其对使用辅助技术的人可访问。</li>
<li>体验良好的打开和关闭动画，优化展开的位置</li>
</ul>
<p>以上这些需求，恐怕没有多少家企业会让员工花时间去做这些功能，出活快才是大多数企业对员工的要求。</p>
<p>在不使用难以定制却具有完备样式的 UI 框架时，重新开发这些功能将会极大消耗开发者的时间和精力，并且对开发者的专业技术能力有较高的要求。</p>
<p>因此，如果有人能为我们开发好这些组件的<code>JavaScript</code>功能就好了，我们只需要按设计师的需求去实现样式即可！</p>
<p><code>Radix</code>为此而生！</p>
<p>甚至，我们可以基于<code>Radix</code>和<code>tailwindcss</code>构建团队的组件库。不要再重复设计组件的细节了，只设计样式就好！</p>
<h3>必应翻译 API</h3>
<p><a href="https://github.com/plainheart/bing-translate-api#readme">plainheart/bing-translate-api: A simple and free API for Bing Translator for Node.js</a>：作者逆向了必应翻译的 Web JavaScript 代码，然后封装成了一个简单的<code>node</code>库，效果堪比国内的一些翻译<code>API</code>。</p>
<h3>x-crawl</h3>
<p><a href="https://github.com/coder-hxl/x-crawl">x-crawl</a>：基于 <code>puppeteer</code> 的 nodejs 的爬虫框架。</p>
<p>功能特性如下：</p>
<ul>
<li>模式切换：异步或同步</li>
<li>爬取优先级设置，可以优先爬取目标</li>
<li>多功能：页面（支持单页应用爬取）、接口、文件等</li>
<li>自动生成配置页面，通过 UI 检视状态</li>
<li>定时爬取</li>
<li>错误重试</li>
<li>代理设置</li>
<li>零配置动态生成设备指纹绕过目标基于浏览器指纹的防护机制</li>
<li>采集录制功能</li>
<li>良好的 TypeScript 支持，提升开发体验</li>
</ul>
<p>对于熟悉 TypeScript 的前端开发者来说，使用这个框架可以比较轻松地处理一些数据爬取采集的工作。</p>
<h3>Div100vh</h3>
<p><a href="https://github.com/mvasin/react-div-100vh">mvasin/react-div-100vh: A workaround for the &#39;100vh&#39; issue in mobile browsers</a>：在 Safari 移动端存在一个臭名昭著的<code>100vh</code>问题，如图所示，移动端<code>safari</code>的<code>100vh</code>的高度包含了导航区域遮挡住的部分视图：</p>
<p><img src="https://raw.githubusercontent.com/mvasin/react-div-100vh/master/images/regular-div.png" alt=""></p>
<p>为了解决这个问题，可以使用这个针对性的方案：</p>
<pre><code class="language-react">import Div100vh from &#39;react-div-100vh&#39;

const MyFullHeightComponent = () =&gt; (
  &lt;Div100vh&gt;
    &lt;marquee&gt;Look ma, no crop!&lt;/marquee&gt;
  &lt;/Div100vh&gt;
)
</code></pre>
<p>具体的细节隐藏在组件里了，如果你有兴趣则查看源代码。</p>
<h3>Ameliorated Windows system</h3>
<p><a href="https://ameliorated.io/#top">Ameliorated.io</a>：构建一个纯净的 Windows 系统（如果你有兴趣的话，可以深入了解一下）。这个应用将会在不影响系统稳定性的前提下移除默认的 Windows 下的很多系统内置的应用，你将会得到一个“纯净”的 Windows 操作系统。</p>
<h3>PropelAuth</h3>
<p><a href="https://www.propelauth.com/">PropelAuth - Authentication for B2B products</a>：在产品的早期阶段，可以尝试使用第三方服务来实现用户注册和多平台登录的功能。</p>
<p>此服务在月活 1000 以下的早期阶段，能免费提供 10000 万封电子邮件的转发额度、支持用户密码登录、单点登录、魔术贴登录、审计日志、用户信息收集等功能。如果顺利你的产品得到了超过 1000 的月活人数，那么升级服务即可立即获得新的服务。</p>
<h3>Konsta UI</h3>
<p><a href="https://konstaui.com/#get-started">Konsta UI - Mobile UI components built with Tailwind CSS</a>：基于<code>tailwindcss</code>的移动端组件解决方案，支持<code>react</code>、<code>vue</code>、<code>svelte</code>。</p>
<h3>flowcv</h3>
<p><a href="https://app.flowcv.com/">Dashboard – FlowCV</a>：极简的简历生成应用，感谢 @linying 分享了这个工具，我用这个工具写了自己的新简历</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 OrbStack 运行 MacOS 上的 Docker 镜像]]></title>
            <link>https://i5lin.top/blog/post/1709927370</link>
            <guid>1709927370</guid>
            <pubDate>Mon, 15 May 2023 11:48:12 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 37 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![image](https://github.com/Developer27149/blog/assets/23721611/f7027ad2-bcf6-49fa-8c12-a9c6f35ec45a)


> 封面图：厦门]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 37 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/f7027ad2-bcf6-49fa-8c12-a9c6f35ec45a" alt="image"></p>
<blockquote>
<p>封面图：厦门·园博苑·思念</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>OrbStatck</h3>
<p><a href="https://orbstack.dev/">OrbStack · Fast, light, simple Docker &amp; Linux on macOS</a>：MacOS 上运行 <code>Docker</code>镜像的又一方案。</p>
<p><img src="https://orbstack.dev/_next/image?url=%2Fimg%2Fhero.png&w=3840&q=75" alt=""></p>
<blockquote>
<p>tips：作者还是学生，膜拜</p>
</blockquote>
<p>根据作者的描述，这个工具初始化速度是<code>Docker Desktop</code>的七倍左右，另外在<code>CPU</code>占用率上也远远比<code>Docker Desktop</code>小，网络和内存方面也大大领先，笔者正在体验中，目前感觉就是一个字：<code>快</code>。</p>
<p>非常推荐给大家~</p>
<h3>CSS Gradient</h3>
<p><a href="https://cssgradient.io/">CSS Gradient — Generator, Maker, and Background</a>：方便地生成 CSS 背景过度色和遮罩，另外他的博客也经常更新关于<code>CSS</code>的文章，质量很高。</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/48fc5b81-5823-4d33-b2fb-6a72350c7681" alt="image"></p>
<h3>Icon-Icons</h3>
<p><a href="https://icon-icons.com/">Free Icons PNG, ICO, ICNS and SVG</a>：免费的图片资源素材网站，在提供众多的图标素材外，亮点在于这里有非常全面的<code>MacOS</code>应用程序 Logo 图片资源，如果你需要替换默认的<code>Logo</code>，那么这里的素材非常适合你。</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/fa1a51cd-a743-4c8a-8a00-e2396bd84d81" alt="image"></p>
<h3>SigmaOS</h3>
<p><a href="https://beta.sigmaos.com/">SigmaOS</a>：旨在重新定义用户使用互联网的方式（看起来像是一个新的类<code>Arc</code>浏览器）</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/5bab1701-846e-40a5-b34b-c64c3bb73c25" alt="image"></p>
<h3>高图网</h3>
<p><a href="https://gaoimg.com/">高图网-免费无版权高清图片下载</a>：笔者实在是受不了<code>Unsplash</code>的速度（怪谁呢），找到了一个国内的可商用高清图片站点。</p>
<h3>codeimg</h3>
<p><a href="https://codeimg.io/">Codeimg.io</a>：快速生成美观的代码示例图片，可以快速制作马斯克的社交媒体软件上常见某些代码图示。</p>
<p><img src="https://github.com/Developer27149/blog/assets/23721611/c41d644a-f2a0-4ae5-898a-a5d892c169c3" alt="image"></p>
<h3>AALocker</h3>
<p><code>IOS</code>系统上隐藏应用的绝佳工具，谁还没几个不想让人看到的 APP 了是吧，限时免费到 5 月 31 日。</p>
<p><img src="https://img.lancdn.com/landian/2023/05/98623-1.png" alt=""></p>
<h3>V2EX Polish</h3>
<p><a href="https://v2p.vercel.app/">V2EX Polish - 浏览器插件</a>，专为<code>V2EX</code>用户设计的浏览器插件，丰富的扩展功能带给你出色的体验。</p>
<p><code>V2EX</code>的<code>UI</code>实在是太久没更新了，设计性其实挺一般的，颜控速来体验一下这个插件，支持以下功能：</p>
<ul>
<li>界面美化</li>
<li>评论回复嵌套</li>
<li>热门回复展示</li>
<li>表情回复支持</li>
<li>长回复优化，折叠内容</li>
<li>内置主题列表</li>
<li>等等</li>
</ul>
<h3>React-If</h3>
<p><a href="https://romac.github.io/react-if/">react-if</a>：<code>React</code>的条件渲染解决方案，笔者正在使用。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue 3.3 发布：十分钟速递]]></title>
            <link>https://i5lin.top/blog/post/1708449126</link>
            <guid>1708449126</guid>
            <pubDate>Sat, 13 May 2023 05:55:47 GMT</pubDate>
            <description><![CDATA[大家好，现在是 2023 年 5 月 13 日上午。不知道大家有没有注意到，前天`Vue`发布了`3.3`版本。我今天才看了一下，新的一些特性非常有用，因此想在这里给还没看过的开发者朋友稍微介绍一下最新的特性和使用案例。

![](https://images.unsplash.com/photo-1653387137517-fbc54d488ed8?ixlib=rb-4.0.3&ixid=M]]></description>
            <content:encoded><![CDATA[<p>大家好，现在是 2023 年 5 月 13 日上午。不知道大家有没有注意到，前天<code>Vue</code>发布了<code>3.3</code>版本。我今天才看了一下，新的一些特性非常有用，因此想在这里给还没看过的开发者朋友稍微介绍一下最新的特性和使用案例。</p>
<p><img src="https://images.unsplash.com/photo-1653387137517-fbc54d488ed8?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80" alt=""></p>
<blockquote>
<p>“This release is focused on developer experience improvements” 					- 此版本主要专注开发人员的体验提升</p>
</blockquote>
<h3>总结</h3>
<p>“献给时间紧急的朋友 🚀”</p>
<p>Vue 3.3 已发布，改进了开发人员体验、新语法和宏以及对 <code>TypeScript</code> 的改进。该版本包括通用组件、定义插槽和<code>emit</code>类型、定义组件选项以及响应式<code>props</code>解构和定义模型语法糖等实验性功能。该版本还包括弃用 Reactivity Transform。新宏之一，<code>defineOptions</code>，用于定义 <code>Options API</code> 选项，可用于定义除 props、emits、expose 和 slot 之外的任何选项。另一个新功能是 <code>hoistStatic</code>，它通过将常量声明提升到顶层来优化 <code>SFC</code> 编译器。最后，<code>defineModel</code> 是一个新的语法糖宏，用于定义双向绑定 props。</p>
<h3>单文件组件类型导入</h3>
<p>了解<code>React</code>开发的朋友可能在接触<code>Vue3.2+TypeScript</code>时对于单文件组件无法导入外部 TypeScript 类型而感到困惑和遗憾，其原因在于：</p>
<blockquote>
<p>This is because Vue needs to be able to analyze the properties on the props interface in order to generate corresponding runtime options.</p>
</blockquote>
<p>**Vue 需要能够分析 props 接口上的属性，以便生成相应的运行时选项。**框架底层的限制让开发者只能在定义<code>DefineProps</code>和<code>defineEmits</code>的时候使用本地 TypeScript type 或 interface。</p>
<p>而 <code>3.3</code> 版本终于解决了这个问题（开发团队在 Github issue 里曾承诺会尽快解决这个问题，他们做到了），我们可以从外部导入 TypeScript 类型了：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import type { Props } from &#39;./foo&#39;

// imported + intersection type
defineProps&lt;Props &amp; { extraProp?: string }&gt;()
&lt;/script&gt;
</code></pre>
<p>除此之外，还可以从第三方的包导入其 TypeScript 类型或接口，亦或是引用全局类型描述文件&quot;.d.ts&quot;内的类型。例如：</p>
<pre><code class="language-typescript">import type { Props } from &#39;some-package&#39;
defineProps&lt;Props&gt;()
</code></pre>
<p>但需要注意的是，开发者不能在 props 类型中使用条件类型：</p>
<pre><code class="language-typescript">import type { Props } from &#39;./foo&#39;
// will throw a compiler error
defineProps&lt;Props extends object ? Props : {}&gt;()
</code></pre>
<p>究其原因，还是因为这个特性是基于<code>AST</code>解析的，而非<code>TypeScript</code>的支持。</p>
<h3>泛型组件（Generic Component)</h3>
<p>直接看代码：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot; generic=&quot;T&quot;&gt;
defineProps&lt;{
  items: T[]
  selected: T
}&gt;()
&lt;/script&gt;
</code></pre>
<p>亦或是在泛型定义的时候继承内置或从第三方导入的类型：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot; generic=&quot;T extends MyItem&quot;&gt;
  interface MyItem {
    name: string;
    foo: number
  }

  defineProps&lt;{
    list: T[],
    modelValue?: T
  }&gt;
&lt;/script&gt;
</code></pre>
<p>使用泛型组件时，要注意更新<code>volar</code>和<code>vue-tsc</code>，在调用组件时传参将会变得更加灵活。</p>
<p>诚然，这个泛型组件笔者没有写过，对此也不够了解，十分抱歉。如果你对此很有兴趣，推荐看看讨论区：<a href="https://github.com/vuejs/rfcs/discussions/436"><a href="https://github.com/vuejs/rfcs/discussions/436">Generic component enhancements - Discussion #436</a></a></p>
<h3>更优雅的 DefineEmits</h3>
<p>此前，TypeScript 和 Vue 结合定义 <code>DefineEmits</code>代码只支持如下调用签名的语法：</p>
<pre><code class="language-typescript">&lt;script setup lang=&quot;ts&quot;&gt;
const emits = defineEmits&lt;{
  (evt: &#39;update:modelValue&#39;, value: string): void
  (evt: &#39;change&#39;): void
}&gt;()
</code></pre>
<p>笔者的体验或许跟大多数人一样，这样的写法有点冗长。在<code>3.3</code>版本我们可以这样写了：</p>
<pre><code class="language-typescript">// ⬇️ Vue 3.3 之后
const emits = defineEmits&lt;{
  &#39;update:modelValue&#39;: [value: string],
  &#39;change&#39;: []
}&gt;()
&lt;/script&gt;
</code></pre>
<p>在类型定义中，键就是事件名，值就是函数参数。<strong>新写法不是必须的，你依然可以使用旧的写法</strong>。</p>
<p>笔者较懒，推荐后者 😂</p>
<h3>DefineSlots</h3>
<blockquote>
<p>这是一个全新的特性 👏🏻</p>
</blockquote>
<p>这个特性可以让我们显式地定义插槽的类型，这个特性对于复杂的组件较为有用，来看看下面这个配合泛型组件的示例（代码源于参考文章）：</p>
<p>分页组件：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot; generic=&quot;T&quot;&gt;
// 子组件 Paginator
defineProps&lt;{
  data: T[]
}&gt;()

defineSlots&lt;{
  default(props: { item: T }): any
}&gt;()
&lt;/script&gt;
</code></pre>
<p>使用：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;!-- 父组件 --&gt;
  &lt;Paginator :data=&quot;[1, 2, 3]&quot;&gt;
    &lt;template #default=&quot;{ item }&quot;&gt;{{ item }}&lt;/template&gt;
  &lt;/Paginator&gt;
&lt;/template&gt;
</code></pre>
<p>显式定义类型优于隐式定义类型，有助于提高代码的可读性。</p>
<h3>实验特性</h3>
<blockquote>
<p>试验性的特性都需要在编译工具的配置中开启试验性属性。</p>
</blockquote>
<h4>Props 响应式解构</h4>
<p>此特性可以让我们少写一些代码：</p>
<p>自动保持响应式解构，并且可以使用非常符合 JavaScript 的语法的方式设置默认值。</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { watchEffect } from &#39;vue&#39;

const { msg = &#39;hello&#39; } = defineProps([&#39;msg&#39;])

watchEffect(() =&gt; {
  // accessing `msg` in watchers and computed getters
  // tracks it as a dependency, just like accessing `props.msg`
  console.log(`msg is: ${msg}`)
})
&lt;/script&gt;

&lt;template&gt;{{ msg }}&lt;/template&gt;
</code></pre>
<p>如果你想用 TypeScript，则：</p>
<pre><code class="language-typescript">const { count } = defineProps&lt;{ count: 0 }&gt;()
</code></pre>
<p>此外，记住开启试验性配置：</p>
<p>笔者使用<code>vite</code>编译项目：</p>
<pre><code class="language-js">// vite.config.js
export default {
  plugins: [
    vue({
      script: {
        propsDestructure: true
      }
    })
  ]
}
</code></pre>
<h4>defineModel</h4>
<p>此前，编写支持<code>v-model</code>组件时需要声明<code>props</code>和<code>emit</code>，代码如下所示：</p>
<pre><code class="language-vue">&lt;!-- BEFORE --&gt;
&lt;script setup&gt;
const props = defineProps([&#39;modelValue&#39;])
const emit = defineEmits([&#39;update:modelValue&#39;])
console.log(props.modelValue)

function onInput(e) {
  emit(&#39;update:modelValue&#39;, e.target.value)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input :value=&quot;modelValue&quot; @input=&quot;onInput&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>现在，开启这个<code>defineModel</code>实验性属性就可以这样写：</p>
<pre><code class="language-vue">&lt;!-- AFTER --&gt;
&lt;script setup&gt;
const modelValue = defineModel()
console.log(modelValue.value)
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model=&quot;modelValue&quot; /&gt;
&lt;/template&gt;
</code></pre>
<p>显著降低代码量，懒人必备，早点下班回家撸猫才是正经。</p>
<h3>DefineOptions 宏定义</h3>
<p>笔者在写缓存组件的时候，发现要定义组件的名字，必须在<code>&lt;script setup&gt;</code>之外再使用<code>&lt;script&gt;</code>来声明组件名（我也不需要使用默认的文件名）。实在是麻烦，于是搜索到了 **Kevin Deng **的<a href="https://www.npmjs.com/package/unplugin-vue-define-options"><a href="https://www.npmjs.com/package/unplugin-vue-define-options">unplugin-vue-define-options - npm</a></a> 插件来实现在<code>setup</code>里面定义组件名。</p>
<p>现在，感谢作者的贡献，我们终于可以在<code>3.3</code>版本直接使用内置功能了：</p>
<pre><code class="language-vue">&lt;script setup&gt;
defineOptions({
  name: &#39;Foo&#39;,
  inheritAttrs: false,
  // ... 更多自定义属性
})
&lt;/script&gt;
</code></pre>
<h3>基础设施完善</h3>
<p>除了以上更新之外，开发团队还更新了一些关于基础设施的内容：</p>
<ul>
<li><p>提升静态常量，这个属于编译器优化</p>
</li>
<li><p>提高构建速度，使用<code>rollup-plugin-esbuild</code></p>
</li>
<li><p>提高测试速度：从<code>Jest</code>到<code>Vitest</code>（OK，大家转到<code>Vitest</code>来吧）</p>
</li>
<li><p>加速类型生成，使用<code>rollup-plugin-dts</code></p>
</li>
<li><p>增加回归测试</p>
</li>
</ul>
<h3>参考文档</h3>
<ul>
<li><a href="https://blog.vuejs.org/posts/vue-3-3"><a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3 | The Vue Point</a></a></li>
<li>[<a href="https://xlog.sxzz.moe/vue-3-3">Vue 3.3 主要新特性详解 - 三咲智子 Kevin Deng</a>](</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 CSS BEM 规范对样式进行命名]]></title>
            <link>https://i5lin.top/blog/post/1700587531</link>
            <guid>1700587531</guid>
            <pubDate>Mon, 08 May 2023 16:49:20 GMT</pubDate>
            <description><![CDATA[Hello， 大家好。这里是妙才的周刊第 35 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀

![](https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/X2zhVP.jpg)

> 封面图：象象的猫咪在巡视领地



以下是本周话题：

##]]></description>
            <content:encoded><![CDATA[<p>Hello， 大家好。这里是妙才的周刊第 35 期，这里将会分享笔者每周接触到的科技内容亦或是 Web 开发的一些新知识，甚至是一些有趣的非技术性人、事、物 🚀</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/X2zhVP.jpg" alt=""></p>
<blockquote>
<p>封面图：象象的猫咪在巡视领地</p>
</blockquote>
<p>以下是本周话题：</p>
<h3>Vue Toastification</h3>
<p><a href="https://vue-toastification.maronato.dev/">Vue-Toastification</a>：支持<code>vue2 和 vue3</code>的通知组件，扩展性很好，非常适合作为<code>vue</code>项目独立的消息通知组件。</p>
<p>以下是一些截图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Developer27149/uPic@main/uPic/9dJh3q.png" alt="image-20230509002318298"></p>
<p>这个组件的动画效果还挺不错的，如果需要自定义一些样式也可以通过添加覆盖样式来满足需求。</p>
<h3>CSS BEM 命名规范</h3>
<blockquote>
<p><em>here are only two hard problems in Computer Science: cache invalidation and naming things — Phil Karlton</em></p>
</blockquote>
<p><a href="https://getbem.com/naming/">BEM — Naming</a>：BEM 方法确保参与网站开发的每个人都使用单一代码库并使用相同的语言。使用正确的命名将使您为网站设计的变化做好准备。</p>
<p>如果你需要开发团队组件库，亦或是开源组件库，在编写样式表的时候遵守良好的命名规范有利于后续的维护和提高代码的可读性。最重要的是，你将不必为给样式起名而烦恼。</p>
<p>如果你想看中文分享内容，可以看看这里<a href="https://juejin.cn/post/6844903672162304013">CSS — BEM 命名规范 - 掘金</a>。</p>
<h3>Valtio</h3>
<p><a href="https://valtio.pmnd.rs/">Valtio</a>是日本开发者<strong>dai-shi</strong>开发的又一<code>React</code>状态管理库，Valtio 使代理状态对 React 和 Vanilla 变得简单，笔者将会主力使用此库来处理状态数据操作。</p>
<h3>huntersofbook</h3>
<p><a href="https://opensource.huntersofbook.com/">huntersofbook the door from books to software · huntersofbook</a>：是专门为完善vue生态而建立的社区。作者声称自己的团队将永远把这种贡献回馈给世界。</p>
<p>主要分享：<code>vue3</code>、<code>Nuxt3</code>、<code>Vite4</code>、<code>TypeScript</code>、<code>Npm Packages</code>等技术相关的最佳实践。</p>
<h3><a href="https://ismail9k.github.io/vue3-carousel/">Vue3-carousel | Vue3-carousel</a></h3>
<p><a href="https://ismail9k.github.io/vue3-carousel/">Vue3-carousel | Vue3-carousel</a>是一个基于<code>Vue3</code>的轮播图组件库，代码示例很丰富，我们可以很方便地将之作为项目的轮播图解决方案。</p>
<p>文档内也详细地说明了对外暴露的一些接口和相关特性，入手难度很低。</p>
<h3>Flowbite</h3>
<p><a href="https://flowbite.com/">Flowbite - Build websites even faster with components on top of Tailwind CSS</a>：基于<code>tailwindcss</code>的<code>UI</code>组件库，样式调教得非常赏心悦目。如果你的项目用上了<code>tailwindcss</code>，那么就可以很方便地接入这个<code>UI</code>库。</p>
<p>此外，这个库更新非常频繁，目前已经有了超过 <code>600+</code> 的组件分享，扩展性也很棒。</p>
<h3>Vue3 + TS 搭建组件库</h3>
<p><a href="https://juejin.cn/post/7145113345765408798">Vue3 + TS 搭建组件库 - 掘金</a></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9ad30199ee45a295645f6b907f0d5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>内容很完整，可以作为自己的库的经验参考。</p>
<h3>Background Music</h3>
<p><a href="https://github.com/kyleneideck/BackgroundMusic">kyleneideck/BackgroundMusic: Background Music, a macOS audio utility: automatically pause your music, set individual apps&#39; volumes and record system audio.</a></p>
<p>这是一款<code>MacOS</code>的音乐调节软件，开源免费。</p>
<p>使用这个应用可以方便地单独调整系统每一个应用的音量🔊：<img src="https://github.com/kyleneideck/BackgroundMusic/raw/master/Images/README/Screenshot.png" alt=""></p>
<p>如果你也使用<code>brew</code>来管理应用，那么可以很方便地安装这个应用：</p>
<pre><code class="language-bash">brew install --cask background-music
</code></pre>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Next.js 新版本 v13.4 来了]]></title>
            <link>https://i5lin.top/blog/post/1699131646</link>
            <guid>1699131646</guid>
            <pubDate>Sun, 07 May 2023 16:15:26 GMT</pubDate>
            <description><![CDATA[Next.js v13.4 真的来了

![](https://mobisoftinfotech.com/resources/wp-content/uploads/2022/04/next-JS-framework.png)

2023 年 5 月 5 日，Tim Neutkens 在 NextJS 官网发布了最新的文章来宣告最新版本`Next.js`正式发布。

今天，就让笔者来分享]]></description>
            <content:encoded><![CDATA[<p>Next.js v13.4 真的来了</p>
<p><img src="https://mobisoftinfotech.com/resources/wp-content/uploads/2022/04/next-JS-framework.png" alt=""></p>
<p>2023 年 5 月 5 日，Tim Neutkens 在 NextJS 官网发布了最新的文章来宣告最新版本<code>Next.js</code>正式发布。</p>
<p>今天，就让笔者来分享一下关于<code>Next.js</code>最新版本<code>v13.4</code>的一些消息吧。</p>
<h3>Next.js ？</h3>
<p>为了方便不熟悉<code>Next.js</code>的朋友阅读本文，笔者先简单介绍一下<code>Next.js</code>是什么。</p>
<p><a href="https://nextjs.org/">Next.js by Vercel - The React Framework for the Web</a>：Next.js 是一个基于 React 的轻量级框架，用于构建高性能的 Web 应用程序和静态网站。</p>
<p>它采用了服务器端渲染（SSR）和静态生成（SSG）的技术，可以在客户端和服务器端之间实现快速导航和无缝的数据传输。Next.js 支持自动代码分割、热重载和静态文件服务，并且与许多流行的技术栈和部署平台兼容。</p>
<p>它还提供了一系列丰富的功能，例如动态导入、API 路由、静态优化和预渲染等，可以大大提高开发人员的生产力和开发效率。通过使用 Next.js，开发人员可以轻松构建出具备优秀性能、可维护性和可扩展性的现代 Web 应用程序。</p>
<blockquote>
<p><code>Next.js</code>创立的目标就是提供一个易用的基于<code>React</code>的服务端渲染应用解决方案，乃至创建一个更加动态、个性化和全球化的网络。</p>
</blockquote>
<h3>最新版本</h3>
<p>六个月前，开发团队发布了<code>Next.js v13</code>版本，而最新版本的<code>Next.js</code>已经更新到了<code>v13.4</code>！并且相对于之前的内容有了一些评论两极分化的改动和更新。</p>
<p>首先来看看以下更新内容：</p>
<ul>
<li>APP Router 稳定版<ul>
<li>React 服务器组件</li>
<li>嵌套路由和嵌套布局</li>
<li>简化数据获取</li>
<li>流渲染和Suspense</li>
<li>更好的内置 SEO 功能</li>
</ul>
</li>
<li>Turbopack 测试版</li>
<li>Server Action 测试版</li>
</ul>
<p>在<code>Next.js</code>发布之初（2016 年）便提供了基于目录的约定式路由方案，亦被称为“基于文件系统的路由”，此方案一直是<code>Next.js</code>的核心功能。</p>
<p>随着社区的发展和基于<code>Next.js</code>应用的普及，开发人员发现旧的方案很难实现自定义布局中诸如布局嵌套、单组件的自定义加载和错误状态处理等功能的需求。</p>
<p>在<code>v13.4</code>中，开发者团队发布了一个新的路由器系统：基于新的<code>app/</code>目录创建新的路由系统，开发者不必使用自定义的<code>_app</code>文件来设置全局共享布局，而是转移到了<code>app</code>路由下的<code>layout.ts</code>文件下，并且各个层级的布局可以相互嵌套。</p>
<p>举个例子：</p>
<pre><code class="language-js">// New: App Router ✨
// app/layout.js
//
// The root layout is shared for the entire application
export default function RootLayout({ children }) {
  return (
    &lt;html lang=&quot;en&quot;&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  );
}

// app/dashboard/layout.js
//
// Layouts can be nested and composed
export default function DashboardLayout({ children }) {
  return (
    &lt;section&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      {children}
    &lt;/section&gt;
  );
}
</code></pre>
<p>此外，除非显式地在文件最上方声明<code>&#39;use client&#39;;</code>来告知编译器这是一个客户端组件，否则所有在<code>app/</code>目录下的组件都是服务端组件。</p>
<p>服务端组件的简单示例：</p>
<pre><code class="language-tsx">// app/page.js

export default async function Page() {
  const res = await fetch(&#39;https://api.example.com/...&#39;);
  // The return value is *not* serialized
  // You can use Date, Map, Set, etc.
  const data = res.json();

  return &#39;...&#39;;
}
</code></pre>
<p>获取数据的函数将会仅在服务端运行，数据获取将会很明显地取决于开发人员的需求，开发者可以获取数据并且组成任何组件（包括项目内组件和第三方支持的服务端组件）。</p>
<blockquote>
<p>更多内容，请阅读官方文档：<a href="https://nextjs.org/docs/getting-started/installation">Getting Started: Installation | Next.js</a>。</p>
</blockquote>
<p>至于<code>Turbopack</code>和<code>Server Action</code>，二者都还处于<code>Beta</code>版本。前者号称最快的打包工具，开发者可以通过<code>next dev --turbo</code>加快本地开发模式下的编译速度，并且很快这个功能就将推进到<code>next build --turbo</code>（官方团队放话）。</p>
<p>后者则是随着<code>React</code>对于表单状态管理和数据缓存、验证等需求的思索产生的<code>服务端</code>解决方案（此前一直是客户端来处理），这将运行开发者在服务器上变更数据，直接调用函数而无需创建基于客户端和服务端的 API 层。</p>
<p>听起来很美好，但现在还不是时候，大多数开发者追求的还是稳定，让子弹先飞一会吧。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，后续笔者将用<code>Next.js</code>实现自己的应用程序，同时也会发一些相关的知识分享，欢迎大家一起讨论👏🏻👏🏻</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[每天问目前世界上最先进的人工智能模型一个学习的问题]]></title>
            <link>https://i5lin.top/blog/post/1683327642</link>
            <guid>1683327642</guid>
            <pubDate>Tue, 25 Apr 2023 14:50:28 GMT</pubDate>
            <description><![CDATA[每天免费向 chatGPT 4 问一个问题，你会询问它什么？

![](https://images.unsplash.com/photo-1675271591211-126ad94e495d?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80)
]]></description>
            <content:encoded><![CDATA[<p>每天免费向 chatGPT 4 问一个问题，你会询问它什么？</p>
<p><img src="https://images.unsplash.com/photo-1675271591211-126ad94e495d?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80" alt=""></p>
<p>现在是 2023 年 4 月 24 日，<code>chatGPT</code>已经将我国用户完全封锁了，除非我们使用一些非常规的手段来获得使用机会，否则几乎可以说国内用户已经和官方提供的服务绝缘了。</p>
<blockquote>
<p>+gpt 什么是 chatGPT 4 ?
ChatGPT 4 是指 Chat Generator Pre-trained Transformer 4，它是一个预训练的自然语言处理模型，旨在生成与人类对话相似的响应。ChatGPT 4 是 GPT-4 的一种变体，GPT-4 是 OpenAI 的下一代语言模型，目前已经发布。ChatGPT 4 可以用于聊天机器人、智能客服、语音助手等应用程序中，以帮助用户解决问题、提供信息和娱乐等。</p>
<p>Tips: 上面这句回答是这个世界上最先进的人工智能自然语言处理模型的v3版本针对我的提问返回的答案。</p>
</blockquote>
<p>在这样的情况下，我们怎么做才能最简单地拥有一次向<code>chatGPT 4</code>提问一次的机会，我们又该如何提问呢？</p>
<p>Hello， 大家好。这里是妙才的周刊第26期，本周要分享的内容如下：</p>
<h3>Poe</h3>
<p><a href="https://poe.com/">Sage - Poe</a>：（全称“开放探索平台”，Platform for Open Exploration）<strong>是一款由Quora开发的流动应用程式</strong>，于2022年12月推出。 该应用程式内置建基于人工智能技术的聊天机器人，可供用户向机器人询问专业知识、食谱、日常生活，甚或要求它创作文章等。</p>
<p>重点是支持中文且完全免费，每天有一次机会向<code>chatGPT4</code>或<code>Claude+</code>提问一次，并且向<code>Sage</code>模型、<code>chatGPT3.5</code>模型提问无限制，只要你可以想到都可以提问。</p>
<h3>Learning Prompt</h3>
<p><a href="https://learningprompt.wiki/">Hello from Learning Prompt | Learning Prompt</a> 是一个免费的 Prompt Engineering 教程，现在已经包含了免费的 ChatGPT 和 Midjourney 教程，学习这个教程可以让你更好地使用现今最火热的人工智能来解决现实问题。</p>
<h3>OpenPrompt</h3>
<p>你可以向<code>chatGPT</code>提任何问题，但这并不是免费的。每一个字符都具有价格，每一个问题都花费时间。如何高效地提问是一个很好的问题，在<a href="https://openprompt.co/">Open Prompt</a>你可以看到社区共享的一些<code>Prompt</code>（提问方式），或许能够对你组织自己的提问方式有所帮助。此外，这个站点目前可以每天免费提问10 条，使用体验也很不错。</p>
<h3>Ky</h3>
<p><a href="https://github.com/sindresorhus/ky">sindresorhus/ky: 🌳 Tiny &amp; elegant JavaScript HTTP client based on the browser Fetch API</a></p>
<p><img src="https://github.com/sindresorhus/ky/raw/main/media/logo.svg" alt=""></p>
<p><code>Ky</code>是一个基于<code>fetch api</code>的轻量化（无第三方依赖）的<code>http</code>客户端库，其面相的是现代浏览器（IE 吐槽的就是你）和<code>Deno</code>。</p>
<blockquote>
<p>非常值得学习源代码</p>
</blockquote>
<p>如果非要支持旧的浏览器，可以考虑使用<code>fetch polyfill</code>，如果需要支持<code>SSR</code>那么可以使用<a href="https://github.com/sindresorhus/ky-universal">sindresorhus/ky-universal: Use Ky in both Node.js and browsers</a>。</p>
<h3>AIOS Key</h3>
<p><a href="https://key.aios.chat/">AIOS Key</a>：国内开发者团队创建的基于<code>openai</code>官方接口的中转服务，如果你不想在自己花费大量时间构建自己的后台 API 系统，可以接入这个服务。目前注册免费送 10 万 token，我用来替换了 openCat 的官方<code>key</code>，感觉还不错。</p>
<h3>API 搬运工</h3>
<p><a href="https://github.com/fangzesheng/free-api">fangzesheng/free-api: 收集免费的接口服务,做一个api的搬运工</a>，如果你短暂地需要一个真正的 API，那么可以看看这个免费 API 收集列表。</p>
<h3>Vite-plugin-banner</h3>
<p><a href="https://github.com/chengpeiquan/vite-plugin-banner">chengpeiquan/vite-plugin-banner: A banner plugin for Vite. It can adds a banner to the top of each generated chunk.</a>可以让使用<code>vite</code>进行开发的朋友方便地给打包出来的文件添加描述信息，诸如版本号、作者联系方式、时间日期等等。</p>
<h3>UnoCSS</h3>
<p><a href="https://unocss.dev/">UnoCSS: The instant on-demand Atomic CSS engine</a>：按需即时的原子化 CSS 引擎，一切都在设计时考虑了灵活性和性能。 UnoCSS 中没有核心实用程序，所有功能都是通过预设提供的。 UnoCSS 的主要目标是直观性和可定制性。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[习惯是如此之轻，以至于无法察觉。又是如此之重，以至于无法挣脱。]]></title>
            <link>https://i5lin.top/blog/post/1642353092</link>
            <guid>1642353092</guid>
            <pubDate>Mon, 27 Mar 2023 15:44:48 GMT</pubDate>
            <description><![CDATA[习惯是如此之轻，以至于无法察觉。又是如此之重，以至于无法挣脱。 ——沃伦·巴菲特

![image](https://user-images.githubusercontent.com/23721611/227992877-1ca19b1c-867e-4a00-8109-89f2c238dfed.png)


Hello， 大家好。这里是妙才的周刊第`31`期，本周要分享其他的内容如下：]]></description>
            <content:encoded><![CDATA[<p>习惯是如此之轻，以至于无法察觉。又是如此之重，以至于无法挣脱。 ——沃伦·巴菲特</p>
<p><img src="https://user-images.githubusercontent.com/23721611/227992877-1ca19b1c-867e-4a00-8109-89f2c238dfed.png" alt="image"></p>
<p>Hello， 大家好。这里是妙才的周刊第<code>31</code>期，本周要分享其他的内容如下：</p>
<h3>哈佛大学Python课程</h3>
<p><img src="https://user-images.githubusercontent.com/23721611/227992904-3903e777-5c72-400a-a2c8-1799a06bab52.png" alt="image"></p>
<p><a href="https://cs50.harvard.edu/python/2022/weeks/0/">Week 0 Functions - CS50&#39;s Introduction to Programming with Python</a>：考不上哈佛没关系，这里有一份哈佛著名的 CS 50 计算机科学入门课程之一：Python 编程介绍。既可以练听力又能学 Python ！一举两得，希望你喜欢！</p>
<blockquote>
<p>CS50是哈佛大学的一门计算机科学入门课程，旨在教授学生计算机科学的基本概念和编程技能。该课程涵盖了计算机科学的广泛领域，包括算法、数据结构、计算机系统、网络、安全性和人工智能等方面。CS50课程由哈佛大学教授David J. Malan主讲，并且已经成为全球最受欢迎的在线计算机科学课程之一。</p>
</blockquote>
<h3>堆友 - 3D 设计在线编辑器</h3>
<p><a href="https://d.design/">堆友—3D在线编辑器，0门槛堆出无限创意，免费下载，免费使用</a>：素材挺好看的，下载需要消耗一定的<code>堆豆</code>，官方提供 120 个堆豆。</p>
<img width="497" alt="image" src="https://user-images.githubusercontent.com/23721611/227992932-45981315-1247-4f4c-ba21-b29b5f4ffa75.png">


<h3>Linux 文件系统九讲</h3>
<p><a href="https://www.youtube.com/playlist?app=desktop&list=PL3wVcVGXqdnbp8ww_ogY39Mnk8IVNE3B1">Linux 文件系统九讲 - YouTube</a>：九个 Linux 文件系统视频，质量很高。</p>
<h3>Free Tailwind Tutorials</h3>
<p><a href="https://www.protailwind.com/tutorials">Free Tailwind Tutorials from Simon Vrachliotis</a>：免费的 tailwind 入门教程，使用了很可爱的图示例子，很有趣。</p>
<h3>DrawKit - 手绘矢量图资源</h3>
<p><a href="https://www.drawkit.com/">DrawKit - Beautiful vector illustrations</a>：手绘矢量插图和图标资源，非常适合您的下一个项目。</p>
<h3>Matt Pocock&#39;s TypeScript video tutorials</h3>
<p><a href="https://www.youtube.com/playlist?app=desktop&list=PLIvujZeVDLMx040-j1W4WFs1BxuTGdI_b">(1) Advanced TypeScript - YouTube</a>： 油管上非常出名的 TypeScript 系列教学视频，既可以学英语还可以学<code>TypeScript</code>，双赢！</p>
<h3>myGPTReader</h3>
<p><a href="https://github.com/madawei2699/myGPTReader">madawei2699/myGPTReader: myGPTReader is a slack bot that can read any webpage, ebook, video(YouTube) or document and summarize it with chatGPT. It can also talk to you via voice using the content in the channel.</a></p>
<p>如果你想在<code>slack</code>上部署一个可以读取文档、电子书、YouTube 视频，甚至是语音对话的机器人，可以参考这篇文档进行部署。</p>
<h3>GOST</h3>
<p><a href="https://github.com/ginuerzh/gost">ginuerzh/gost: GO Simple Tunnel - a simple tunnel written in golang</a>： Go 实现的极简信道通信工具，可以用来部署自由网络。</p>
<h3>xLog</h3>
<p><a href="https://xlog.app/">xLog</a>：面相所有人的链上开源博客社区，时间线上的文章很有趣。能懂得在这里写东西的人在这个社会中实在是少数中的少数，推荐看看这里的文章开阔自己的视野。</p>
<h3>Bilix - 最好用的 B 站下载器</h3>
<p><a href="https://oldcat.cf/Bilix">【软件推荐】Bilix - 最好用的B站下载器 - oldcatY</a>，本文介绍了两款视频下载软件：BBdown和Bilix。BBdown的优点包括多线程下载和调用Aria2实现超高速下载，但Cookie容易被拉黑。Bilix是更加简易的超高速下载软件，优点包括使用pip包管理器安装、下载界面直观、无需Aria2c即可实现超多线程下载等。需要手动扒取Cookie，但对于需要大量扒取B站视频的用户来说，Bilix是最佳选择。本文介绍了如何配置Bilix，并提供了安装Bilix和配置下载命令的具体步骤。最后介绍了如何使用Bilix下载高清视频。</p>
<h3>土耳其订阅 ICloud+ 方案</h3>
<p><a href="https://zblogs.top/how-to-subscribe-to-turkey-icloud/">[最新教程] 国内用户订阅土耳其区 iCloud+ 攻略 - Justin写字的地方</a>：笔者看着这篇文章完成了土区账号拉入家庭共享，让自己的 Mac ICloud 具有了 2T 空间，以后可以自由地使用苹果生态的存储了！</p>
<h3>Chatbot - ui</h3>
<p><a href="https://github.com/mckaywrigley/chatbot-ui">mckaywrigley/chatbot-ui: An open source ChatGPT UI.</a>：如果想让国内的朋友体验到 openAI ，其实可以部署类似 <code>chatbot-ui</code> 这样的项目，只需要在部署的时候提供一个<code>token</code>即可本地访问，也可以部署在香港<code>vps</code>上让国内的朋友访问。</p>
<p><img src="https://github.com/mckaywrigley/chatbot-ui/raw/main/public/screenshot.png" alt="Chatbot UI"></p>
<p>本项目基于<code>nextjs</code>和<code>tailwindcss</code>以及<code>TypeScript</code>技术栈，想要学习大神的源代码的朋友也可以看看。</p>
<h3>MPV 播放器</h3>
<p>windows 下我一直用<code>potplayer</code>，但毕竟是商业软件要赚钱的。如果你也在寻找一个替代品，可以看看 <code>MPV</code>，<a href="https://github.com/dyphire/mpv-config">https://github.com/dyphire/mpv-config</a> 这里有一份配置文件和整合包，足够用了。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[机智是将世事人心放在X光线下照透，幽默则不带这种超越的态度，而似乎把人都看成兄弟，大家都有短处。]]></title>
            <link>https://i5lin.top/blog/post/1633204833</link>
            <guid>1633204833</guid>
            <pubDate>Tue, 21 Mar 2023 04:30:04 GMT</pubDate>
            <description><![CDATA[老舍的《谈幽默》：机智是将世事人心放在X光线下照透，幽默则不带这种超越的态度，而似乎把人都看成兄弟，大家都有短处。

![image](https://user-images.githubusercontent.com/23721611/226517380-9cc09693-2d19-445f-9d79-3e56466e6200.png)



嘿嘿！大家好，新的一周又开始了，下面是上]]></description>
            <content:encoded><![CDATA[<p>老舍的《谈幽默》：机智是将世事人心放在X光线下照透，幽默则不带这种超越的态度，而似乎把人都看成兄弟，大家都有短处。</p>
<p><img src="https://user-images.githubusercontent.com/23721611/226517380-9cc09693-2d19-445f-9d79-3e56466e6200.png" alt="image"></p>
<p>嘿嘿！大家好，新的一周又开始了，下面是上周的周刊内容分享：</p>
<h3>人工智能代码建议</h3>
<p><a href="https://codeium.com/">Codeium</a>：免费的人工智能代码建议插件，支持的平台很多：</p>
<p><img src="https://user-images.githubusercontent.com/23721611/226517404-5dc34fc4-3a31-42dd-a8ae-79f943be15cd.png" alt="image"></p>
<p>如果你喜欢 github 的 <code>copilot</code>却像找一个免费的人工智能代码工具，非常推荐试试这个工具！</p>
<h3>VS Code 和 chatGPT 4</h3>
<p><a href="https://github.com/mpociot/chatgpt-vscode">mpociot/chatgpt-vscode: A VSCode extension that allows you to use ChatGPT</a>：免费的<code>vscode</code>插件，不需要<code>OpenAI</code>密钥就能使用现在最火热的人工智能模型来辅助编程！</p>
<p>你可以询问问题，甚至是基于代码进行提问、review 建议、优化等。目前<code>chatGPT3.5</code>无限制，<code>chatGPT4</code>限制了访问的数量和速率，但是基本不影响使用。</p>
<p><img src="https://user-images.githubusercontent.com/23721611/226517427-97e5cd47-a043-46cf-8b61-99c4f8239a85.png" alt="image"></p>
<h3>AI CLI</h3>
<p><img src="https://user-images.githubusercontent.com/23721611/226517436-da6a3a62-7395-4709-b5b7-8d63261f8e3c.png" alt="image"></p>
<p><a href="https://github.com/abhagsain/ai-cli">abhagsain/ai-cli: Get answers for CLI commands from GPT3 right from your terminal</a>：基于<code>GPT3</code>的 CLI 工具，使用<code>nodejs</code>构建。具有<code>nodejs</code>环境的用户可以用<code>npm i -g @abhagsain/ai-cli</code>进行安装，然后直接询问即可，支持中文：</p>
<pre><code class="language-bash">$ ai ask &quot;Check process running on port&quot;
</code></pre>
<h3>扩展管理器</h3>
<p><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco">扩展管理器（Extension Manager）</a>：chrome 浏览器的扩展管理器，可以很方便的管理插件，UI 还挺美观的。</p>
<h3>chathub</h3>
<p><a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma">chathub</a>：chrome 浏览器插件：bing 和 chatgpt 二合一的客户端，前者需要登录必应，后者需要提供 Key 即可使用。</p>
<h3>Bing Unchained - use new bing in chrome</h3>
<p><a href="https://chrome.google.com/webstore/detail/bing-unchained-use-new-bi/laldfnbbeocphnilnofhedhcjcnchbld">Bing Unchained</a>：可以让你在 chrome 中使用 new bing!如果你拥有了<code>new bing</code>的权限，并且想在<code>chrome</code>上使用<code>new bing</code>，这个插件真是太赞了~</p>
<h3>LASTPASS - 密码管理解决方案</h3>
<p><a href="https://www.lastpass.com/">#1 Password Manager &amp; Vault App with Single-Sign On &amp; MFA Solutions | LastPass</a>：chrome 用户不容错过的免费密码管理插件，个人版已经足够用了，可以非常方便地管理密码。</p>
<h3>最后</h3>
<p>上周鸽了，想起朋友说要坚持，惭愧惭愧~下周再见，期待四月（ ！</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue3 - 101 挑战]]></title>
            <link>https://i5lin.top/blog/post/1615400960</link>
            <guid>1615400960</guid>
            <pubDate>Wed, 08 Mar 2023 14:48:12 GMT</pubDate>
            <description><![CDATA[这几天晚上，我打算花点时间直接通关 Vuejs 挑战。]]></description>
            <content:encoded><![CDATA[<p><img src="https://user-images.githubusercontent.com/23721611/223744407-a1ee28c4-e490-470c-93b1-5b7549113d23.png" alt="image"></p>
<p>感谢<a href="https://cn-vuejs-challenges.netlify.app/questions/10-lifecycle/README.zh-CN.html">Vue.js挑战 | Vue.js挑战</a>系列文章，本文是笔者自己进行<code>vue</code>挑战的知识总结。推荐在阅读时配合<a href="https://vuejs.org/guide/introduction.html">Introduction | Vue.js</a>“食用”！</p>
<blockquote>
<p>PS：本文全文使用<code>typescript</code>和<code>vue3 options api with setup syntax suger</code>!</p>
</blockquote>
<h2>内置 API 挑战</h2>
<h3>DOM 传送门</h3>
<p>vue 提供了<code>Teleport</code>组件来将组件内的一部分模板渲染到指定的<code>DOM</code>节点下面（即渲染到此组件之外）。</p>
<p>这个组件最常见的需求就是模态框，动态的模态框从整个应用的视角下来看，应该是某种场景下被触发而产生的，并且为了让 CSS 层级更为清晰或易于控制其样式免受父元素影响，最佳实践应该是将之渲染到 body 或某些特殊节点下会更好。</p>
<p>看示例：</p>
<pre><code class="language-vue">&lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;

&lt;Teleport to=&quot;body&quot;&gt;
  &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt;
    &lt;p&gt;Hello from the modal!&lt;/p&gt;
    &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/Teleport&gt;
</code></pre>
<p>通常，给<code>to</code>一个元素选择器即可，并且还支持<code>disabled</code>属性来控制某些场景下的特殊需求，例如在移动端将之视为普通的内部组件来使用，如此一来可以减少一些额外的逻辑判断代码。</p>
<p>最后，推荐为<code>teleport</code>设置一个固定的目标元素而不是使用<code>body</code>，因为在很多场景下动态地追加元素到<code>body</code>下可能会产生一些意想不到的变动，例如 SSR 服务端渲染的情况下，通常 body 就会包含一些服务端渲染的代码，从而让<code>teleport</code>难以确定激活的正确位置。</p>
<h3>性能优化的指令</h3>
<p>如果你有一个仅渲染一次的组件或元素，则可以为之添加<code>v-once</code>指令，从而让 vue 在更具数据更新重新渲染的时候跳过这些元素。</p>
<p>说人话就是，如果你需要在某个地方渲染一个响应式数据，却不希望其数据变更后重新渲染这个地方，则可以添加<code>v-once</code>指令。举例：在某个位置同时渲染初始值和动态初始值。</p>
<p>此外，在<code>vue3.2</code>还新增了一个<code>v-memo</code>指令：</p>
<pre><code class="language-vue">&lt;div v-memo=&quot;[valueA, valueB]&quot;&gt;
  ...
&lt;/div&gt;
</code></pre>
<p>在组件渲染时当且仅当<code>valueA</code>或<code>valueB</code>都不变时，其内部的渲染将被跳过。这个场景其实比较少，如果你有超过<code>1000</code>的<code>v-for</code>循环，则可以使用这个机制进行渲染优化，否则这个渲染就没多大必要了，毕竟缓存条件对比也需要消耗资源。</p>
<h2>CSS 属性</h2>
<h3>动态 CSS</h3>
<p>如果你想使用一个响应式的变量去控制某个 DOM 的 CSS 属性，通常有两种简单的方式：</p>
<ol>
<li>给节点添加<code>style</code>，其值使用变量来替换</li>
<li>在 style 模板选择器中使用<code>v-bind(variable)</code>来设置属性</li>
</ol>
<p>代码示例：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { ref } from &#39;vue&#39;;
const theme = ref(&#39;red&#39;);
const px = ref(40);

const colors = [&#39;blue&#39;, &#39;yellow&#39;, &#39;red&#39;, &#39;green&#39;];

setInterval(() =&gt; {
  theme.value = colors[Math.floor(Math.random() * 4)];
}, 1000);
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;hello&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
p {
  color: v-bind(theme);
  font-size: v-bind(&#39;&quot;100px&quot;&#39;);
  width: v-bind(`${px}px`);
}
&lt;/style&gt;
</code></pre>
<p><code>v-bind</code>函数内是一个表达式（需要用单引号包起来），<code>theme</code>还能自动解构，如果你需要设置一些单位则可以使用引号。</p>
<h3>常规 CSS</h3>
<p>在<code>vue</code>组件中，局部样式和全局样式示例如下：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;p&gt;Hello Vue.js&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
p {
  font-size: 20px;
  color: red;
  text-align: center;
  line-height: 50px;
}

:deep(body) {
  width: 100vw;
  height: 100vh;
  background-color: burlywood;
}

:global(body) {
  width: 100vw;
  height: 100vh;
  background-color: burlywood;
}
  
:slotted(div) {
  color: blue;
}
&lt;/style&gt;
</code></pre>
<p><code>vue</code>文件最终将编译成<code>js</code>和<code>css</code>，在上面的例子中<code>style</code>加上了<code>scoped</code>标志会让<code>vue-loader</code>在编译的时候给<code>html</code>标签添加随机的<code>data-v-</code>自定义属性来配合<code>选择器</code>进行组件之间的样式隔离。</p>
<p>此外，还可以使用<code>:global</code>伪类来实现全局样式设置，使用<code>:deep()</code>伪类来影响更深处的子组件样式。由于默认样式不会影响插槽内的内容，因此可以使用<code>:slotted()</code>插槽选择器来设置传入插槽的样式。</p>
<blockquote>
<p>标签结合 scoped 限制作用域时的效率相对类名或 id 来说会慢许多倍（来自官方文档的解释），此外组件还需要小心引用递归现象。 </p>
</blockquote>
<p>此外，使用<code>v-html</code>动态生成的内容不受<code>scoped</code>影响，此时可以使用<code>:deep()</code>选择器来设置样式，亦或使用单独的样式表。</p>
<h3>CSS Module</h3>
<p>使用<code>scoped</code>属性会在<code>html</code>的标签中生成用于样式隔离的<code>data-v-</code>自定义属性，如果真的不想要这些自定义属性，则可以考虑<code>CSS Module</code>方案，这里就不深入讨论了。</p>
<h2>组件</h2>
<h3>Prop 验证</h3>
<p>组件需要显式申明其接受的<code>prop</code>，如此一来便可以于透传的属性进行区分。</p>
<p>prop 需要注意的是推荐和社区保持一致，使用<code>kebad-case</code>语法，如此一来可以和 html 属性的书写形式保持一致。</p>
<p><code>prop</code>可以传递不同类型的值，当传递的<code>prop</code>是<code>true</code>时，推荐直接写此属性即可，可以让代码稍微简洁一些。</p>
<p>可以使用一个变量绑定多个<code>prop</code>:</p>
<pre><code class="language-vue">export default {
  data() {
    return {
      post: {
        id: 1,
        title: &#39;My Journey with Vue&#39;
      }
    }
  }
}

// 传递
&lt;BlogPost v-bind=&quot;post&quot; /&gt;
// 等同于
&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;
</code></pre>
<p>单项数据流是<code>vue</code>组件使用的最佳实践，不要去改动对象或数组类型的<code>prop</code>，即使你可以做到。</p>
<p>通常，我们可以写<code>prop</code>类型检验来提高开发效率，如果你使用 JavaScript 开发 vue 程序，可以参考文档来编写类型检查：<a href="https://cn.vuejs.org/guide/components/props.html#one-way-data-flow">Props | Vue.js</a>！</p>
<p>而如果你像我一样使用<code>TypeScript</code>构建应用，则可以参考如下示例：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
  import { type PropType } from &#39;vue&#39;
  withDefaults(defineProps&lt;{
    title?: string
    likes: number,
    labels?: string[]
  }&gt;(), {
    // here we have default values
    title: &#39;---&#39;,
    labels: () =&gt; [&#39;one&#39;, &#39;two&#39;]
  })
&lt;/script&gt;
</code></pre>
<p>对于原始数据类型可以直接使用<code>withDefaults</code>函数的第二个参数传递值，而对象则在传值时使用返回其正确类型的函数。</p>
<h3>函数式组件</h3>
<p>有时候你可能会需要一个函数式的组件：</p>
<pre><code class="language-vue">import { h } from &quot;vue&quot;;

const DynamicHeading = (props, context) =&gt; {
  return h(`h${props.level}`, context.attrs, context.slots);
};
</code></pre>
<p>其用法如下：</p>
<pre><code class="language-vue">&lt;dynamic-heading :level=&quot;1&quot;&gt;Hello&lt;/dynamic-heading&gt;
&lt;dynamic-heading :level=&quot;2&quot;&gt;World&lt;/dynamic-heading&gt;
</code></pre>
<p>函数式组件的传入参数：<code>props</code>和<code>context</code>，其中<code>context</code>包括：<code>attrs/slots/emit</code>属性。其实现最终是返回一个 <code>h()</code>函数创建的<code>vnode</code>!</p>
<p>上述代码是一个动态标题的函数式组件，根据传入的<code>props.level</code>来决定渲染的是<code>h1</code>还是<code>h2</code>等，函数式组件在某些场景比传统组件更易用，甚至更易于组织代码。传统组件一个组件即一个文件，而函数式组件可以将多个功能性的组件放在同一个文件。</p>
<h3>树组件</h3>
<p>树组件的需求即得知其数据格式是树，对于树这种结构我们通常可以考虑递归的方法去遍历数据。</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
interface TreeData {
  key: string;
  title: string;
  children: TreeData[];
}
defineProps&lt;{ data: TreeData[] }&gt;();
&lt;/script&gt;

&lt;template&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;{ key, title, children } in data&quot; :key=&quot;key&quot;&gt;
      &lt;span&gt;{{ title }}&lt;/span&gt;
      &lt;TreeComponent v-if=&quot;children&quot; :data=&quot;children&quot;&gt;&lt;/TreeComponent&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;
</code></pre>
<p>上述代码文件为：<code>TreeComponent.vue</code>，在模板内部可以使用自身来实现递归。</p>
<h2>可组合函数</h2>
<p>vue composable function 指的是用 vue 的 composition API 来封装和复用具有<code>逻辑状态</code>的函数。</p>
<p>举个切换器的例子：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from &#39;vue&#39;;
/**
 * Implement a composable function that toggles the state
 * Make the function work correctly
 */
function useToggle(init: boolean) {
  const state = ref(init);
  const toggle = () =&gt; (state.value = !state.value);
  return [state, toggle];
}

const [state, toggle] = useToggle(false);
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;State: {{ state ? &#39;ON&#39; : &#39;OFF&#39; }}&lt;/p&gt;
  &lt;p @click=&quot;toggle&quot;&gt;Toggle state&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<p>编写一个<code>useToggle</code>函数来快速创建可复用的<code>state</code>和翻转其状态的函数，这个功能可以方便地在很多地方复用。并且因为这是一个纯函数，我们可以方便地扩展和测试。</p>
<p>再举个计数器的例子：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from &#39;vue&#39;;
interface UseCounterOptions {
  min?: number;
  max?: number;
}

/**
 * Implement the composable function
 * Make sure the function works correctly
 */
function useCounter(initialValue = 0, options: UseCounterOptions = {}) {
  const count = ref(initialValue);

  const inc = () =&gt; {
    if (count.value === options?.max) {
      return;
    }
    count.value += 1;
  };
  const dec = () =&gt; {
    if (count.value === options?.min) {
      return;
    }
    count.value -= 1;
  };
  const reset = () =&gt; (count.value = initialValue);
  return { count, inc, dec, reset };
}

const { count, inc, dec, reset } = useCounter(0, { min: 0, max: 10 });
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;Count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;inc&quot;&gt;inc&lt;/button&gt;
  &lt;button @click=&quot;dec&quot;&gt;dec&lt;/button&gt;
  &lt;button @click=&quot;reset&quot;&gt;reset&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<h2>组合式 API - Composition API</h2>
<h3>生命周期钩子</h3>
<p>这一题的问题在于收起子组件之后，全局的定时器任务没有被清除，因此再次挂载渲染子组件之后会再次执行一个新的定时任务，二者会影响到<code>count</code>值。</p>
<p>因此，问题的关键在于：我们需要在卸载子组件的时候清除定时器任务。</p>
<p>关于组件的生命周期，可以看看这个图示：</p>
<p><img src="https://vuejs.org/assets/lifecycle.16e4c08e.png" alt=""></p>
<blockquote>
<p>查看文档：<a href="https://vuejs.org/api/composition-api-lifecycle.html">Composition API: Lifecycle Hooks | Vue.js</a></p>
</blockquote>
<p>因此，我们可以使用<code>onUnmounted</code>生命周期函数，传入一个回调函数，在这个函数中清理掉定时任务即可！</p>
<h3>Ref - 你应该知道的知识</h3>
<p><code>ref</code>是响应式 API 最常见的知识之一，接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 <code>.value</code>。它可以在我们组件挂载之后获取一个特定<code>DOM</code>元素或子组件实例的直接引用。<code>ref</code>也是一个可以修改的响应式对象，并且可以追踪和触发相关的副作用。</p>
<p>在<code>TypeScript</code>中，要为<code>ref</code>标注类型可以从<code>vue</code>导出类型<code>Ref</code>!</p>
<p>在处理<code>ref</code>的时候，可以多回顾以下的几个工具函数。这些函数能帮助你更好地处理<code>ref</code></p>
<blockquote>
<p>请注意：ref 将会对传入的数据进行深度响应式，修改其对象或数组中的所有属性都会触发更新。</p>
</blockquote>
<ul>
<li><code>isRef</code>：检查某个值是否为<code>Ref</code>类型的值</li>
<li><code>unref</code>：如果传入的参数是<code>Ref</code>类型，则返回其内部值，否则返回参数本身。如果某些场景下你得到的值可能是<code>Ref</code>，那么可以直接使用<code>unref</code>去取值而不必写判断逻辑。</li>
<li><code>toRef</code>：基于传入的<code>响应式对象</code>的一个属性去创建一个<code>Ref</code>响应式对象，这个对象将会追踪传入的对象的值的变化来同步返回值。</li>
<li><code>toRefs</code>：将传入的响应式对象转换为一个普通对象，这个对象的每个属性都指向源对象对应属性的<code>ref</code>（每个<code>ref</code>都使用<code>toRef</code>创建），如此一来在某些场合下解构将不会丢失响应性。</li>
</ul>
<p>这里为<code>toRefs</code>写一个示例用于解决<code>vue</code>挑战的响应性丢失的问题：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { reactive, toRefs } from &#39;vue&#39;;

function useCount() {
  const state = reactive({
    count: 0,
  });

  function update(value: number) {
    state.count = value;
  }

  return {
    state: toRefs(state),
    update,
  };
}

// Ensure the destructured properties don&#39;t lose their reactivity
const {
  state: { count },
  update,
} = useCount();
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      &lt;span @click=&quot;update(count - 1)&quot;&gt;-&lt;/span&gt;
      {{ count }}
      &lt;span @click=&quot;update(count + 1)&quot;&gt;+&lt;/span&gt;
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>如此一来<code>useCount</code>返回值解构之后，<code>count</code>依然是一个<code>ref</code>响应式对象，源属性改变时<code>count</code>将会更新。</p>
<h3>Shallow Ref</h3>
<p><code>Shallow Ref</code>是<code>ref</code>的浅层作用形式，只有修改<code>.value</code>的时候会触发更新机制，因此在创建大型数据结构的时候我们可以考虑使用浅层优化。</p>
<p>但是如果你真希望对浅层<code>ref</code>的属性进行修改后触发更新，也可以显式地调用<code>triggerRef</code>函数，传入此浅层<code>ref</code>即可。</p>
<h3>Custom Ref</h3>
<p><code>customRef()</code>函数可以创建一个自定义的<code>ref</code>，并且显式声明对其依赖追踪和更新触发的控制方式。先看看其类型签名：</p>
<pre><code class="language-typescript">function customRef&lt;T&gt;(factory: CustomRefFactory&lt;T&gt;): Ref&lt;T&gt;

type CustomRefFactory&lt;T&gt; = (
  track: () =&gt; void,
  trigger: () =&gt; void
) =&gt; {
  get: () =&gt; T
  set: (value: T) =&gt; void
}
</code></pre>
<p>如果你需要创建一个响应式对象，并且对其进行更细粒度的控制（在读写的时候添加逻辑），那么使用<code>customRef</code>是个很好的方式，尤其是在创建<code>composable function</code>的时候。</p>
<p>这里我举两个代码示例：</p>
<p>示例 1：基于<code>sessionStorage</code>的请求缓存<code>Ref</code>：</p>
<pre><code class="language-javascript">import { customRef } from &#39;vue&#39;

function useCache(key, fn) {
  return customRef((track, trigger) =&gt; {
    let cache = sessionStorage.getItem(key)
    if (cache) {
      cache = JSON.parse(cache)
    } else {
      fn().then(data =&gt; {
        cache = data
        sessionStorage.setItem(key, JSON.stringify(cache))
        trigger()
      })
    }
    track()
    return {
      get() {
        track()
        return cache
      },
      set(value) {
        cache = value
        sessionStorage.setItem(key, JSON.stringify(cache))
        trigger()
      }
    }
  })
}

// 使用示例
const dataRef = useCache(&#39;data&#39;, () =&gt; {
  return fetch(&#39;https://api.example.com/data&#39;).then(res =&gt; res.json())
})

// 访问（读取）dataRef 时，如果缓存中有数据，则直接返回缓存的数据，否则进行异步请求，并将结果保存到缓存中
console.log(dataRef.value)
</code></pre>
<p>其中关键的代码是<code>track()</code>和<code>trigger()</code>，二者功能如下：</p>
<ul>
<li>track：调用后立即记录当前函数正在访问数据</li>
<li>trigger：调用后立即更新依赖此数据的组件函数</li>
</ul>
<p>通常，我们应该在<code>get()</code>方法中调用<code>track()</code>函数，在<code>set()</code>方法中调用<code>trigger()</code>函数。</p>
<p>示例 2：封装自定义表单控件</p>
<pre><code class="language-javascript">import { customRef } from &#39;vue&#39;

function useCustomInput(initialValue, validator) {
  return customRef((track, trigger) =&gt; {
    let value = initialValue
    let error = &#39;&#39;
    track()
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        if (validator(newValue)) {
          value = newValue
          error = &#39;&#39;
        } else {
          error = &#39;Invalid input&#39;
        }
        trigger()
      },
      error: () =&gt; error
    }
  })
}

// 使用示例
const nameRef = useCustomInput(&#39;&#39;, value =&gt; value.length &gt;= 3)
console.log(nameRef.value) // &#39;&#39;
console.log(nameRef.error()) // &#39;Invalid input&#39;
nameRef.value = &#39;John&#39;
console.log(nameRef.value) // &#39;John&#39;
console.log(nameRef.error()) // &#39;&#39;
</code></pre>
<p>最后，再来看看<code>vue</code>挑战的自定义防抖<code>ref</code>的题目：</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { watch, customRef } from &#39;vue&#39;;

/**
 * Implement the function
 */
function useDebouncedRef(value, delay = 200) {
  return customRef((track, trigger) =&gt; {
    // 声明 timer 为 null 而不是 0 可以防止可能存在的其他任务 timer 自动分配为 0 导致的任务被不可预测地取消
    let timer = null; // 不能放在 return customRef 上面，否则多个 ref 实例将会访问同一个 timer
    return {
      set(v) {
        // 检查值是否有变化可以减少渲染 trigger
        if(v === value) return
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
          value = v;
          trigger();
        }, delay);
      },
      get() {
        track();
        return value;
      },
    };
  });
}
const text = useDebouncedRef(&#39;hello&#39;);

/**
 * Make sure the callback only gets triggered once when entered multiple times in a certain timeout
 */
watch(text, (value) =&gt; {
  console.log(value);
});
&lt;/script&gt;

&lt;template&gt;
  &lt;input v-model=&quot;text&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h3>Reactive</h3>
<p>我们可以使用<code>reactive()</code>创建一个响应式代理，这个转换是深层的。举个例子：</p>
<pre><code class="language-vue">const data = reactive({
    meta: {
        text: &#39;x&#39;	
    }
})
</code></pre>
<p>修改<code>data.meta.text</code>的值将会触发更新，如果你使用<code>watch</code>函数侦听<code>data</code>，那么就会执行回调函数。</p>
<p>此外，如果<code>data</code>的某个属性是一个<code>ref</code>：</p>
<pre><code class="language-vue">const count = ref(1)
const obj = reactive({ count })

// ref 会被解包
console.log(obj.count === count.value) // true

// 会更新 `obj.count`
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2

// 也会更新 `count` ref
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3
</code></pre>
<p>如果我们创建的<code>reactive(obj)</code>响应式代理数据较大，那么深层转换所消耗的性能则越多，并且我们只想要保留对顶层属性的响应性，那么可以使用<code>shallowReactive()</code>来替代以优化性能。</p>
<h3>可写的计算属性</h3>
<p>如果想要控制响应式对象的读写逻辑，可以考虑使用<code>computed</code>接口：</p>
<pre><code class="language-vue">&lt;script setup lang=&quot;ts&quot;&gt;
import { ref, computed } from &#39;vue&#39;;

const count = ref(1);
const plusOne = computed({
  get() {
    return count.value + 1;
  },
  set(v) {
    count.value = v - 1;
  },
});

/**
 * 确保 `plusOne` 可以被写入。
 * 最终我们得到的结果应该是 `plusOne` 等于 3 和 `count` 等于 2。
*/

plusOne.value++;
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ count }}&lt;/p&gt;
    &lt;p&gt;{{ plusOne }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>通常我们传给<code>computed</code>函数一个函数作为参数，此函数的返回值被转化成一个<code>ref</code>对象，但是如果需要对写进行额外的逻辑控制，则可以不传函数而传一个对象，这个对象如上所示具有<code>set</code>和<code>get</code>属性，其函数签名如下：</p>
<pre><code class="language-typescript">// 只读
function computed&lt;T&gt;(
  getter: () =&gt; T,
  // 查看下方的 &quot;计算属性调试&quot; 链接
  debuggerOptions?: DebuggerOptions
): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt;

// 可写的
function computed&lt;T&gt;(
  options: {
    get: () =&gt; T
    set: (value: T) =&gt; void
  },
  debuggerOptions?: DebuggerOptions
): Ref&lt;T&gt;
</code></pre>
<p>当我们用<code>TypeScript</code>进行开发时，既可以显式地指名<code>T</code>的类型，也可以通过自动类型推断机制让<code>ref</code>自动推断出归属的类型。</p>
<h3>watch everything</h3>
<p>首先，<code>vue</code>支持让开发者监听某个或某些响应式数据源亦或是一个函数的返回值，从而在数据源变化之后调用回调函数。</p>
<p>先来看看<code>watch</code>函数的类型定义：</p>
<pre><code class="language-typescript">// 侦听单个来源
function watch&lt;T&gt;(
  source: WatchSource&lt;T&gt;,
  callback: WatchCallback&lt;T&gt;,
  options?: WatchOptions
): StopHandle

// 侦听多个来源
function watch&lt;T&gt;(
  sources: WatchSource&lt;T&gt;[],
  callback: WatchCallback&lt;T[]&gt;,
  options?: WatchOptions
): StopHandle

type WatchCallback&lt;T&gt; = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () =&gt; void) =&gt; void
) =&gt; void

type WatchSource&lt;T&gt; =
  | Ref&lt;T&gt; // ref
  | (() =&gt; T) // getter
  | T extends object
  ? T
  : never // 响应式对象

interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean // 默认：false
  flush?: &#39;pre&#39; | &#39;post&#39; | &#39;sync&#39; // 默认：&#39;pre&#39;
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}
</code></pre>
<p>可以看到<code>watch source</code>可以是以下几种类型：</p>
<ul>
<li>一个响应式对象</li>
<li>function</li>
<li>多个观察对象的数组（任意元素改变都将触发回调函数）</li>
</ul>
<p>回调函数的参数基于你的监听类型而定，举个例子如果仅仅监听单个数据源则回调函数将被传入<code>value</code>和<code>oldValue</code>，如果监听的是数组则相应的新值和旧值也是数组。</p>
<p>如果需要处理新旧的值，则可以考虑对回调函数定义添加合理的参数类型。</p>
<p><code>watch</code>除了监听对象和回调函数，还可以添加<code>options</code>来细粒度控制整个代码逻辑。</p>
<p>我们可以为<code>options</code>设置以下的键值：</p>
<ul>
<li>immediate：这是一个布尔值，顾名思义，在创建侦听器的时候立即调用回调函数，其默认值是<code>false</code>。</li>
<li>deep：这也是一个布尔值，如果数据源是一个具有深层键值对的对象或数组，那么整个侦听将会消耗更多性能去检查每一个深层的值的变化，谨慎使用此设置，越深的对象监听的开销越大。</li>
<li>flush： 控制回调函数的执行时机，默认为<code>pre</code>，这意味着在你的回调函数中如果去访问<code>DOM</code>，那么得到的值将会是<code>vue</code>更新之前（组件渲染前）的值，配合<code>pre</code>的字面意思我们也比较容易记下这一点。<ul>
<li>&#39;pre&#39; </li>
<li>&#39;post&#39; 意味着在侦听回调中访问<code>DOM</code>将得到<code>vue</code>更新之后的值</li>
<li>&#39;sync&#39; 仅当回调函数中包含<code>复杂的计算</code>、<code>DOM 更新</code>或<code>发送请求</code>等操作时可以设置此选项，从而让回调函数直接在数据源变化后同步执行。（是的，watch 底层实现通过<code>reactive</code>函数创建一个响应式对象，并且为<code>setter</code>和<code>getter</code>添加了依赖和触发回调函数的逻辑，默认情况下回调函数最终会再次封装成一个异步调度任务<code>SchedulerJob</code>对象）添加到更新队列中，也就是说默认情况下回调并不是<code>同步任务</code>）</li>
</ul>
</li>
</ul>
<p>在回调函数中，我们必须小心不能去做可能导致监听对象变化的操作，这样可能会导致回调循环。</p>
<p>最后，我们或许需要停止侦听器，每个侦听器函数都会返回一个停止侦听的函数，利用这个函数即可停止侦听。</p>
<p>除了<code>watch</code>，我们可能会在其他人代码里看到<code>watchEffect</code>！这算是<code>watch</code>的一个语法糖。</p>
<p>先来看看其类型定义：</p>
<pre><code class="language-typescript">function watchEffect(
  effect: (onCleanup: OnCleanup) =&gt; void,
  options?: WatchEffectOptions
): StopHandle

type OnCleanup = (cleanupFn: () =&gt; void) =&gt; void

interface WatchEffectOptions {
  flush?: &#39;pre&#39; | &#39;post&#39; | &#39;sync&#39; // 默认：&#39;pre&#39;
  onTrack?: (event: DebuggerEvent) =&gt; void
  onTrigger?: (event: DebuggerEvent) =&gt; void
}

type StopHandle = () =&gt; void
</code></pre>
<p>所谓<code>watchEffect</code>，顾名思义“侦听副作用”。其接受一个函数作为参数，并且立即运行这个函数，同时响应式地追踪其依赖，此函数内部的响应式对象即其依赖，依赖更改则会让函数立即执行。</p>
<p>所谓副作用，可以理解为函数或表达式执行时，除了返回一个值以外，还对函数外部的状态产生了影响，比如修改了全局变量，发出了网络请求，更新了<code>DOM</code>等。</p>
<p>相对了<code>watch</code>来说，<code>watchEffect</code>更加灵活，其自动追踪依赖的数据既是优点也是缺点，笔者认为<code>watch</code>通过显式地指名观察的对象能让代码逻辑更加完整，并且可读性更高，也有利于团队开发协作，自动追踪依赖则需要团队成员和开发者更细致地了解整个侦听的逻辑和数据，这有时会让人感到疲惫。</p>
<p>每个人的观点都不一样，不必强求~</p>
<blockquote>
<p><code>watchEffect</code>的<code>options</code>支持<code>onTrack</code>和<code>onTrigger</code>，这两个特性主要用于调试和优化响应式数据，仅当你真的需要做这件事时才方便用到它们。</p>
</blockquote>
<h3>依赖注入</h3>
<p>为了降低多层组件之间利用<code>props</code>传递数据的复杂度，官方提供了<code>依赖注入</code>机制。看看官方文档的这张图：</p>
<p><img src="https://cn.vuejs.org/assets/provide-inject.3e0505e4.png" alt="Provide/inject 模式"></p>
<p>只需要在上层组件利用<code>provide</code>函数提供数据，即可在后代组件里使用<code>inject</code>函数来获取数据。</p>
<p>利用这个<code>API</code>，我们可以在两个方向上提供<code>provide</code>:</p>
<ol>
<li>在应用层 Provide</li>
<li>在组件层  Provide</li>
</ol>
<p>首先看看在应用层<code>provide</code>:</p>
<pre><code class="language-tsx">import { createApp } from &#39;vue&#39;

const app = createApp({})

app.provide(/* 注入名 */ &#39;message&#39;, /* 值 */ &#39;hello!&#39;)
</code></pre>
<p>通常在写插件的时候比较常用，因为定义插件的时候使用<code>app</code>来提供数据比较方便。</p>
<p>其次，看看最为常用的在组件处<code>provide</code>:</p>
<pre><code class="language-vue">&lt;script setup&gt;
import { provide } from &#39;vue&#39;

provide(/* 注入名 */ &#39;message&#39;, /* 值 */ &#39;hello!&#39;)
&lt;/script&gt;
</code></pre>
<p>注入的名字可以是字符串或<code>symbol</code>，推荐使用一个全局文件来保存所有<code>symbol</code>，并且在<code>provide</code>和<code>inject</code>的时候导入使用。</p>
<p>注入的值可以是响应式的对象，注入内部解构也不会自动解包为内部的值，使用响应式数据的时候，如果需要在子组件中修改数据值，官方推荐提供一个修改值的方法来修改数据。</p>
<p>在<code>inject</code>的时候值可能是<code>undefined</code>，这种情况下如果使用<code>TypeScript</code>并且可以确保使用的时候一定存在数据则可以使用<code>as</code>声明值的类型，亦或是<code>inject</code>提供第二个参数作为默认值，默认值可以是一个值也可以是一个函数的返回值，甚至是一个函数。如果注入一个函数，则需要添加第三个参数来说明这是一个函数。</p>
<p>由于笔者日常使用<code>TypeScript</code>进行开发，因此在这里记录一下使用<code>TypeScript</code>标注类型的关键点。</p>
<p>首先，推荐使用一个文件来统一管理<code>provide</code>的<code>key</code>：</p>
<pre><code class="language-ts">const myKey: InjectKey&lt;string&gt; = Symbol();
provide(myKey, &#39;Yo&#39;)
const data = inject(myKey) // TypeScript 能推导出 data 的数据类型为 string
</code></pre>
<p>使用<code>InjectKey&lt;T&gt;</code>来声明此符号对应注入的数据值，后续<code>inject</code>的时候即可自动推导出类型。</p>
<p>最后，我们再来看一个示例：使用依赖注入机制创建一个<code>TypeScript</code>完备的简单状态管理<code>store</code>:</p>
<pre><code class="language-typescript">import { provide, inject, reactive } from &#39;vue&#39;

interface State {
  count: number
}

interface Actions {
  increment: () =&gt; void
  decrement: () =&gt; void
}

const createState = (): State =&gt; {
  return reactive({
    count: 0
  })
}

const createActions = (state: State): Actions =&gt; {
  const increment = () =&gt; {
    state.count++
  }

  const decrement = () =&gt; {
    state.count--
  }

  return {
    increment,
    decrement
  }
}

const stateSymbol = Symbol()
const actionsSymbol = Symbol()

export const provideStore = () =&gt; {
  const state = createState()
  const actions = createActions(state)

  provide&lt;State&gt;(stateSymbol, state)
  provide&lt;Actions&gt;(actionsSymbol, actions)
}

export const useStore = () =&gt; {
  const state = inject&lt;State&gt;(stateSymbol)
  const actions = inject&lt;Actions&gt;(actionsSymbol)

  if (!state || !actions) {
    throw new Error(&#39;Store is not provided&#39;)
  }

  return {
    state,
    actions
  }
}
</code></pre>
<p>从上面的示例中可以看到我们定义了<code>State</code>和<code>Actions</code>接口分别定义状态和操作，然后定义了<code>createState</code>和<code>createActions</code>函数来创建状态和改变状态的操作，在使用时只需要在上层组件定义处调用<code>provideStore</code>函数即可完成初始化状态和改变状态的操作的数据注入。</p>
<p>我们再定义一个<code>useStore</code>函数来辅助获取注入的数据。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ state.count }}&lt;/p&gt;
    &lt;button @click=&quot;actions.increment&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;actions.decrement&quot;&gt;-&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { defineComponent } from &#39;vue&#39;
import { useStore } from &#39;@/store&#39;
const { state, actions } = useStore()
&lt;/script&gt;
</code></pre>
<p>从这个示例衍生出去，我们可以创建良好且<code>TypeScript</code>完备的依赖注入数据管理模式。</p>
<h3>effectScope</h3>
<p><code>effectScope()</code>函数可以创建一个<code>effect作用域</code>，并且捕获其中所创建的响应式副作用（计算属性和侦听器），并且返回一个可以将副作用函数标记为<code>stopped=true</code>的<code>stop</code>函数。</p>
<p>简而言之，我们可以使用如下代码：</p>
<pre><code class="language-typescript">const scope = effectScope()

scope.run(() =&gt; {
  const doubled = computed(() =&gt; counter.value * 2)

  watch(doubled, () =&gt; console.log(doubled.value))

  watchEffect(() =&gt; console.log(&#39;Count: &#39;, doubled.value))
})

// 处理掉当前作用域内的所有 effect
scope.stop()
</code></pre>
<p>以上代码依然可以让计算属性和侦听器按预期运行，但是我们从此得到了一个可以控制副作用集体终止的控制器：<code>scope.stop()</code>函数！</p>
<p>调用此函数之后，此作用域内部的副作用函数都将被标记为<code>stopped: true</code>并且被跳过。</p>
<p>切记：<code>scope.stop()</code>仅仅是标记内部的副作用函数不必再执行，已经执行的副作用函数还是无法停止的。</p>
<h3>修饰符</h3>
<p>修饰符是为了方便开发者处理一些通用逻辑而提供的一种接口，我们可以在指令后面使用修饰符特殊后缀，即可增强或改变指令的功能。</p>
<p><code>vue3</code>修饰符有以下几种：</p>
<ul>
<li>事件修饰符</li>
<li>按键修饰符</li>
<li>鼠标按键修饰符</li>
<li>系统按键修饰符</li>
<li>表单输入绑定修饰符</li>
<li>自定义修饰符</li>
</ul>
<p>了解每一种修饰符都会对我们开发过程中遇到的指令处理有帮助！</p>
<p><strong>当我们开发的时候遇到上述相关功能的时候，推荐先思考自己是否能利用这些修饰符来优化或减少重复的逻辑代码。</strong></p>
<p>首先，我们从事件修饰符开始，事件修饰符有：</p>
<pre><code class="language-jsx">&lt;!-- 单击事件将停止传递 --&gt;
&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件将不再重新加载页面 --&gt;
&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰语可以使用链式书写 --&gt;
&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 也可以只有修饰符 --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;

&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;
&lt;!-- 例如：事件处理器不来自子元素 --&gt;
&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;

&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;
&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;
&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 点击事件最多被触发一次 --&gt;
&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;
&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;
&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;
</code></pre>
<blockquote>
<p>链式书写事件修饰符需要注意顺序，因为相关代码编译后的事件是顺序生成的，例如<code>@click.prevent.self</code>和<code>@click.self.prevent</code>的点击事件阻止范围不同。</p>
</blockquote>
<p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告。</p>
<p>其次，按键修饰符示例：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;
    &lt;input @keyup.enter=&quot;submit&quot; /&gt;

    &lt;!-- 使用中划线的形式，支持所有按键事件暴露的按键民，不用自己处理案件判断，非常方便 --&gt;
    &lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;
    &lt;input @keydown.tab=&quot;nextInput&quot; /&gt;
    &lt;input @keydown.delete=&quot;deleteCharacter&quot; /&gt;
    &lt;input @keydown.backspace=&quot;deleteCharacter&quot; /&gt;
    &lt;input @keydown.esc=&quot;cancelForm&quot; /&gt;
    &lt;input @keydown.space=&quot;toggleCheckbox&quot; /&gt;
    &lt;input @keydown.up=&quot;moveUp&quot; /&gt;
    &lt;input @keydown.down=&quot;moveDown&quot; /&gt;
    &lt;input @keydown.left=&quot;moveLeft&quot; /&gt;
    &lt;input @keydown.right=&quot;moveRight&quot; /&gt;
    &lt;!-- 支持组合键 --&gt;
    &lt;input @keydown.ctrl.enter=&quot;submitForm&quot; /&gt;
    &lt;input @keydown.alt.tab=&quot;nextInput&quot; /&gt;
    &lt;input @keydown.shift.delete=&quot;deleteCharacter&quot; /&gt;
    &lt;input @keydown.meta.esc=&quot;cancelForm&quot; /&gt;
    
    &lt;!-- 按键限制： 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;
    &lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

    &lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;
    &lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

    &lt;!-- 仅当没有按下任何系统按键时触发 --&gt;
    &lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
    
    &lt;!-- 鼠标点击事件 --&gt;
    &lt;button @click.left=&quot;handleLeftClick&quot;&gt;左键点击&lt;/button&gt;
    &lt;button @click.right=&quot;handleRightClick&quot;&gt;右键点击&lt;/button&gt;
    &lt;button @click.middle=&quot;handleMiddleClick&quot;&gt;中键点击&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>接着，看看表单输入绑定修饰符：</p>
<pre><code class="language-vue">&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;
&lt;input v-model.lazy=&quot;msg&quot; /&gt;
&lt;!-- 自动用parseFloat转为数字，失败则返回原始值 --&gt;
&lt;input v-model.number=&quot;age&quot; /&gt;
&lt;!-- 去除值左右两边空格 --&gt;
&lt;input v-model.trim=&quot;msg&quot; /&gt;
</code></pre>
<h3>directives - 指令</h3>
<p>指令本质上是一个对象，注册到<code>app</code>实例后在实例上全局可用，注册到组件内时，则组件实例可用。</p>
<p>官方文档如是说：</p>
<pre><code class="language-javascript">const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode, prevVnode) {}
}
</code></pre>
<p>自定义的指令是一个对象，其内部规定以上 <code>key</code>表示的是指令调用的时间段，每个都是可选的周期函数。</p>
<p>来举例说学习一些用法，首先一个例子：自动将<code>v-model</code>绑定的输入字符串首字母转为大写。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model.capitalize=&quot;message&quot; /&gt;
    &lt;p&gt;Message: {{ message }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import { defineComponent } from &#39;vue&#39;;

// 定义capitalize修饰符
const capitalize = (value: string): string =&gt; {
  if (!value) return &#39;&#39;;
  return value.charAt(0).toUpperCase() + value.slice(1);
};

export default defineComponent({
  name: &#39;MyComponent&#39;,
  data() {
    return {
      message: &#39;&#39;,
    };
  },
  directives: {
    capitalize: {
      beforeUpdate(el, binding) {
        // 将输入值转为大写字母
        const capitalizedValue = capitalize(binding.value);
        // 更新输入框的值
        el.value = capitalizedValue;
        // 更新绑定的值
        binding.value = capitalizedValue;
      },
    },
  },
});
&lt;/script&gt;
</code></pre>
<p>如上所述，利用<code>beforeUpdate</code>函数即可在更新之前操作<code>DOM</code>的值和绑定的值。</p>
<p>再来一个示例：在元素上添加点击外部区域的事件!</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button v-click-outside=&quot;handleClickOutside&quot;&gt;Click Me&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 自定义指令：点击元素外部区域触发事件
const clickOutside = {
  // 指令绑定到元素时调用
  mounted(el, binding) {
    // 点击元素外部区域触发事件
    const handleClickOutside = (event) =&gt; {
      if (!el.contains(event.target)) {
        binding.value();
      }
    };
    document.addEventListener(&#39;click&#39;, handleClickOutside);
    // 在元素销毁时移除事件监听
    el._clickOutsideHandler = handleClickOutside;
  },
  // 指令从元素上解绑时调用
  unmounted(el) {
    document.removeEventListener(&#39;click&#39;, el._clickOutsideHandler);
    delete el._clickOutsideHandler;
  },
};

export default {
  name: &#39;MyComponent&#39;,
  directives: {
    clickOutside,
  },
  methods: {
    handleClickOutside() {
      console.log(&#39;Clicked Outside&#39;);
    },
  },
};
&lt;/script&gt;
</code></pre>
<blockquote>
<p><code>el.contains</code> 是一个DOM API中的方法，用于检查一个元素是否包含另一个元素，返回一个布尔值。</p>
</blockquote>
<p>上述监听函数会检查点击的对象是否是绑定对象的子元素，不是则视为点击了外部区域。</p>
<p>再来一个图片懒加载的全局自定义指令例子：</p>
<pre><code class="language-javascript">const lazyloadDirective = {
  created(el) {
    el.classList.add(&#39;img-loading&#39;)
  },
  mounted(el) {
    const img = new Image();
    img.src = el.dataset.src;
    img.onload = function () {
      el.src = el.dataset.src;
      el.classList.remove(&#39;img-loading&#39;);
    };
  },
};

const app = Vue.createApp({
  // ...
});

app.directive(&#39;lazyload&#39;, lazyloadDirective);
</code></pre>
<p>在图片DOM 创建的时候添加一个<code>class</code>:<code>img-loading</code></p>
<pre><code class="language-css">.img-loading {
  position: relative;
}

.img-loading::before {
  content: &quot;&quot;;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #f5f5f5; /* 占位符背景色 */
  border-radius: 4px; /* 占位符圆角 */
}
</code></pre>
<p>如此一来，在浏览器请求图片数据完成之前都会展示一个简单的骨架样式。</p>
<h3>nextTick()</h3>
<p><code>nextTick(callback)</code>是一个全局方法，其可以解决<code>vue</code>中改变响应式状态时<code>DOM</code>不会立即同步更新的问题，调用这个异步函数即可等待<code>DOM</code>更新，你可以传入回调函数，也可以使用<code>await</code>语法糖来等待<code>DOM</code>更新再添加更多逻辑。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[不要让你的热情被磨灭，去创作一些什么亦或是去爱上些什么。]]></title>
            <link>https://i5lin.top/blog/post/1607269473</link>
            <guid>1607269473</guid>
            <pubDate>Thu, 02 Mar 2023 18:11:08 GMT</pubDate>
            <description><![CDATA[不要让你的热情被磨灭。

![image](https://user-images.githubusercontent.com/23721611/222515046-00964eae-4cc9-468b-ac2a-a0741f89fedf.png)


我本想在本周一发布本周的分享内容，但是周一开始就被耽搁了，直到今天23:58:30才开始动笔，糟糕的经历。

好了，本周的周刊分享如]]></description>
            <content:encoded><![CDATA[<p>不要让你的热情被磨灭。</p>
<p><img src="https://user-images.githubusercontent.com/23721611/222515046-00964eae-4cc9-468b-ac2a-a0741f89fedf.png" alt="image"></p>
<p>我本想在本周一发布本周的分享内容，但是周一开始就被耽搁了，直到今天23:58:30才开始动笔，糟糕的经历。</p>
<p>好了，本周的周刊分享如下：</p>
<h4>PopClip for Mac</h4>
<p><a href="https://pilotmoon.com/popclip/">PopClip for Mac</a> 是一个 MacOS 应用程序，当你使用在系统上选中某些文本之后，为系统增加一个增强性的功能。举个例子，当我们选中一段文字之后，<code>popClip</code>将会调用其功能来展示一些功能选项在选择的文本上方（你可以调整这个位置），这样一来就可以实现很多自定义的功能，举个我用到的例子：选择文本，弹出复制、粘贴、搜索、询问 chatGpt 疑问等一系列功能？你想要的是什么功能呢？或许可以在<code>PopClip</code>的插件列表这里找到你需要的插件，亦或者自己编写插件。</p>
<h4>Typewind</h4>
<p><a href="https://typewind.dev/">Typewind – Typesafe Tailwind</a> 是一个为<code>tailwindcss</code>提供基于<code>TypeScript</code>类型安全功能的辅助库。</p>
<img width="961" alt="image" src="https://user-images.githubusercontent.com/23721611/222515099-64eb6f85-04ab-484a-8a01-42ac04bc17a0.png">

<p>良好的代码补全功能，将<code>tailwindcss</code>以另一种方式在构建时生成完整的<code>css</code>文件。以我个人的视角来看，这种链式书写的方式很棒。</p>
<p>另外，这个库是框架无关的，我们可以将之轻松融合到现有的技术栈里，也就是说我可以同时在<code>Vue</code>和<code>React</code>中无缝切换地使用。</p>
<h4>Planetscale</h4>
<p><a href="https://planetscale.com/">PlanetScale: The world’s most advanced database platform</a> ： 就像是<code>Planetscale</code>自己描述的那样，这是一个非常优秀的<code>serverless</code>数据平台，用户在不付费的情况下可以创建一个组织，平台提供5GB的存储空间，每个月10亿行读取和1000万行写入，还支持一个开发分支和一个生产分支，并且平台还有一个不错的社区，作为一个想要为自己的创作试用<code>serverless</code>服务的开发者，免费额度已经足够了。</p>
<h4>WallHaven</h4>
<p><a href="https://wallhaven.cc/">Awesome Wallpapers - wallhaven.cc</a> 是一个壁纸分享站点，用户可以免费下载超高清的壁纸，内容非常丰富，搜索做得非常灵活，非常适合喜欢壁纸的朋友。</p>
<blockquote>
<p>开发者也能通过其开放接口访问，速度上感觉比<code>unsplash</code>更好一些。</p>
</blockquote>
<p>举个例子：</p>
<p><img src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt=""></p>
<h4>Clack</h4>
<p>使用<a href="https://www.clack.cc/">Clack</a> 和<code>TypeScript</code>可以开发精美的<code>CLI</code>程序。</p>
<img width="599" alt="image" src="https://user-images.githubusercontent.com/23721611/222515205-a233c26f-07a7-49c5-965e-819aa320049d.png">



<h4>防御性CSS</h4>
<p><a href="https://defensivecss.dev/">Defensive CSS</a> 有助于构建面向未来的用户界面的实用 CSS 和设计技巧，学习这个站点关于CSS的一些防御性知识，可以让你的CSS更加健壮。</p>
<p>最后，给大家推荐一个油管视频主：</p>
<p><img src="https://user-images.githubusercontent.com/23721611/222515260-d21ed5fc-c23b-4521-ac77-5770627c7e83.png" alt="image"></p>
<p><a href="https://www.youtube.com/@yorke">孫沁岳</a>：漫画、人生漫漫谈。</p>
<p>❤️ 吴林</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MacOS 翻译软件 - 最终的选择]]></title>
            <link>https://i5lin.top/blog/post/1599633937</link>
            <guid>1599633937</guid>
            <pubDate>Sat, 25 Feb 2023 09:37:03 GMT</pubDate>
            <description><![CDATA[我用`macOS`苹果系统已经很久了，最开始要算到大四那会折腾了自己的宏碁笔记本装黑苹果，再到后来自己组装`ITX`小主机来装黑苹果。不过最后还是回归白苹果，在很长一段时间内我都有翻译的需求（自己英语不好），并且尝试过好几种方案，比如：词典、系统自带的翻译功能、浏览器翻译插件、浏览器自带的网页翻译功能甚至是独立的翻译软件。

![](https://images.unsplash.com/ph]]></description>
            <content:encoded><![CDATA[<p>我用<code>macOS</code>苹果系统已经很久了，最开始要算到大四那会折腾了自己的宏碁笔记本装黑苹果，再到后来自己组装<code>ITX</code>小主机来装黑苹果。不过最后还是回归白苹果，在很长一段时间内我都有翻译的需求（自己英语不好），并且尝试过好几种方案，比如：词典、系统自带的翻译功能、浏览器翻译插件、浏览器自带的网页翻译功能甚至是独立的翻译软件。</p>
<p><img src="https://images.unsplash.com/photo-1534617619381-fb71fe6471fb?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2934&q=80" alt=""></p>
<p>我看到有些朋友也有翻译的需求，因此我想或许我可以分享一下自己的翻译方案。</p>
<p>总的来说，我最喜欢的方案是：独立翻译软件“Bob”！</p>
<img src="https://bobtranslate.com/images/hero.png" style="zoom:5%;" width="64" />

<p>没错，就是上面这个应用。我猜这个应用图标应该跟作者本人的长相有一定的关系😂，开个玩笑~</p>
<p>今天，我来分享给大家我是如何使用这个翻译软件的。</p>
<h4>Bob简介</h4>
<p><a href="https://bobtranslate.com/">Bob</a>：一款<code>macOS</code>平台的翻译软件，支持<code>OCR</code>光学字符识别和强大的插件系统。其界面简洁，结构紧凑，绝对是一款经典的小而美的软件。</p>
<p>其支持的功能如下所示：</p>
<ul>
<li>划词翻译</li>
<li>截图翻译</li>
<li>输入翻译</li>
</ul>
<p>这些功能涉及的翻译基本都需要第三方API来提供支持，内置的翻译功能比较弱，其官方文档非常简明且精炼，用户只需要照着文档说明就可以轻松配置翻译功能。</p>
<h4>使用建议</h4>
<p><code>Bob</code>支持配置一系列的自定义快捷键来使用其功能，例如我会选择自己常用的<code>command+7</code>来支持选中文本后的翻译功能，亦或是<code>OCR</code>截图识别翻译，并且支持配置历史记录和窗口位置和状态。这样一来，可以非常方便的随时切换翻译窗口。</p>
<p>此外，我觉得<code>Bob</code>最好用的还是要属插件功能。社区里有非常多的翻译插件，开发者甚至可以定义自己的翻译插件来做自己想做的任何事情。</p>
<p>举个例子，在翻译的同时记录用户的未知词汇，后期进行统计和重复记忆练习等。</p>
<h4>推荐插件</h4>
<p>我安装了三个非常好用的插件，首先就是：<a href="https://github.com/tingv/bobplugin-google-translate">tingv/bobplugin-google-translate: Bob 的 Google 翻译插件，无需申请 API 秘钥</a>， 下载安装之后即可在服务设置里启用此插件，只需要配置代理域名为：<code>translate.google.com</code>即可在没有谷歌API的时候使用谷歌翻译功能。</p>
<p>其次，我想推荐另一个翻译插件：<a href="https://github.com/clubxdev/bob-plugin-deeplx">clubxdev/bob-plugin-deeplx: Bob DeepL 插件</a>!</p>
<blockquote>
<p><code>DeepL</code>是世界上最大的人工翻译数据集。 翻译效果相比国内某些翻译应用来说，部分句子翻译结果可能更容易理解😂，不会过于生硬。虽然这只是一点点的用户体验提升，但是何乐而不为呢？</p>
</blockquote>
<p>下载安装此插件之后，还需要使用配合<a href="https://hub.docker.com/r/kanikig/deepl-bk">kanikig/deepl-bk - Docker Image | Docker Hub</a>和<code>Docker</code>一起使用，操作如下：</p>
<pre><code class="language-bash">docker pull kanikig/deepl-bk
docker run --platform linux/amd64 -p 8282:80 -itd kanikig/deepl-bk
</code></pre>
<p>上述命令首先是拉去镜像服务，然后指定平台运行此镜像（我的笔记本是苹果芯片，因此需要指定平台）。</p>
<p>此时，<code>docker</code>将会运行这个镜像并且映射其端口到本地的8282端口，你甚至可以稍微测试一下：</p>
<pre><code class="language-bash">curl &#39;127.0.0.1:8282/translat&#39; -X POST -d &#39;{&quot;source_lang&quot;:&quot;EN&quot;,&quot;text&quot;:&quot;Hello World&quot;,&quot;target_lang&quot;:&quot;ZH&quot;}&#39;
</code></pre>
<p>上面的 <code>curl</code>命令正常情况下即可得到<code>DeepL</code>翻译的本地返回数据。</p>
<blockquote>
<p>如果你不想要Docker，也可以在这里下载一分<a href="https://github.com/reycn/deepl-custom-server-for-bob">reycn/deepl-custom-server-for-bob</a>Python源代码本地或在VPS上部署。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/23721611/221350099-5aa30ab2-f134-4acb-89e5-7f4a62799a2f.png" alt="image"></p>
<p>打开<code>Bob</code>设置页面选择服务下的<code>DeepL X</code>插件配置本地的接口域名即可保存。</p>
<p>最后，便是蹭一下<code>OpenAI</code>的风：</p>
<p><a href="https://github.com/yetone/bob-plugin-openai-translator">yetone/bob-plugin-openai-translator: 基于 OpenAI API (GPT-3) 的 Bob 翻译插件，让我们一起迎接不需要巴别塔的新时代！</a></p>
<p>安装此插件之后稍微有点麻烦的是从<a href="https://platform.openai.com/account/api-keys">OpenAI</a>获取一个<code>API KEY</code>来使用此功能。</p>
<p>如果你有一个<code>ChatGPT</code>账户并且能够自由的获取互联网信息，那么你可以轻松前往上面的链接去拿到一个<code>KEY</code>。</p>
<p>如果没有，其实也可以去这个世界上最大的程序员分享网站<code>Github</code>去搜索<code>OPEN_AI_KEY</code>的代码段，很多人将其开源了出来你随便找一个就行。</p>
<p>当然，<code>OPEN_AI_KEY</code>换成<code>YOUDAO_SECRET</code>之类的名字也可以拿到国内服务商的一些<code>KEY</code>。</p>
<p><code>OpenAI</code>翻译稍微慢一点，但是人工智能的加持在某些时候真的很棒，一些中英文组合的内容也可以翻译得非常好 。哎，<code>AI</code>革命真的来了。</p>
<h4>最后</h4>
<p>为了照顾<code>Windows</code>用户并且秉持坚持选择开源作品的原则，这里推荐一款实用性非常高的翻译软件：<a href="https://github.com/zu1k/translator">zu1k/translator: 简单、轻量、好用的划词翻译软件</a>!</p>
<blockquote>
<p>为什么优先选择开源作品？因为公司要赚钱，国内公司更需要赚钱，有什么事是他们做不出来的呢？</p>
</blockquote>
<p>OK 今天的分享就到这里结束了，下次见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[『妙才周刊』在这像X一样的人生中，我们必须扔掉一些东西，总是要有需要照看的东西，你还有时间。]]></title>
            <link>https://i5lin.top/blog/post/1592234147</link>
            <guid>1592234147</guid>
            <pubDate>Mon, 20 Feb 2023 17:26:08 GMT</pubDate>
            <description><![CDATA[在这像X一样的人生中，我们必须扔掉一些东西，总是要有需要照看的东西，你还有时间。

But ease donot enter into grown-up life.

-《The weatherman》

![](https://plus.unsplash.com/premium_photo-1666900049633-358025dd45ec?ixlib=rb-4.0.3&ixid=]]></description>
            <content:encoded><![CDATA[<p>在这像X一样的人生中，我们必须扔掉一些东西，总是要有需要照看的东西，你还有时间。</p>
<p>But ease donot enter into grown-up life.</p>
<p>-《The weatherman》</p>
<p><img src="https://plus.unsplash.com/premium_photo-1666900049633-358025dd45ec?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2371&q=80" alt=""></p>
<p>Hello， 大家好。这里是妙才的周刊第27期，本周要分享其他的内容如下：</p>
<h3>易书</h3>
<p><a href="https://search.yibook.org/">易书 电子书聚合搜索引擎</a>：免费+资源丰富+无广告的电子书聚合搜索站。</p>
<h3>Language Reactor</h3>
<p><a href="https://localsend.org/">LocalSend</a>：百万用户量的油管Netflix双语字幕Chrome浏览器插件，如果你想学习英语或者辅助理解英语音频内容，这个插件非常好用。</p>
<h3>Zsh-autosuggestions</h3>
<p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-users/zsh-autosuggestions: Fish-like autosuggestions for zsh</a>: 像用<code>fish shell</code>一样用<code>zsh shell</code>，这个插件提供良好的搜索建议补全功能，非常适合日常大量使用终端的朋友。</p>
<h3>Mac App Collection</h3>
<p><a href="https://renegadevi.gitlab.io/mac-app-collection/">Mac App Collection</a> 是一个无广告的<code>MacOS</code>系统精品软件分享列表，就像作者所说的一样：</p>
<blockquote>
<p>The software ecosystem for macOS over the last decade has been growing rapidly. There&#39;s a lot of new software which offers high quality, native and polished experiences, or just enhances the existing macOS experience to suit personal needs, which is often overlooked by what&#39;s being advertised.</p>
<p>Over time, with the amount of advertising, requirements, and bloatware found on store fronts, it&#39;s eventually become harder to browse for good native apps, especially those by smaller indie or hobby developers.</p>
</blockquote>
<p>在过去十年间，MacOS的软件生态发展迅速，有很多优秀的软件被巨大的广告系统、臃肿的应用所淹没，优秀的本地应用程序开发变得越来越难以传播，尤其是小型独立开发者或业余开发者来说，这个站点起源于一个“优秀的软件列表”，并且没有任何商业用途。</p>
<p>如果你是MacOS的用户，非常推荐看看这个列表下的精品应用。</p>
<h3>Teach Anything</h3>
<p><a href="https://www.teach-anything.com/">Teach Anything</a>是一个小而美的Web应用，你可以提出你的问题，然后点击获取答案，应用将会通过对接第三方数据接口获取一个回答，有兴趣可以体验体验~</p>
<h3>Charts.css</h3>
<p><a href="https://chartscss.org/">Charts.css</a>: 让人眼前一亮的纯<code>CSS</code>表格生成库，轻度使用非常方便，能提供一定的定制功能。</p>
<h3>Omnivore</h3>
<p><a href="https://omnivore.app/home">Home - Omnivore</a>是一个跨平台的内容暂存工具，我初步用来保存后续阅读的一些资料或讯息，支持安装Chrome扩展和移动端应用，总体上来说还行。</p>
<h3>Free UI Design Tips EBook</h3>
<p><a href="https://hype4academy.gumroad.com/l/designtips">UI Design Tips (FREE eBook) (ENG)</a> 这是一本英文的免费UI设计电子书，作者是一个从业二十年经验的老设计师，最近为了推广他自己的其他课程，将这本电子书分享了出来，如果你想了解一些设计的讯息和技术，扩充自己的视野，或许可以下载来看看。</p>
<h3>TO-D 杂志</h3>
<p><a href="https://2d2d.io/">TO-D 杂志</a>：<strong>《TO-D 杂志》</strong> 是一个<strong>专注于探讨全球 To-D 领域相关产品、创业公司、融资等资讯的开源独立杂志</strong>。</p>
<blockquote>
<p>To-D 即 To Developers，主要指面向开发者市场的创业活动。但 To-D 并非一个独立的领域划分，它通常和 To-C, To-B 可能存在重叠。不管最终产生付费行为的是开发者个人，还是企业，只要其主要目标使用人群为 Developers 都算 To-D 产品。大家熟知的 Jetbrains, Postman, GitLab 等都属于 To-D 产品。</p>
</blockquote>
<p>此杂志此前仅在字节内网发布，后来于2022年3月才公开发布，有兴趣的开发者或产品人员可以关注一下~</p>
<h3>TZF</h3>
<p><a href="https://github.com/ringsaturn/tzf">ringsaturn/tzf: Get timezone via longitude&amp;latitude in Go in a fast way</a>： 号称最快的Go语言时区查询工具。</p>
<h3>钛盘</h3>
<p><a href="https://tmp.link/">钛盘 - 超好用的文件中转站</a>，不限空间不限速的免费网盘问卷中转站点。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[微软收购OpenAI，给Bing搜索注入生命力]]></title>
            <link>https://i5lin.top/blog/post/1581281839</link>
            <guid>1581281839</guid>
            <pubDate>Sun, 12 Feb 2023 14:34:33 GMT</pubDate>
            <description><![CDATA[所有人都在讨论`chatgpt`，微软这波真的赢麻了。
![](https://images.unsplash.com/photo-1676299081847-824916de030a?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)]]></description>
            <content:encoded><![CDATA[<p>所有人都在讨论<code>chatgpt</code>，微软这波真的赢麻了。
<img src="https://images.unsplash.com/photo-1676299081847-824916de030a?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt=""></p>
<p>微软收购<code>OpenAI</code>，并且准备给bing搜索注入<code>chatgpt</code>的力量，想想就令人激动。</p>
<p>如果你想提前体验，可以在这里排队：<a href="https://www.microsoft.com/en-us/edge/bing?form=MA13FJ">Microsoft Edge</a>。</p>
<p>此外，谷歌在演示自己的<code>Bard</code>这款人工智能竞品时出现事实性错误，导致股价蒸发💰💰💰😂，所以说微软真的赢麻了。</p>
<p>Hello， 大家好。这里是妙才的周刊第26期，本周要分享其他的内容如下：</p>
<h3><a href="https://midjourney.com/">Midjourney</a></h3>
<p><a href="https://midjourney.com/">Midjourney</a>是一个独立的研究实验室，其人工智能程序可以根据用户提供的文本描述创建图像，目前免费可用。进入其<code>Discord</code>之后，随便选择一个频道即可输入<code>image</code>命令和你的描述，即可排队生成相关图片。我有看到别人为自己的播客生成用户推广的宣传图片，效果还不错。</p>
<p>看看这个小女孩的例子，其生成描述为：“<strong>Avatar, girl, cartoon caracters ,Face light ,no accessories ,sunset, no blur,depth of field,Small-catchlight,cinematic colors , realistic,random AI 8k--V 4 --ar 3:2</strong>”：</p>
<p><img src="https://media.discordapp.net/attachments/1008571225309728878/1074320060698607758/elk_Avatar_girl_cartoon_caracters_Face_light_no_accessories_sun_7db18df9-d8d0-4383-848c-4c3f98361dc3.png" alt=""></p>
<p>如果你是内容创作者，你可以轻而易举地获得于内容搭配的超高清图片资源。</p>
<h3>Screenstab</h3>
<p><a href="https://www.screenstab.com/editor/">Screenstab</a>可以将一张平面图片，转换为具有一定倾斜度的设计性图片。还是以为上面那张小女生的图片为例，上传后即可生成如下图片（还可以进行角度微调）：</p>
<img width="1132" alt="image" src="https://user-images.githubusercontent.com/23721611/218317291-233799ca-a4da-4bcf-8a7e-440cb8658f54.png">


<p>非常适合设计师，或者是独立开发者为自己的作品做宣传内容使用，以往自己进行处理可能需要花费很多时间和精力。</p>
<h3>ONE LIB</h3>
<p><a href="https://1lib.ink/">ONE LIB - 知识就是力量</a>：免费电子书下载，搜索于 Z-Library 数据库。</p>
<h3>LocalSend</h3>
<p><strong><a href="https://localsend.org/">LocalSend</a></strong> 是一款免费、开源、跨平台的局域网文件互传工具，无需互联网，无需外部服务器。即开即用，支持 Windows、macOS、Linux，以及 iOS、Android。</p>
<h3>He3</h3>
<p><a href="https://he3.app/zh/">He3: 开发者必备的万能工具箱</a>，没必要再在浏览器上找什么在线工具了，这个软件一把梭，随时用随时切。</p>
<p><img src="https://he3app.com/section/bg10.png" alt=""></p>
<p>此外，作者还为此创建了一个交流论坛：<a href="https://community.he3.app/">He3 App</a>，再也不怕找不到人了。</p>
<h3>Google Style Guides</h3>
<p><a href="https://google.github.io/styleguide/">Google Style Guides | styleguide</a>是谷歌开发者规范的共享文档，如果你对自己或团队的代码有规范设定参考的需求，可以参考一下这里。亦或是想学习一下世界上最好的公司的开发规范，也很值得一看。</p>
<h3>前端问问 - BigFrontEnd.dev</h3>
<p><a href="https://bigfrontend.dev/">BFE.dev - prepare for Front-End job interviews.</a>：了解这个站的所有问题和答案，会让你的前端开发水平直接上天。</p>
<h3>Icons8</h3>
<p><a href="https://icons8.com/">Free Icons, Clipart Illustrations, Photos, and Music</a>是一个<code>icon</code>图标聚合站点，其提供了大量精美的<code>icon</code>图标，尺寸设置和类型设置非常方便，很多资源是免费的，值得收藏。</p>
<h3>Peo</h3>
<p><a href="https://apps.apple.com/app/id1640745955">Poe – Fast, Helpful AI Chat on the App Store</a>：非国区可下载的人工智能对话APP，免费可用堪比<code>chatgpt</code>（仅支持iOS），暂时用不到<code>chatgpt</code>的朋友可以试试<code>Peo</code>。</p>
<h3>tremor</h3>
<p><a href="https://www.tremor.so/">Tremor – The React library to build dashboards fast</a>：基于<code>React+Tailwindcss+rechats</code>的组件库，用于快速构建后台看板系统。制作十分精美，样式非常好看，而且源代码非常简洁，不管是用还是学都非常有价值。</p>
<h3>一次性Gmail</h3>
<p><a href="https://www.emailnator.com/">Temporary Disposable Gmail | Temp Mail | Email Generator</a> 是一个提供一次性Gmail临时邮箱的站点，某些时候注册使用的临时邮箱会被限制为仅支持常规邮箱，这时候或许这个站能帮到你。</p>
<h3>最后</h3>
<p>好了，今天的分享就先到这里，大家下周见~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我要不要用弹性布局的`gap`属性？]]></title>
            <link>https://i5lin.top/blog/post/1581235988</link>
            <guid>1581235988</guid>
            <pubDate>Sun, 12 Feb 2023 12:14:27 GMT</pubDate>
            <description><![CDATA[上班时我坚决不用，下班之后全都要用！

![](https://images.unsplash.com/photo-1634838083208-ce7a36701fe4?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)

今天看到群里的LSP吐]]></description>
            <content:encoded><![CDATA[<p>上班时我坚决不用，下班之后全都要用！</p>
<p><img src="https://images.unsplash.com/photo-1634838083208-ce7a36701fe4?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<p>今天看到群里的LSP吐槽了一下<code>flex</code>的<code>gap</code>属性，他的原话是这样说的：</p>
<p>LSP： &quot;嗝屁了这么差的。&quot;</p>
<p>掏粪工：“不是还可以啊”</p>
<p>LSP：“灾难。”</p>
<p>群友的对话成功吸引到了我的注意，于是我看了看群里发的图，思考了标题这个问题：“我要不要用弹性布局的<code>gap</code>属性？”</p>
<h3>过程</h3>
<p>在讨论要不要用之前，我们先来看看什么是<code>gap</code>属性：</p>
<blockquote>
<p>The gap property in CSS is a shorthand for <code>row-gap</code> and <code>column-gap</code>, specifying the size of gutters, which is the space between rows and columns within <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">grid</a>, <a href="https://css-tricks.com/almanac/properties/f/flex/">flex</a>, and <a href="https://css-tricks.com/almanac/properties/c/columns/">multi-column</a> layouts.</p>
</blockquote>
<p>简而言之，就是弹性布局中子项主轴和交叉轴之间的空隙值。</p>
<p>举个例子<a href="https://css-tricks.com/almanac/properties/g/gap/">gap | CSS-Tricks - CSS-Tricks</a>：</p>
<pre><code class="language-css">
/* Grid layout */
.container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: 1fr 2fr 1fr;
  gap: 30px 20px;
}

/* Flex layout */
.container {
  display: flex;
  gap: 10%;
}

/* Multi-column layout */
.container {
  column-count: 5;
  gap: 20px;
}
</code></pre>
<p>解释这个属性不是我想表达的重点，你可以在网上找到无数的解释，让我们回过头来说一说到底该不该用。</p>
<p>首先，来看看兼容性：</p>
<p><img src="https://user-images.githubusercontent.com/23721611/218310394-d9494249-387d-4fb3-9fa0-aff8a570b9b6.png" alt="image"></p>
<p>先不管死掉的<code>IE</code>(如果你们的产品要兼容就当我没说)，其他浏览器的兼容性还是可以的，<code>Chrome 57</code>的发布时间是<code>2017-03-09</code>，<code>Edge 16</code>则是<code>2017-10-17</code>，其他几家也都是<code>2017</code>年跟进的，算起来也是很多年前的事情了，是吗？</p>
<p>别废话，都2023年了，还不升级六年前版本浏览器的用户不配当我们的产品的用户！</p>
<p>那我们是不是可以直接一把梭用<code>gap</code>？</p>
<p>注意看这个数据：<code>China: 53.83%</code>! 这就意味着，中国所有浏览器中，仅仅有<code>53.83%</code>使用份额的浏览器得到完全支持或部分支持。</p>
<p>看到这个数据，我立马想起自己在项目里大量使用了<code>gap</code>来创建元素之间的间隙样式，而我们的产品又面向了比较多的老用户。。。</p>
<p>于是：</p>
<p><img src="https://user-images.githubusercontent.com/23721611/218310407-5401b98c-9eab-4bc0-af1d-29eff1d09268.png" alt="image"></p>
<h3>最后</h3>
<p>当你需要考虑产品用户设备兼容性时，你最好不要用。</p>
<p>当你需要考虑所有用户设备兼容性时却<code>能接受</code>老大突然在<code>下班时间</code>让你修复某个用户因这个属性导致的页面布局异常时，你可以爱怎么用就怎么用。</p>
<p>当你在开发自己的项目，亦或是学习一些新知识时，这个属性还是非常方便的，这时候我就可以很硬气地说不升级浏览器版本的用户不配当我的用户。</p>
<p>另外，相对于<code>margin</code>属性来实现相同的效果来说，其大大减少了代码量，并且对国际化的支持也非常棒。</p>
<blockquote>
<p>题外话，如果你需要考虑国际化，你可能会因为<code>margin</code>问题导致某些国家从右到左的阅读方向导致的布局效果而加班😂。</p>
</blockquote>
<p>这个属性就水到这里，其他的下次再说。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[寻找自己的石头，去碰对手的鸡蛋]]></title>
            <link>https://i5lin.top/blog/post/1562760958</link>
            <guid>1562760958</guid>
            <pubDate>Mon, 30 Jan 2023 16:23:32 GMT</pubDate>
            <description><![CDATA[如果你想少走些弯路，就要找到自己的石头去碰对手的鸡蛋。



![](https://images.unsplash.com/photo-1493406300581-484b937cdc41?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)
]]></description>
            <content:encoded><![CDATA[<p>如果你想少走些弯路，就要找到自己的石头去碰对手的鸡蛋。</p>
<p><img src="https://images.unsplash.com/photo-1493406300581-484b937cdc41?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>CSS压缩工具</h3>
<blockquote>
<p>cssminifier 提供API，我们也可以借助其接口实现自己的CLI，亦或是集成到项目构建流程中去</p>
</blockquote>
<p><a href="https://www.toptal.com/developers/cssminifier">CSS Minifier &amp; Compressor | Toptal®</a>：一个简洁易用的在线<code>CSS</code>压缩工具。</p>
<h3>Open Graph Protocol</h3>
<p><a href="https://ogp.me/">The Open Graph protocol</a>：开放图谱协议。</p>
<blockquote>
<p>The <a href="https://ogp.me/">Open Graph protocol</a> enables any web page to become a rich object in a social graph</p>
</blockquote>
<p>利用开放图谱协议，我们为支持此协议的社交媒体上分享我们的数据，以一种美观的图形对象来展示！简而言之，如果某个社交应用支持此协议，则在分享一个链接时，链接将被渲染成良好可读性的图文内容。</p>
<p>其最早创建于<code>Facebook</code>, 现在国内大多社交媒体都支持了此协议，如果你想分享自己的应用到<del>微信</del>或微博上，则可以参考此协议的规范去设置自己的应用数据。</p>
<h3>Jotai Video Course</h3>
<p><a href="https://daishi.gumroad.com/l/learn-jotai">Learn Simplified Jotai, an atomic state management library for React</a>：大名鼎鼎的React前端状态管理库<code>Jotai</code>作者录制的关于<code>Jotai</code>的视频教程，30刀（或许公司出？😂）。</p>
<blockquote>
<p>如果你是<code>React</code>开发者，这真是个不容错过的资源。</p>
</blockquote>
<h3>JS-Cookie</h3>
<p><a href="https://github.com/js-cookie/js-cookie/tree/latest#readme">js-cookie/js-cookie at latest</a>： 让前端处理<code>cookie</code>变得简单的一款简单、轻量的JS库。优点还是很多的：</p>
<ul>
<li>全浏览器支持（标准浏览器）</li>
<li>可接收任何字符，如果有特殊字符存储或读取的特殊场景，可以让我们少很多麻烦</li>
<li>无依赖，压缩后不足800字节</li>
<li>支持<code>ES Module</code>和<code>AMD/CommonJS</code></li>
<li>文档齐全，用户数量很多，意味着你可以找到很多相关问题的解决思路甚至是答案</li>
<li>...</li>
</ul>
<h3>英语写作检查</h3>
<p><a href="https://trinka.enago.cn/sentence-checker">免费在线句子检查工具——Trinka AI</a>：英语弱鸡的福音，如果你想要写一些英文文档、邮件、简单的信息等等，可以使用这个人工智能驱动的检查工具，其免费额度足够普通用户日常使用。</p>
<p>此工具将为您提供以下功能：</p>
<ul>
<li>句子检查和更正</li>
<li>语法检查</li>
<li>上下文联想表达更正</li>
</ul>
<h3>CSS 设计示例</h3>
<p><a href="https://github.com/chenglou/chenglou.github.io">chenglou/chenglou.github.io</a>：惊人的CSS设计效果，兼容性极强，样式顺滑，非常有学习价值。</p>
<h3>Github Action 本地运行工具</h3>
<p><a href="https://github.com/nektos/act">nektos/act: Run your GitHub Actions locally 🚀</a>，如果你需要写<code>Github Action</code>，那么或许在本地进行测试能给你节省非常多时间。此仓库具有<code>3.4w</code>的star，还等什么快上车！</p>
<h3>Github Contributions 历史图示</h3>
<p><a href="https://green-wall.vercel.app/">Green Wall · GitHub contribution graph generator</a>：输入你的开发者账户，它会展示给你看你的账户的历史提交图示。</p>
<h3>Flask自建图床</h3>
<p><a href="https://green-wall.vercel.app/">Green Wall · GitHub contribution graph generator</a>：基于Flask的web自检图床，支持存储到本地、又拍云、七牛云、阿里云OSS、腾讯云COS、GitHub、Gitee(码云)等， 支持第三方扩展存储到<a href="https://aws.amazon.com/s3/">AWS S3</a>、<a href="https://sm.ms/">sm.ms</a>、<a href="https://www.superbed.cn/">superbed聚合图床</a>等。</p>
<p>无论是学习<code>Python3</code>的<code>Flask</code>项目，还是了解图床自建的思路，本项目都很有借鉴意义。其文档齐全，我们可以照着快速部署自己的图床。</p>
<h3>unocss小程序预设</h3>
<p><a href="https://github.com/MellowCo/unocss-preset-weapp">MellowCo/unocss-preset-weapp: unocss preset for wechat miniprogram，unocss小程序预设，在 taro uniapp 原生小程序 中使用unocss</a></p>
<h3>Storage 本地化存储</h3>
<p><a href="https://github.com/PlasmoHQ/storage">PlasmoHQ/storage: 💾 Safely store data and share it across your extension</a>：此库提供给使用<code>plasmo</code>开发浏览器扩展程序去操作本地化存储的工具，兼容性很好。</p>
<h3>最后</h3>
<p>本周的web开发资讯就分享到这里，我们下周再见。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello, Ruby]]></title>
            <link>https://i5lin.top/blog/post/1559910415</link>
            <guid>1559910415</guid>
            <pubDate>Fri, 27 Jan 2023 15:02:16 GMT</pubDate>
            <description><![CDATA[Hello, Ruby! 学习 ruby 的语法知识，并且做一个 ruby 项目。]]></description>
            <content:encoded><![CDATA[<p>Hello, Ruby!</p>
<p><img src="https://mllmu3qmmprr.i.optimole.com/w:auto/h:auto/q:mauto/f:avif/https://www.codingclub.org/wp-content/uploads/elementor/thumbs/ruby-pnq82bm8hpfdnwihsoudyp39okf9fczjwsxjkewd54.jpg" alt=""></p>
<h1>Ruby Programming</h1>
<blockquote>
<p><a href="https://www.techotopia.com/index.php/Ruby_Essentials"><a href="https://www.techotopia.com/index.php/Ruby_Essentials">Ruby Essentials - Techotopia</a></a></p>
</blockquote>
<h2>HELLO WORLD.Ruby.</h2>
<pre><code class="language-ruby">puts &#39;hello world,ruby.&#39;
</code></pre>
<h3>Strings,Numbers,Classes and Objects</h3>
<pre><code class="language-ruby">puts(&#39;Enter your name:&#39;)
name = gets()
puts(&#39;hello, #{name}&#39;)
</code></pre>
<p><code>Puts</code> string into terminal.Gets input from terminal and save to variable <em>&quot;name&quot;</em> , and puts string with variable.</p>
<blockquote>
<p>If your do not want to auto add a linefeed after output, you can use <code>print</code> instead of <code>puts</code>.</p>
</blockquote>
<p>Ruby is case sensitive,<code>myvar</code> and <code>myVar</code> is difference variable.</p>
<p>The funny thing is, <code>#{name}</code>(called embedded evaluation) only works with double quotes and neither a single quote.</p>
<p>Next example about numbers:</p>
<pre><code class="language-ruby">subtotal = 100.00
taxrate = 0.175
tax = subtotal * taxrate
puts &quot;Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}&quot;
</code></pre>
<p>or other version:</p>
<pre><code class="language-ruby">taxrate = 0.175
print &quot;Enter price (ex tax): &quot;
s = gets
subtotal = s.to_f
tax = subtotal * taxrate
puts &quot;Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}&quot;
# this is a comment

=begin
This is a
multiline
comment
=end
</code></pre>
<blockquote>
<p>You can do not use <code>()</code> after any method, but sometimes ruby intercepted will warn you.</p>
</blockquote>
<p>Here <code>s.to_f</code> is a method of the String class.It attempts to convert the string to a floating point number.</p>
<p>If the string cannot be converted, <code>0.0</code> is returned.</p>
<p>You can find two comment at above code.</p>
<h3>Condition</h3>
<p>Example:</p>
<pre><code class="language-ruby">taxrate = 0.175
print &quot;Enter price (ex tax): &quot;
s = gets
subtotal = s.to_f
if (subtotal &lt; 0.0) then
    subtotal = 0.0
end
tax = subtotal * taxrate
puts &quot;Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}&quot;
</code></pre>
<p>Condition is simple like those:<code>if (...) then ... end</code>.</p>
<p>In fact, the brackets are optional, also the keyword <code>then</code> is optional too.But if you were to write the following, with no line break after the test condition, them <code>then</code> would be obligatory:</p>
<p><code>if( subtotal&lt; 0.0 ) then subtotal = 0.0 end</code></p>
<h3>Local and global variables</h3>
<p>Variables such as these, which begin with a lowercase character, are local variables, otherwise,   is a global variable.Look this example:</p>
<pre><code class="language-ruby">localvar = &quot;hello&quot;
$globalvar = &quot;goodbye&quot;
def aMethod
  localvar = 10
  puts( localvar )
  puts( $globalvar )
end
def anotherMethod
  localvar = 500
  $globalvar = &quot;bonjour&quot;
  puts( localvar )
  puts( $globalvar )
end
aMethod # echo 10,goodbye
anotherMethod # echo 500, bonjour
puts localvar # echo hello (scope variable)
puts $globalvar # echo boujour (global variable)
</code></pre>
<h3>Classes and Objects</h3>
<blockquote>
<p>A &#39;class&#39; is the blueprint for an object.And Ruby is object oriented.</p>
</blockquote>
<p>Let us create a dog class:</p>
<pre><code class="language-ruby">class Dog
  def set_name(aName)
    @myname = aName
  end
end
</code></pre>
<p>The class definition begins with the keyword <code>class</code>(all lowercase) and the name of the class itself, which must begin with an uppercase letter.</p>
<p>The class contains a method <code>set_name</code>.This takes a incoming argument, <code>aName</code>.</p>
<p>The body of the method assigns the value of  <code>aName</code> to variable called <code>@myname</code>.</p>
<h3>Instance variables</h3>
<p>Variables beginning with the <code>@</code> charactor are <code>instance variable</code>,that means that they belong to individuals objects, or instance of the class.</p>
<pre><code class="language-ruby">myDog = Dog.new
yourDog = Dog.new
myDog.set_name(&#39;Aaron&#39;)
yourDog.set_name(&#39;Jay&#39;)
</code></pre>
<p>At the moment, these two dogs have a difference name between other.The data inside each object is private.</p>
<p>This is called <code>data hiding</code>.</p>
<p>Now, we need each dog to know its own name.</p>
<pre><code class="language-ruby">def getName
  return @myname
end
</code></pre>
<blockquote>
<p>The <code>return</code> keyword here is optional.When it is omitted, Ruby methods will return the last expression evaluated.But for the sake of clarity, I want to keep write a clarity return value which I plan to use.</p>
</blockquote>
<h3>Messages,Methods and Polymorphism</h3>
<p>Nothing.</p>
<h3>Constructors - new and initialize</h3>
<p>Example:</p>
<pre><code class="language-ruby">class Demo
  def initialize(name, descrip)
    @name = name
    @descrp = descrip
  end
end
</code></pre>
<p>When a class contains  a method named <code>initialize</code> this will be automatically called when an object is created use the new method.</p>
<p>Developers often use a <code>initialize</code> method to set the values of an object&#39;s instance variables.</p>
<h3>Inspecting Objects</h3>
<p>The <code>inspect</code> method is defined for all Ruby Objects.It returns a string containing a humen-readable representation of the object.</p>
<p>Ruby also provides the <code>p</code> method as a shortcut to inspecting object</p>
<h2>Class Hierarchies,Attributes and Class variables</h2>
<h3>Class Hierarchies</h3>
<pre><code class="language-ruby">class Thing
  def initialize(name, des)
    @name = name
    @des = des
  end
  
  def getName
    return @name
  end
  
  def setName(name)
    @name = name
  end
end

class Treasure  &lt; Thing
  def initialize(name, des, value)
    super(name, des) # super =&gt; passes name , des and value to super class&#39;s initialize function
    # super() =&gt; no pass params
    @value = value
  end
  
  def value
    return @value
  end
  
  def value=(v)
    @value = v
  end
end
</code></pre>
<p>Classes have own <code>set</code> accessors, you can not use space between set accessors code.</p>
<p>So this is correct:</p>
<p><code>def name=(name)</code></p>
<p>And, this is an error:</p>
<p><code>def name = (name)</code></p>
<p>But, we have a shortcut method:</p>
<pre><code class="language-ruby">class Dog
  attr_reader :name
  attr_writer :name
  # more terse: attr_accessor :name
end
</code></pre>
<p>Now, you can set and get dog instance&#39;s name easily.</p>
<p>If you want to declare multi accessor, just like this:</p>
<pre><code class="language-ruby">class Dog
  attr_reader :name, :id
  attr_writer(:name, :id)
  # or 
  # attr_accessor(:name, :id)
end
</code></pre>
<blockquote>
<p>As always, in Ruby, brackets around the arguments are optional but, in my view (for reasons of clarity), are to be preferred.</p>
</blockquote>
<h3>Calling methods of a superclass</h3>
<p>If you want to init some value from superclass,you need to call super method.</p>
<h3>Class variables</h3>
<p>The two <code>@</code> characters at the start pf this variable name, <code>@@num</code>, define this to be a <code>class variable</code>.</p>
<p>if superclass define a class variable, then all subclass can share this variable.</p>
<h3>CONSTANTS INSIDE CLASSES</h3>
<pre><code class="language-ruby">class X
  A = 10
  class Y
  end
end
</code></pre>
<p>If you want to access the constant <code>A</code>, you must to use the special scope resolution operator  <code>::</code> like this:</p>
<p><code>X::A</code> or <code>ob = X::Y.new</code>!</p>
<h3>Partial classess</h3>
<p>In Ruby its is not obligatory to define a class all in one place.</p>
<pre><code class="language-ruby">class A
  def a
  puts( &quot;a&quot; )
  end
end

class B &lt; A
  def ba1
      puts( &quot;ba1&quot; )
  end
end

class A
  def b
  puts( &quot;b&quot; )
  end
end

class B &lt; A
  def ba2
      puts( &quot;ba2&quot; )
  end
end
</code></pre>
<p>Now,if I create a B object, all the methods of both A and B are available to it:</p>
<pre><code class="language-ruby">ob = B.new
ob.a # &#39;a&#39;
ob.b # &#39;b&#39;
ob.ba1 # &#39;ba1&#39;
ob.ba2 # &#39;ba2&#39;
</code></pre>
<p>You can use partial class definitions to add features onto Ruby&#39;s standard class such as Array:</p>
<pre><code class="language-ruby">class Array
  def hello
    puts &quot;hello&quot;
  end
end

[1,2,3].hello # &#39;hello&#39;
</code></pre>
<h3>User-Defined String Delimiters</h3>
<p>%Q/This is the same as a double-quoted string./
%/This is also the same as a double-quoted string./
%q/And this is the same as a single-quoted string/</p>
<p>Also, you can define your self string delimiters like this:</p>
<pre><code class="language-ruby">%Q[This is a string] # as &quot;this is a string&quot;
</code></pre>
<h3>BACKQUOTES</h3>
<p>Blackquotes means execute a system command.</p>
<pre><code class="language-ruby">puts(`ls`) # just like exec ls command on unix system
print(&quot;show dir: #{%x{ls}}&quot;)
</code></pre>
<h2>String Handling</h2>
<h3>Concatenation</h3>
<pre><code class="language-ruby">s = &quot;hi&quot; &lt;&lt; &quot;yo&quot;
s = &quot;hi&quot; + &quot;yo&quot;
s = &quot;hi&quot; &quot;yo&quot; 
# all echo: &#39;hiyo&#39;
</code></pre>
<blockquote>
<p>Puts a array will put each item in a newline,prints not.</p>
</blockquote>
<h3>String Assignment</h3>
<pre><code class="language-ruby">s = &quot;hello&quot;
s[1] # prints out index 1 =&gt; e
s[-1] # o
s[1,2] # el
</code></pre>
<p>If you want to remove some charactor from a string.</p>
<pre><code class="language-ruby">s = &quot;hello&quot;
s.chop # hell
s = &quot;hello
&quot;
s.chop # hello

s.chomp # just remove record separator , echo hello
s.chomp(&#39;lo&#39;) # hel
</code></pre>
<h3>Format String</h3>
<p>Ruby provides the <code>printf</code> method to print <code>format strings</code> containing specifiers starting with a percent sign, <code>%</code>.</p>
<pre><code class="language-ruby">printf(&quot;%0.02f&quot;, 10.123) # 10.12
</code></pre>
<h3>Ranges</h3>
<pre><code class="language-ruby">a = (1..10)
a.to_A # [1,2,3,...,10]
b = (&#39;b&#39;..&#39;e&#39;)
b.to_a # [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
</code></pre>
<h3>Interation with range</h3>
<pre><code class="language-ruby">for i in (1..3) do
  puts(i)
end
# 1,2,3 with newline
</code></pre>
<h3>Heredocs</h3>
<pre><code class="language-ruby">str = &lt;&lt;EODOC
I am Jay.
Yo
EODOC
</code></pre>
<h2>Arrays and Hashes</h2>
<p>An Array is a sequential collection of items in which each item can be indexed.</p>
<p>In an array, each item can be difference type.</p>
<h3>Create Arrays</h3>
<p>In common with many other programming languages, Ruby uses square brackets to delimit an array.</p>
<pre><code class="language-ruby">arr = [&#39;one&#39;, &#39;two&#39;]
puts(arr[1]) # two
Array.new # []
Array.new(2) # [nil, nil]
Array.new(2, &#39;a&#39;) # [&#39;a&#39;, &#39;a&#39;]
</code></pre>
<h3>Iteration over arrays</h3>
<pre><code class="language-ruby">arr = [1,2,3]
for i in arr
  puts(i.inspect)
end
# 1
# 2
# 3
</code></pre>
<h3>Indexing into array</h3>
<pre><code class="language-ruby">arr = [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]
arr[0,5] # [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]
arr[0..1] # [&#39;h&#39;]
arr = []
a[0] = 1
a[3] = 3
print(a) # [1, nil, 3]
</code></pre>
<h3>Copy arrays</h3>
<pre><code class="language-ruby">arr1 = [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;]
arr2 = arr1
arr2[0] = &#39;x&#39;
arr1 # [&#39;x&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;]
arr3 = arr1.clone
# arr3 is independent
</code></pre>
<h3>Sorting arrays</h3>
<pre><code class="language-ruby">arr.sort{
  |a,b|,
  a.to_s &lt;=&gt; b.to_s # if a &gt; b, return 1,if a === b,return 0, else return -1
  }
</code></pre>
<h3>Comparing values</h3>
<p>The comparison <code>operator</code> &lt;=&gt; (which is, in fact, a method) is defined in the Ruby module named Comparable.</p>
<p>Other operator:</p>
<ul>
<li><code>&lt;</code>: less than</li>
<li><code>==</code> : equal to</li>
<li><code>&gt;</code>: lass than</li>
</ul>
<h3>Array methods</h3>
<ul>
<li>flatten</li>
<li>compact</li>
<li>&lt;&lt;</li>
<li>clear</li>
<li>delete</li>
<li>delete_at</li>
<li>...</li>
</ul>
<blockquote>
<p>Visit here: <a href="https://www.freecodecamp.org/news/common-array-methods-in-ruby/"><a href="https://www.freecodecamp.org/news/common-array-methods-in-ruby/">Most Common Ruby Array Methods You Should Know</a></a></p>
</blockquote>
<h3>Creating Hashes</h3>
<pre><code class="language-ruby">h1 = Hash.new
h2 = Hash.new(&quot;some kind of ring&quot;)
h1 # {}
h1[&#39;name&#39;] = &#39;Jay&#39;
h1 # {&#39;name&#39;: &#39;Jay&#39;}
</code></pre>
<p>Hash map&#39;s key can be any type in principle.</p>
<h3>Copying a hash</h3>
<pre><code class="language-ruby">h1 = Hash.new
h1[&#39;a&#39;] = &#39;a&#39;
h2 = h1.clone
h2[&#39;a&#39;] = &#39;aa&#39;
h1[&#39;a&#39;] # &#39;a&#39;
</code></pre>
<h3>Sorting a hash</h3>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2023年 - 年初思索]]></title>
            <link>https://i5lin.top/blog/post/1552216667</link>
            <guid>1552216667</guid>
            <pubDate>Sun, 22 Jan 2023 17:47:46 GMT</pubDate>
            <description><![CDATA[2023年01月23日00:44:04  室外温度：8° 深夜，肚子饿。

![](https://images.unsplash.com/photo-1467810563316-b5476525c0f9?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8aGFwcHklMjBuZXclMjB5ZWFyfGVufDB8MHwwfHw%3D&auto]]></description>
            <content:encoded><![CDATA[<p>2023年01月23日00:44:04  室外温度：8° 深夜，肚子饿。</p>
<p><img src="https://images.unsplash.com/photo-1467810563316-b5476525c0f9?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8aGFwcHklMjBuZXclMjB5ZWFyfGVufDB8MHwwfHw%3D&auto=format&fit=crop&w=800&q=60" alt=""></p>
<p>回顾去年的工作，996不可避免，精神内耗永无止境。</p>
<p>但是，收获大于消耗。</p>
<p>去年年后去了福州食亨，入职后真正体会到前端开发在做什么，以及web开发的流程和团队是怎么配合的。</p>
<p>在那段时间很快就写了比前年在深圳一年还多的代码，身边的同事都很不错。感谢当时帮我很多的宇哥，但是不得不说塔斯汀微信小程序简直乱成一锅粥（sorry，宇哥，但那部分代码真的一锅粥）</p>
<p>在福州结识了几个朋友也不错。</p>
<p>年中，投奔了老胡。</p>
<p>新的团队从零开始，我开始负责更多工作，除了日常的编码之外，甚至还有设计（当然我的设计水平简直不忍直视，幸运的是我们后来来了一个超级酷的设计师，括弧：不是设计水平很酷），甚至还负责给新人前端做一面。</p>
<p>这部分工作内容很有趣，对我来说是一种全新的体验。从某天晚上开始，我陆陆续续看简历，语音沟通面试内容，从说话莫名其妙到稍微有一点逻辑，很有趣。</p>
<p>给新人看简历、做一面让我了解了如何处理简历、如何跟面试官沟通，甚至是公司和面试官期望的面试者需要具有什么特性和能力。</p>
<p>工作的部分，大家都是年龄相近的同事，沟通非常顺畅。</p>
<p>对于我带的几个新人，我很抱歉。</p>
<p>如果你们看到我写的这部分内容，我很抱歉。这是我第一次带人，距离我被带仅仅有一个月时间左右😂。</p>
<p>我带得不好，源于自己并没有足够的能量和能力。这也就导致了我们初期不断的加班和返工，我们疲于奔命去处理一些问题。</p>
<p>sorry. 为深夜两点我们还在公司而道歉。</p>
<p>这里可能真的不适合你们仨，新人进入职场有一个经验丰富且足够优秀的前辈太重要了。</p>
<p>最终你们都离开了，这是我的遗憾。</p>
<p>但是，你们几个也不要放松，自己也要好好加油~ </p>
<p>剑伟不要笑嘻嘻的！如琦和迎霜要多巩固基础。（我不好意思发给你们，看得到看不到全靠缘分😂</p>
<p>此外，新团队的leader真的很拼，当然也很好说话。</p>
<p>现在立马发一张好人卡给我组长昭鹏，你真是个好人，但是除夕夜还跟我说工作真的很 fuck-off。</p>
<p>剑鑫身体素质真好，中了新冠还能肝到半夜。</p>
<p>老胡搭建了公司的整个技术体系框架，cool.</p>
<p>技术上，我还有很多需要学习的地方，非常非常多。由于不够了解技术，经常跟老胡讨论问题却答不出结果，尬。</p>
<p>总体来说，工作上去年求仁得仁，唯一不如意的地方就是加班加班加班，我有很严重的精神内耗，非常非常严重，也就导致了熬夜太多，生活作息紊乱，精神内耗也因此加剧，无限循环。</p>
<p>犹如一个孤岛。</p>
<p>2023年01月23日01:38:16</p>
<p>新的一年，祝有所改变。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[创业就像狂欢节游戏，而有些人只是工作人员]]></title>
            <link>https://i5lin.top/blog/post/1552111140</link>
            <guid>1552111140</guid>
            <pubDate>Sun, 22 Jan 2023 13:10:55 GMT</pubDate>
            <description><![CDATA[游乐场有一个飞镖游戏，大家纷纷尝试。但是，我买不起票来体验这种游戏，我是工作人员。]]></description>
            <content:encoded><![CDATA[<p><img src="https://images.unsplash.com/photo-1553481187-be93c21490a9?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8Mnx8Z2FtZXxlbnwwfDB8MHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<h2>创业游戏</h2>
<blockquote>
<p><code>notacoward</code>:&quot;Entrepreneurship is like one of those carnival games where you throw darts or something.</p>
<p>Middle class kids can afford one throw. Most miss. A few hit the target and get a small prize. A very few hit the center bullseye and get a bigger prize. Rags to riches! The American Dream lives on.</p>
<p>Rich kids can afford many throws. If they want to, they can try over and over and over again until they hit something and feel good about themselves. Some keep going until they hit the center bullseye, then they give speeches or write blog posts about &quot;meritocracy&quot; and the salutary effects of hard work.</p>
<p>Poor kids aren&#39;t visiting the carnival. They&#39;re the ones working it.&quot;</p>
</blockquote>
<p>创业就像狂欢节游戏，你可以扔飞镖什么的。</p>
<p>中产阶级的孩子扔得起。大部分都没打中。有几个击中了目标，得到了一个小奖品。只有极少数射中了中心的靶心，获得了更大的奖励。白手起家！美国梦永存。</p>
<p>有钱人家的孩子可以买得起很多东西。如果他们愿意，他们可以一遍又一遍地尝试，直到他们得到什么东西，并对自己感觉良好。有些人一直坚持下去，直到他们成功中心靶心，然后他们发表演讲或写博客文章，谈论“精英管理”和努力工作的有益影响。</p>
<p>而有些可怜的孩子们不是来参观狂欢节的，他们才是工作人员。</p>
<h2>微信读书体验卡</h2>
<p><a href="https://weread.qnmlgb.tech/">瓦斯组队 - 无限卡 - 微信读书组队</a>：利用微信读书的组队机制，快速匹配陌生人组队即可获取不限次数的会员体验卡。</p>
<h2>李志音乐</h2>
<p><a href="https://lizhi.turkyden.com/#/">李志 BB 音乐作品播放器</a>：民间李志音乐爱好者＆web开发者开源的在线播放器，站点资源都收集自网络，并且向李志先生发了邮件告知。</p>
<p>另外，支持打包成移动APP，如果你有MacBook也可以单独下载客户端，如果你有特斯拉😂，也提供了特斯拉车载系统应用。</p>
<h2>Web 应用打包</h2>
<p><a href="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Simply make any web page a desktop application using Rust. 🤱🏻 很简单的用 Rust 打包网页生成很小的桌面 App</a>，已有的打包应用诸如：</p>
<ul>
<li>微信读书</li>
<li>Twitter</li>
<li>李志音乐</li>
<li>YouTube</li>
<li>...</li>
</ul>
<p>开发者可以自己定制自己的需求，小白也可以去下载某些APP，如果还没有打包也可以发起请求。</p>
<h2>安全的RM命令</h2>
<p><a href="https://github.com/nivekuil/rip">nivekuil/rip: A safe and ergonomic alternative to rm</a>：使用<code>Rust</code>写的命令行程序，更快更安全的删除文件或目录的程序，并且支持误删除恢复。</p>
<h2>克隆CP命令</h2>
<p><a href="https://github.com/tarka/xcp">tarka/xcp: An extended `cp`</a>：依然是<code>Rust</code>重写的命令行程序，克隆了系统的<code>cp</code>命令，更快且具有以下功能：</p>
<ul>
<li>展示进度条</li>
<li>支持<code>.gitignore</code>限制不需要复制的文件</li>
</ul>
<p>并且由于底层调用系统机制的优化，其复制大文件更快，我们可以利用<code>alias</code>直接替换掉<code>cp</code>命令。</p>
<h2>JS全文搜索库</h2>
<p><a href="https://lucaong.github.io/minisearch/">MiniSearch</a>：这是一个小而美的全文搜索库，可以在浏览器和<code>Node</code>环境下运行，如果你将要使用JS技术栈去做一些全文搜索，可以找到这个库。</p>
<h2>输入法应用匹配</h2>
<p><a href="https://inputsource.pro/zh-CN?utm_medium=email&utm_source=Revue%20newsletter&utm_campaign=%E5%8F%AF%E4%B9%90%E5%91%A8%E6%8A%A5">Input Source Pro - 优化 macOS 输入法使用体验</a>：切换不同的应用时，自动切换为预设的输入法。</p>
<h2>安全的RM命令</h2>
<p><a href="https://github.com/nivekuil/rip">nivekuil/rip: A safe and ergonomic alternative to rm</a>：使用<code>Rust</code>写的命令行程序，更快更安全的删除文件或目录的程序，并且支持误删除恢复。</p>
<h2>克隆CP命令</h2>
<p><a href="https://github.com/tarka/xcp">tarka/xcp: An extended `cp`</a>：依然是<code>Rust</code>重写的命令行程序，克隆了系统的<code>cp</code>命令，更快且具有以下功能：</p>
<ul>
<li>展示进度条</li>
<li>支持<code>.gitignore</code>限制不需要复制的文件</li>
</ul>
<p>并且由于底层调用系统机制的优化，其复制大文件更快，我们可以利用<code>alias</code>直接替换掉<code>cp</code>命令。</p>
<h2>JS全文搜索库</h2>
<p><a href="https://lucaong.github.io/minisearch/">MiniSearch</a>：这是一个小而美的全文搜索库，可以在浏览器和<code>Node</code>环境下运行，如果你将要使用JS技术栈去做一些全文搜索，可以找到这个库。</p>
<h2>输入法应用匹配</h2>
<p><a href="https://inputsource.pro/zh-CN?utm_medium=email&utm_source=Revue%20newsletter&utm_campaign=%E5%8F%AF%E4%B9%90%E5%91%A8%E6%8A%A5">Input Source Pro - 优化 macOS 输入法使用体验</a>：切换不同的应用时，自动切换为预设的输入法。</p>
<h2>世界国旗资源</h2>
<p><a href="https://seekflag.com/">Seek Flag | Flags of the World</a>：免费下载全世界的国家的国旗，提供<code>png</code>和<code>svg</code>格式。</p>
<h2>CSS 迷你课程</h2>
<p><a href="https://doc.clickup.com/37465296/d/13qb6g-64/css-mini-course/13qb6g-84/css-mini-course">CSS Mini Course</a>，前提是你能上推特。</p>
<h2>油管私有接口</h2>
<p><a href="https://www.npmjs.com/package/youtubei.js">youtubei.js - npm</a>：如果有一天，你想利用油管的数据去做一些有趣的事情，可能这个库能帮到很多忙。</p>
<h2>新世代企业论坛</h2>
<p><a href="https://www.trickle.so/">Trickle – A better way to align your team</a>：新世代的人或许会喜欢，定位是企业内的员工可以工作和交流，分享大家的想法，设计和交互非常现代化。</p>
<h2>制作猫的照片</h2>
<p><a href="https://uchinoko-maker.jp/">【公式】うちのこメーカー | 猫イラストを無料で簡単作成！</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[没有人会偶然成为宇航员]]></title>
            <link>https://i5lin.top/blog/post/1552107581</link>
            <guid>1552107581</guid>
            <pubDate>Sun, 22 Jan 2023 12:58:35 GMT</pubDate>
            <description><![CDATA[没有人会偶然成为宇航员.

![](https://images.unsplash.com/photo-1581574919402-5b7d733224d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8Z29hbHxlbnwwfDB8MHx8&auto=format&fit=crop&w=800&q=60)

- 没有人会偶然成为宇航员]]></description>
            <content:encoded><![CDATA[<p>没有人会偶然成为宇航员.</p>
<p><img src="https://images.unsplash.com/photo-1581574919402-5b7d733224d6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8Z29hbHxlbnwwfDB8MHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<ul>
<li>没有人会偶然成为宇航员</li>
<li>“产品”</li>
<li>你关注的是什么？你把精力放在哪里？你听信谁的声音？你阅读谁的文字？</li>
</ul>
<h3>趣事趣图</h3>
<p>荷兰的一个图书馆，你想要为电子设备充电的话，必须骑自行车发电😂</p>
<p><img src="https://cdn.beekka.com/blogimg/asset/202212/bg2022120702.webp" alt=""></p>
<p>根据新西兰的一项研究，由于没有打开窗户，公共汽车内部充满了乘客呼出的二氧化碳。空车的时候，二氧化碳浓度是百万分之516，即 516 ppm；乘满乘客20分钟以后，二氧化碳浓度就上升到了 5737 ppm，上升了十多倍。</p>
<p><strong>所以，你在呼吸谁的呼吸。</strong></p>
<p><img src="https://cdn.beekka.com/blogimg/asset/202212/bg2022120820.webp" alt=""></p>
<p>这就是我宁愿走路也不愿挤公交的原因。</p>
<h3>ChatGPT Chrome Extension</h3>
<p>这是一个<code>ChatGPT</code>谷歌插件，安装之后就可以在插件栏使用<code>ChatGPT</code>，并且在谷歌搜索结果的右侧空白区域，为你当前搜索的关键字提供<code>ChatGPT</code>的回答结果。</p>
<p>笔者体验之后感觉不错，在某些时候能直接得到我搜索想要的答案。</p>
<blockquote>
<p><code>ChatGPT</code>真的很强，但由于某种原因国内用户无法注册，并且因为网络原因国内也无法访问，如果需要注册的话则需要一个国外的手机号接收验证码。</p>
</blockquote>
<h3><a href="https://github.com/BlackGlory/parse-favicon#readme"><a href="https://sms-activate.org/en">Virtual numbers for receiving SMS online - SMS-Activate</a></a></h3>
<p>国外的一个接码平台，你可以花一块钱就能得到一个二十分钟有效期的印度手机号。是的，你可以用来注册<code>ChatGPT</code>。</p>
<p>他们的支付平台非常多，你甚至可以用支付宝支付。</p>
<h3><a href="https://trianglify.io/">Trianglify.io · Low Poly Pattern Generator</a></h3>
<p>你是否见过某个站点的背景是非常漂亮的三角形拼接成的图片，这个应用能让你轻松得到一张绚丽的多个三角形合成的图片。</p>
<h3><a href="https://rome.tools/">Rome — Unified developer tools for JavaScript, TypeScript, and the web</a></h3>
<p><code>Rome</code>不是一日建成的，但如果前端配置被它统治，也不是什么坏事。</p>
<p>这个工具的愿景就是让前端开发不在受到无数的配置所困扰，让开发者专注到开发中来。</p>
<blockquote>
<p><code>Rome</code>格式化代码的速度远超<code>eslint</code>或<code>prettier</code>，前端工具链正在被<code>Rust</code>重构。</p>
</blockquote>
<h3><a href="https://nassimsoftware.github.io/zeldabotwstreetview/">Zelda BotW Street View</a></h3>
<p>塞尔达旷野之息的地图，从这里进入塞尔达世界。</p>
<h3><a href="https://eveningkid.com/denodb-docs/">denoDB · MySQL, SQLite, MariaDB, PostgreSQL and MongoDB ORM for Deno</a></h3>
<p><img src="https://eveningkid.com/denodb-docs/img/logo.png" alt=""></p>
<p>MySQL, SQLite, MariaDB, PostgreSQL and MongoDB ORM for Deno. 祝<code>Deno</code>变得更好.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[攀比会偷走快乐]]></title>
            <link>https://i5lin.top/blog/post/1552107082</link>
            <guid>1552107082</guid>
            <pubDate>Sun, 22 Jan 2023 12:56:37 GMT</pubDate>
            <description><![CDATA[攀比会偷走快乐。

![](https://images.unsplash.com/photo-1519238425857-d6922ed3d613?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8NHx8bG9uZWx5fGVufDB8fDB8fA%3D%3D&auto=format&fit=crop&w=800&q=60)

- 攀比会偷走快乐]]></description>
            <content:encoded><![CDATA[<p>攀比会偷走快乐。</p>
<p><img src="https://images.unsplash.com/photo-1519238425857-d6922ed3d613?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8NHx8bG9uZWx5fGVufDB8fDB8fA%3D%3D&auto=format&fit=crop&w=800&q=60" alt=""></p>
<ul>
<li>攀比会偷走快乐</li>
<li>极简主义：舍弃不必要的一切</li>
<li>“过去的经历使我意识到缺乏评论框不会阻碍那些真正想要交流的人，如果真的有必要，即使在没有评论框的情况下，这些人也能通过各种方式向我发送信息，这本身是非常奇妙的。”</li>
<li>花点时间把今天看做一个机会</li>
<li>大多数人只能成为无能的模仿者，如果你也是模仿者，那就去模仿最优质的目标。</li>
<li>有时，最短，最简单的路径可能是错误的路径，而最远，最困难的路径才是正确的。如今几乎所有事情都有摩擦更小，更人性化的解决方案。 遗憾的是，那些能够被动获得的解决方案，其本质多是在向人们兜售某种产品。</li>
</ul>
<h3><a href="https://sli.dev/">Slidev</a></h3>
<p>为开发者打造的演示文稿工具，如果你需要为团队或其他群体做技术分享，或许你会喜欢这个很有技术范的演示文稿工具。</p>
<blockquote>
<p>Slidev 依然在开发中，API和用法尚未稳定，但值得我们期待。</p>
</blockquote>
<h3><a href="https://github.com/BlackGlory/parse-favicon#readme">BlackGlory/parse-favicon: 🌲 Parse HTML to get icon information</a></h3>
<p><code>Node</code>环境下，获取某个站点的<code>favicon</code>的工具</p>
<h3><a href="https://www.hyperui.dev/">Free Open Source Tailwind CSS Components | HyperUI</a></h3>
<p>基于<code>tailwindcss</code>且开源的原生组件示例，无论是直接使用还是逐一学习其实现，都很有现实意义。</p>
<p>我们可以直接利用这些内容来帮助我们实现自己的需求，也可以学习到其构建结构化良好的组件的方式。</p>
<blockquote>
<p>在我看来，其后者的意义对于个人开发者来说更重大，这个真的很不错。我决定将之加入到自己的待办事项之中。</p>
</blockquote>
<h3><a href="https://www.bookstack.cn/books/webapi-tutorial">《阮一峰 Web API 教程》 - 书栈网 · BookStack</a></h3>
<p>阮一峰所著的<code>web api</code>教程，图文并茂。我想每一个<code>web</code>开发者都需要了解这部分的知识，这会在未来某一天你需要写涉及这部分功能的产品时发挥作用。</p>
<h3><a href="https://github.com/nuxt-modules/icon">nuxt-modules/icon: The <Icon> component, supporting Iconify, Emojis and custom components.</a></h3>
<p>这绝对是在<code>Nuxt</code>框架下最佳的<code>Icon</code>解决方案之一，或许可以参考这个组件去构建基于企业或团队内部的<code>SVG Icon</code>解决方案。</p>
<h3><a href="https://responsively.app/">A Web Developer&#39;s Browser | Responsively App</a></h3>
<p>一款可以同时预览web开发响应式效果和滚动截屏的跨平台应用，关键是开源且免费。</p>
<p>如果你也需要为某些项目编写响应式代码，或许这会对你预览效果产生帮助。</p>
<h3><a href="https://www.colorhexa.com/color-names"><a href="https://tinify.cn/">TinyPNG – 智能压缩您的WebP、JPEG和PNG图片</a></a></h3>
<p>这是一个支持图片压缩的在线应用，并且支持API调用。压缩效果很不错，支持<code>5M</code>以下尺寸的免费压缩。</p>
<h3><a href="https://css-tricks.com/gradient-borders-in-css/">Gradient Borders in CSS | CSS-Tricks - CSS-Tricks</a></h3>
<p>基于<code>CSS</code>的渐变边框样式实现方案介绍。</p>
<p>度过了一个美好的周末，我写周刊的能量条又恢复了。</p>
<p>工作好忙，学习如何处理这些事情的同时，恢复自己的能量也很重要。</p>
<p>去看了牙医，麻药打下去我是真的麻了，要好好保护牙齿。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[知道自己想做什么事情的人是幸运的，他们可能这辈子都能乐在其中.]]></title>
            <link>https://i5lin.top/blog/post/1552106143</link>
            <guid>1552106143</guid>
            <pubDate>Sun, 22 Jan 2023 12:53:07 GMT</pubDate>
            <description><![CDATA[知道自己想做什么事情的人是幸运的，他们可能这辈子都能乐在其中.

![](https://images.unsplash.com/photo-1558929996-da64ba858215?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGRvZ3N8ZW58MHx8MHx8&auto=format&fit=crop&w=800&q=60)
]]></description>
            <content:encoded><![CDATA[<p>知道自己想做什么事情的人是幸运的，他们可能这辈子都能乐在其中.</p>
<p><img src="https://images.unsplash.com/photo-1558929996-da64ba858215?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGRvZ3N8ZW58MHx8MHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<h3><a href="https://github.com/wclr/yalc">wclr/yalc: Work with yarn/npm packages locally like a boss.</a></h3>
<p>让调试第三库变得简单。</p>
<p>开发第三方库的时候，可以看看这个工具。</p>
<h3><a href="https://github.com/unjs/consola#readme">GitHub - unjs/consola: Elegant Console Logger for Node.js and Browser 🐨</a></h3>
<p>现代化的<code>Javascript</code>打印工具（我就是喜欢花里胡哨），支持浏览器和<code>node</code>端。</p>
<p>好吧，优点如下：</p>
<ul>
<li>易用：接口可以随时替换原生<code>console</code>的方法</li>
<li>支持输出回调</li>
<li>支持命令行接口</li>
<li>支持多标签配置</li>
<li>支持输出中断和重启</li>
<li>支持<code>mock</code>数据### <a href="https://nextui.org/">NextUI - Beautiful, fast and modern React UI Library</a></li>
</ul>
<p>React 服务端渲染框架<code>Next</code>官方团队出品的<code>UI</code>库，个人觉得质量还是挺不错的，无论是学习还是在自己的项目里使用，都是一个不错的选择。</p>
<p>目前依然属于<code>beta</code>版本，但是看其进度和更新的频率还是很高效的。</p>
<p>我喜欢。</p>
<h3><a href="https://gitlab.com/gitlab-org/cli">GitLab.org / cli · GitLab</a></h3>
<p>GitHub 有<code>gh</code>命令行程序，<code>Gitlab</code>也有。</p>
<p>我一直喜欢命令行，并且认可“将一切手动处理的事情转化为程序”的观念，限于技术能力不足，但也愿意尝试坚持一步步走下去。</p>
<h3><a href="https://github.com/abhimanyu003/sttr"><a href="https://eduardoboucas.github.io/include-media/#documentation">include-media: Simple, elegant and maintainable media queries in Sass</a></a></h3>
<p><code>sass</code>语言最佳响应式设计断点语义化辅助库，即使现在<code>windicss</code>这样的库非常好用，在响应式上的支持已然足够好用，但是我依然有独立处理<code>sass</code>代码的场景，<code>include-media</code>是我的最爱。</p>
<h3><a href="https://www.hyperui.dev/">Free Open Source Tailwind CSS Components | HyperUI</a></h3>
<p>基于<code>tailwindcss</code>的开源原生组件，不要拿去就用，而是学习到它的实现方式和思维。</p>
<h3><a href="https://www.colorhexa.com/color-names">List of colors</a></h3>
<p><code>web</code>设计之语义化颜色列表。</p>
<blockquote>
<p>从<code>aliceblue</code>搜到这里，留念：</p>
<p><strong>爱丽丝蓝</strong>（英语：Alice-Blue）是一种<a href="https://zh.wikipedia.org/wiki/%E9%A1%8F%E8%89%B2">颜色</a>，是属于<a href="https://zh.wikipedia.org/wiki/Category:%E8%97%8D%E8%89%B2%E7%B3%BB">蓝色系</a>的一种颜色，其颜色接近浅蓝灰色或钢青色。</p>
</blockquote>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[转化成动力的能量更多来自于激情]]></title>
            <link>https://i5lin.top/blog/post/1552023176</link>
            <guid>1552023176</guid>
            <pubDate>Sun, 22 Jan 2023 06:49:18 GMT</pubDate>
            <description><![CDATA[转化成动力的能量更多来自于激情，而不是压力。

![](https://images.unsplash.com/photo-1617042375876-a13e36732a04?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MzB8fGNvZGV8ZW58MHx8MHx8&auto=format&fit=crop&w=800&q=60)

- 严于]]></description>
            <content:encoded><![CDATA[<p>转化成动力的能量更多来自于激情，而不是压力。</p>
<p><img src="https://images.unsplash.com/photo-1617042375876-a13e36732a04?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MzB8fGNvZGV8ZW58MHx8MHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<ul>
<li>严于律己，宽以待人</li>
<li>转化成动力的能量更多来自于激情</li>
<li>Lift is short.</li>
</ul>
<h3><a href="https://github.com/wclr/yalc">wclr/yalc: Work with yarn/npm packages locally like a boss.</a></h3>
<p>让调试第三库变得简单。</p>
<p>开发第三方库的时候，可以看看这个工具。</p>
<h3><a href="https://github.com/unjs/consola#readme">GitHub - unjs/consola: Elegant Console Logger for Node.js and Browser 🐨</a></h3>
<p>现代化的<code>Javascript</code>打印工具（我就是喜欢花里胡哨），支持浏览器和<code>node</code>端。</p>
<p>好吧，优点如下：</p>
<ul>
<li>易用：接口可以随时替换原生<code>console</code>的方法</li>
<li>支持输出回调</li>
<li>支持命令行接口</li>
<li>支持多标签配置</li>
<li>支持输出中断和重启</li>
<li>支持<code>mock</code>数据</li>
</ul>
<h3><a href="https://nextui.org/">NextUI - Beautiful, fast and modern React UI Library</a></h3>
<p>React服务端渲染框架<code>Next</code>官方团队出品的<code>UI</code>库，个人觉得质量还是挺不错的，无论是学习还是在自己的项目里使用，都是一个不错的选择。</p>
<p>目前依然属于<code>beta</code>版本，但是看其进度和更新的频率还是很高效的。</p>
<p>我喜欢。</p>
<h3><a href="https://gitlab.com/gitlab-org/cli">GitLab.org / cli · GitLab</a></h3>
<p>GitHub 有<code>gh</code>命令行程序，<code>Gitlab</code>也有。</p>
<p>我一直喜欢命令行，并且认可“将一切手动处理的事情转化为程序”的观念，限于技术能力不足，但也愿意尝试坚持一步步走下去。</p>
<h3><a href="https://github.com/abhimanyu003/sttr"><a href="https://eduardoboucas.github.io/include-media/#documentation">include-media: Simple, elegant and maintainable media queries in Sass</a></a></h3>
<p><code>sass</code>语言最佳响应式设计断点语义化辅助库，即使现在<code>windicss</code>这样的库非常好用，在响应式上的支持已然足够好用，但是我依然有独立处理<code>sass</code>代码的场景，<code>include-media</code>是我的最爱。</p>
<h3><a href="https://www.hyperui.dev/">Free Open Source Tailwind CSS Components | HyperUI</a></h3>
<p>基于<code>tailwindcss</code>的开源原生组件，不要拿去就用，而是学习到它的实现方式和思维。</p>
<h3><a href="https://www.colorhexa.com/color-names">List of colors</a></h3>
<p><code>web</code>设计之语义化颜色列表。</p>
<blockquote>
<p>从<code>aliceblue</code>搜到这里，留念：</p>
<p><strong>爱丽丝蓝</strong>（英语：Alice-Blue）是一种<a href="https://zh.wikipedia.org/wiki/%E9%A1%8F%E8%89%B2">颜色</a>，是属于<a href="https://zh.wikipedia.org/wiki/Category:%E8%97%8D%E8%89%B2%E7%B3%BB">蓝色系</a>的一种颜色，其颜色接近浅蓝灰色或钢青色。</p>
</blockquote>
<h3><a href="https://www.dute.org/about">网站简介 - 独特工具箱 - dute.org</a></h3>
<p>一个免费的在线工具站点，无广告且画风简洁且具有不错的工具搜索支持。</p>
<p>支持以下分类的各种工具：</p>
<ul>
<li><p>程序开发</p>
</li>
<li><p>站长工具</p>
</li>
<li><p>图片工具</p>
</li>
<li><p>编码、解码</p>
</li>
<li><p>加密、解密</p>
</li>
<li><p>换算工具</p>
</li>
<li><p>语言处理</p>
</li>
<li><p>文本转换</p>
</li>
<li><p>数据生成</p>
</li>
<li><p>日常通用数据查询</p>
</li>
<li><p>常用对照表，提供了日常生活中方方面面的数据对照表</p>
</li>
</ul>
<h3>书籍分享</h3>
<ul>
<li><a href="https://www.bookstack.cn/books/webapi-tutorial">《阮一峰 Web API 教程》 - 书栈网 · BookStack</a>：原生<code>Web API</code>是前端开发者不可忽视的技术点。</li>
<li>《雪平锅无油料理》：单身狗最佳厨具“雪平锅”的绝配教程，照顾好自己。</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[徒：指能力不足，又肯自愿学习的人。]]></title>
            <link>https://i5lin.top/blog/post/1552021322</link>
            <guid>1552021322</guid>
            <pubDate>Sun, 22 Jan 2023 06:37:12 GMT</pubDate>
            <description><![CDATA[此刻的我是一个能力不足，但是肯自愿学习的人。

![](https://images.unsplash.com/photo-1561145999-7e82bd65c6e2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTN8fHJvb2tpZXxlbnwwfHwwfHw%3D&auto=format&fit=crop&w=800&q=60)

*]]></description>
            <content:encoded><![CDATA[<p>此刻的我是一个能力不足，但是肯自愿学习的人。</p>
<p><img src="https://images.unsplash.com/photo-1561145999-7e82bd65c6e2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTN8fHJvb2tpZXxlbnwwfHwwfHw%3D&auto=format&fit=crop&w=800&q=60" alt=""></p>
<p><strong>奴：指非自愿和靠人监督的人。</strong></p>
<p><strong>徒：指能力不足，又肯自愿学习的人。</strong></p>
<p><strong>工：就是老老实实，按规矩做事的人。</strong></p>
<p><strong>匠：指精通一门技艺或手艺，靠劳动生存的人。</strong></p>
<p><strong>师：就是掌握了一些规矩，又能将规律传授给他人的人。</strong></p>
<p><strong>家：有固定的信念，让别人生活得更好的人。</strong></p>
<p><strong>圣：精通事理，通达万物，大公无私，为民立命的人</strong></p>
<h3><a href="https://www.schemecolor.com/bat-bat.php"><a href="https://neteasecloudmusicapi-docs.4everland.app/#/">网易云音乐 NodeJS 版 API</a></a></h3>
<p>macOs 不支持上传音乐到云盘,于是我借助这个库写了个<code>CLI</code>工具来上传我喜欢的音乐到我的云盘.还写了自动签到的小工具,挂在了<code>github action</code>.</p>
<p>我很喜欢音乐,后续会一直用这个库来做一些有趣的东西.</p>
<h3>Flask 超级指南</h3>
<blockquote>
<p>曾几何时我也用 python flask 写接口.</p>
</blockquote>
<p><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">The Flask Mega-Tutorial Part I: Hello, World! - miguelgrinberg.com</a></p>
<h3>lukeed/kleur</h3>
<p><a href="https://github.com/lukeed/kleur">lukeed/kleur: The fastest Node.js library for formatting terminal text with ANSI colors~!</a></p>
<p>轻量且功能强大的<code>Node</code>终端颜色工具库,用来代替<code>chalk</code>还是不错的.</p>
<h3><a href="https://github.com/cmatsuoka/figlet">cmatsuoka/figlet: Claudio&#39;s FIGlet tree</a></h3>
<p>这个库能帮我们轻松创建<code>CLI LOGO</code>.</p>
<h3><a href="https://github.com/abhimanyu003/sttr">abhimanyu003/sttr: cross-platform, cli app to perform various operations on string</a></h3>
<p>跨平台的字符串<code>CLI</code>工具, 提供了很多实用的字符串处理功能.例如:</p>
<ul>
<li>MD5计算</li>
<li>BASE64计算</li>
<li>长度计算</li>
<li>提取信息(诸如邮件)</li>
<li>等等</li>
</ul>
<h3><a href="https://crawlee.dev/">Crawlee · Build reliable crawlers. Fast. | Crawlee</a></h3>
<p>基于<code>Nodejs</code>的网页抓取和自动化处理库,封装了无头浏览器<code>playwright</code>,简单一句话:“Python行的我也要行”</p>
<h3>这个世界的人如何表达“大笑”</h3>
<p><img src="https://cdn.beekka.com/blogimg/asset/202206/bg2022061601.webp" alt="img"></p>
<h3>Vim as IDE</h3>
<p><a href="https://github.com/ecosse3/nvim">ecosse3/nvim: A non-minimal Neovim config built to work most efficiently with Frontend Development - React &amp; Vue.js</a></p>
<p>零配置的<code>vim</code>,我决定在自己的笔记本上不再使用<code>vscode</code>, 我要转投<code>vim</code>的阵营.</p>
<p>难度?现在还是在起步阶段,虽然很久以前就接触了<code>vim</code>,但是一直没有深入尝试,没有坚持下来.这也许会是一个契机.</p>
<h3><a href="https://github.com/ts1/BLEUnlock">ts1/BLEUnlock</a></h3>
<blockquote>
<p>Lock/unlock your Mac with your iPhone, Apple Watch, or any other Bluetooth LE devices</p>
</blockquote>
<p>离开<code>pc</code>即自动锁屏,回到<code>pc</code>旁边自动激活屏幕并自动输入密码解锁的解决方案!</p>
<h3><a href="https://www.kaspersky.com.cn/resource-center/definitions/what-is-a-qr-code-how-to-scan">什么是二维码，如何扫描？</a></h3>
<p>如果你想要稍微了解一下二维码,可以花几分钟看看这篇介绍.</p>
<p><a href="https://www.gushiwen.cn/">古诗文网-古诗文经典传承</a></p>
<p>心血来潮,找了韩愈的《师说》读了读,发现这个古诗文的站点,无广告且设计具有古风气息.</p>
<p>古诗文真的很美,离开高中后再也没能再接触这些文化,可惜可惜.</p>
<p><a href="https://www.xiachufang.com/category/1009832/">【鱼汤的做法大全_鱼汤怎么做好吃_家常做法】_下厨房</a></p>
<p>见字如面, 我按着教程做了人生中自己的第一份鱼汤.(即使能接受第一次做鱼汤就失败,但实际比预料中好吃 😂)</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[所有一切经由他人之口说出来的真相，都可以被怀疑。]]></title>
            <link>https://i5lin.top/blog/post/1552019618</link>
            <guid>1552019618</guid>
            <pubDate>Sun, 22 Jan 2023 06:27:29 GMT</pubDate>
            <description><![CDATA[所有一切经由他人之口说出来的真相，都可以被怀疑。

旅行者在寺庙旁遇到三个工匠，随后询问其在做什么。其一回道：“我在搬砖”，其二则回答：“我们在砌这堵墙”。

其三看了看这寺庙，回答道：“我在修缮这间寺庙”。

这是个不知真假也不知从何而来的故事。但我们或许可以试试哪怕在某些起步阶段，做一些微不足道的事时改变思维来获取`动力`。

![](https://images.unspla]]></description>
            <content:encoded><![CDATA[<p>所有一切经由他人之口说出来的真相，都可以被怀疑。</p>
<p>旅行者在寺庙旁遇到三个工匠，随后询问其在做什么。其一回道：“我在搬砖”，其二则回答：“我们在砌这堵墙”。</p>
<p>其三看了看这寺庙，回答道：“我在修缮这间寺庙”。</p>
<p>这是个不知真假也不知从何而来的故事。但我们或许可以试试哪怕在某些起步阶段，做一些微不足道的事时改变思维来获取<code>动力</code>。</p>
<p><img src="https://images.unsplash.com/photo-1519389950473-47ba0277781c?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTF8fHdvcmt8ZW58MHx8MHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<h3><a href="https://bulma.io/">Bulma</a></h3>
<p>基于<code>Flexbox</code>的现代化纯<code>CSS</code>框架，善用此框架可以跟任何<code>JS</code>框架配合快速开发出具有良好一致性<code>UI</code>和色觉体验的应用。</p>
<blockquote>
<p>花了点时间看了它完整的文档，让我想起<code>tailwindcss</code>，确有其独到之处。</p>
</blockquote>
<p>内容很齐全，并且很<code>纯</code>。</p>
<p>配合原生JS就可以开发出不错的应用，配合自己喜欢的JS库则如虎添翼。</p>
<p>如果说<code>tailwindcss</code>是为了<code>CSS</code>而来，那么<code>Bulma</code>在<code>CSS</code>之上，还有很多组件化的思想，提供了一系列实用的组件示例。</p>
<h3><a href="https://www.reactpwa.com/">ReactPWA · An extendable boilerplate built on top of PawJS</a></h3>
<p>基于<code>React</code>和<code>PWA</code>、<code>PawJS</code>技术的项目模板，对于将要写<code>PWA</code>应用的开发者来说，很有学习价值。</p>
<h3><a href="https://smalldev.tools/">Home - SmallDev.tools</a></h3>
<p>齐全的<code>WEB</code>开发工具站，可以在这里找到日常工作中可能需要用到的技术小工具，例如<code>JSON</code>格式化、字符解码加密、日期匹配、Diff检查等等。</p>
<p>不妨看看，让其到你的收藏夹吃灰去。</p>
<h3><a href="https://openart.ai/">Discovery | OpenArt</a></h3>
<p>超过10万张由<code>DALL·E 2</code>生成的艺术图片，我想其可以作为我的某些素材来源。Blog？</p>
<h3>Fimo</h3>
<p>一个<code>IOS</code>上的相机软件，我很喜欢其复古的设计和成像效果。</p>
<h3>Plantnet</h3>
<p>一款植物识别软件，在我见到想要了解的植物时，它发挥了作用。</p>
<h3>Dime</h3>
<p>记账应用，使用后让我体会到我确实乱买了一些奇奇怪怪的东西 😂</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[伦常乖舛，立见消亡]]></title>
            <link>https://i5lin.top/blog/post/1551820079</link>
            <guid>1551820079</guid>
            <pubDate>Sat, 21 Jan 2023 14:49:11 GMT</pubDate>
            <description><![CDATA[佚名：世界上至少有两种防止“无意识作恶”的方法，一种是通过审核的方式，另一种则是信息透明的方式。

![](https://images.unsplash.com/photo-1674238924120-a9d9a0425d28?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwxNHx8fGVufDB8fHx8&auto=forma]]></description>
            <content:encoded><![CDATA[<p>佚名：世界上至少有两种防止“无意识作恶”的方法，一种是通过审核的方式，另一种则是信息透明的方式。</p>
<p><img src="https://images.unsplash.com/photo-1674238924120-a9d9a0425d28?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwxNHx8fGVufDB8fHx8&auto=format&fit=crop&w=800&q=60" alt=""></p>
<p>朱子治家：伦常乖舛，立见消亡。</p>
<p>Sam Parr：“当我让一个人给自己打分，他们通常说 6-9。接着我会问他们如何才能得到更高的分。这时他们会告诉你他们的弱点。”</p>
<h3>Vue 管理系统模板</h3>
<p><a href="https://github.com/vbenjs/vue-vben-admin">vbenjs/vue-vben-admin: A modern vue admin. It is based on Vue3, vite and TypeScript. It&#39;s fast！</a>：值得学习其构建方式，组件思路，整体风格。</p>
<h3>classnames 替代品</h3>
<p><a href="https://www.npmjs.com/package/clsx">clsx - npm</a>：更小且更快，用于设置前端类名。</p>
<h3>SVG 动画开发</h3>
<p><a href="https://svg-animation-booklet.vercel.app/">Home | SVG 动画开发实战</a>：值得学习的 SVG 构建动画的方案和经验分享</p>
<h3>基于 Tailwindcss 的主题插件</h3>
<p><a href="https://github.com/upupming/tailwindcss-themeable">upupming/tailwindcss-themeable: 🎨 Adds multiple themes support for Tailwind CSS and Windi CSS.</a></p>
<h3>UNSPLASH</h3>
<p><a href="https://unsplash.com/">Beautiful Free Images &amp; Pictures | Unsplash</a>：国外一个资源非常多的图片站点，提供完整的免费 API。</p>
<h3>酷站</h3>
<p><a href="https://imissmycafe.com/">I Miss My Cafe</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我寻找到一个用于参考公司内部后台管理平台脚手架的Vue脚手架 vbenjs]]></title>
            <link>https://i5lin.top/blog/post/1517581529</link>
            <guid>1517581529</guid>
            <pubDate>Tue, 03 Jan 2023 15:48:54 GMT</pubDate>
            <description><![CDATA[🚀 我寻找到一个用于参考公司内部后台管理平台脚手架的Vue脚手架 vbenjs！

![](https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=29]]></description>
            <content:encoded><![CDATA[<p>🚀 我寻找到一个用于参考公司内部后台管理平台脚手架的Vue脚手架 vbenjs！</p>
<p><img src="https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>vue 前端管理系统示例</h3>
<p>这是笔者最近一个月见过的最好的<code>vue</code>管理系统模板:</p>
<p><a href="https://github.com/vbenjs/vue-vben-admin">vbenjs/vue-vben-admin: A modern vue admin. It is based on Vue3, vite and TypeScript. It&#39;s fast！</a></p>
<p>其配备的文档非常详细，无论你是否用过 vue 开发 web 应用，都可以阅读此项目的文档（此文档对新手非常友好，能学到非常多的系统和项目架构的知识）</p>
<h3>颜色、调色板</h3>
<p><a href="https://encycolorpedia.cn/">十六进制颜色代码表，图表及调色板 - Encycolorpedia</a>：颜色设计思路枯竭了吗，这里有你需要的所有配色搭配。</p>
<h3>私有 NPM 仓库</h3>
<p><a href="https://verdaccio.org/">A lightweight Node.js private proxy registry | Verdaccio</a>：轻量、极简、友好的私有仓库代理服务，可以为你的团队部署私有服务，利用缓存提高访问速度、发布私有库等等。</p>
<p><a href="https://github.com/nanxiaobei/resso/blob/main/README.zh-CN.md">resso/README.zh-CN.md at main · nanxiaobei/resso</a>：号称世界上最简单的 React 状态管理库，支持 React 18、React Native、SSR、小程序。</p>
<h3>Sass Mixin 库</h3>
<p><a href="https://gerillass.com/">Gerillass: The best Sass mixins library for modern web design</a>：如果你经常使用 sass 进行开发，这个 mixin 库一定让你受用无穷，在开发时给你很多很方便的功能特性支持。</p>
<h3>Vue 懒加载组件</h3>
<p><a href="https://learnvue.co/tutorials/lazy-load-components">Lazy Load Components in Vue with defineAsyncComponent</a>：图文并茂的 Vue 懒加载组件介绍。</p>
<h3>前端编码知识分享博客</h3>
<p><a href="https://codesource.io/">CodeSource.io | Top Shelf Code Training</a>：每一篇文章都值得新手朋友学习的前端知识体系博客。</p>
<h3>CSS 多行文字截断</h3>
<p><a href="https://github.com/happylindz/blog/issues/12">纯 CSS 实现多行文字截断</a></p>
<h3>纯 CSS 变量实习动态主题</h3>
<p><a href="https://www.mayashavin.com/articles/dynamic-theme-css-variables">Dynamic theme with CSS Variables</a></p>
<p>利用 CSS 变量来实现项目的动态主题切换的方案介绍（图文并茂）！</p>
<p>如果没有接触过这个知识点，看这一篇非常有用。</p>
<h3>Tailwindcss 自定义主题方案</h3>
<p><img src="https://blog.logrocket.com/wp-content/uploads/2021/08/theming-tailwindCSS.png" alt="Creating custom themes with Tailwind CSS">：</p>
<p>使用<code>Tailwind CSS</code>来创建自定义的主题，如何提高使用这个库的效率，可以看看这一篇文章。</p>
<h3>默认模块导入插件</h3>
<p><a href="https://github.com/antfu/unplugin-auto-import">antfu/unplugin-auto-import: Auto import APIs on-demand for Vite, Webpack and Rollup</a>：无论是 React 还是 Vue，使用构建工具都可以借助类似的插件实现默认模块导入，省去了我们主动导入的麻烦。主动导入的代码看起来不多，但是项目日积月累就会有非常多的显示导入的代码，懒人还是喜欢此类插件的吧~</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[极度自律的人至少分为三种：假装的、自闭的、精神病]]></title>
            <link>https://i5lin.top/blog/post/1517496373</link>
            <guid>1517496373</guid>
            <pubDate>Tue, 03 Jan 2023 14:50:22 GMT</pubDate>
            <description><![CDATA[极度自律的人至少分为三种：假装的、自闭的、精神病（:

![](https://images.unsplash.com/photo-1613475104618-94f6321a19c7?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)

###]]></description>
            <content:encoded><![CDATA[<p>极度自律的人至少分为三种：假装的、自闭的、精神病（:</p>
<p><img src="https://images.unsplash.com/photo-1613475104618-94f6321a19c7?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>极简风博客</h3>
<p><a href="https://github.com/marcantondahmen/automad-terminal">marcantondahmen/automad-terminal: A minimal Automad blog theme for terminal lovers</a>：一个基于<code>PHP</code>的极简风格的博客系统，简单明了的色系搭配让我眼前一亮，给我一种技术的简单和纯粹的感觉（因此周日花了六小时用 React + TS 实现了一个版本，好累歇会）</p>
<h3>JavaScript 函数式编程</h3>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">Introduction · 函数式编程指北</a>，学习 JavaScript 函数式编程可以让我们的代码在某些场景下更简洁有效，稳定且易于测试。</p>
<h3>React 状态管理库</h3>
<p><a href="https://jotai.org/">Jotai, primitive and flexible state management for React</a>：基于 React 元数据的状态管理库，非常灵活和简洁，相比其他库来说可以少写很多格式化代码。</p>
<p><a href="https://github.com/nanxiaobei/resso/blob/main/README.zh-CN.md">resso/README.zh-CN.md at main · nanxiaobei/resso</a>：号称世界上最简单的 React 状态管理库，支持 React 18、React Native、SSR、小程序。</p>
<h3>汉语拼音库</h3>
<p><a href="https://theajack.github.io/cnchar/">cnchar (v3.2.2)</a>：功能全面，多端支持的汉字拼音笔画 JS 库，如果有相关方面的需求可以看看这个库。</p>
<h3>3D 悬停效果</h3>
<p><a href="https://atroposjs.com/">Atropos - Stunning touch-friendly 3D parallax hover effects</a>：web 3D 悬停特效动画库，多框架支持。</p>
<h3>渐变动画示例</h3>
<p><a href="https://hypercolor.dev/">Gradients for Tailwind CSS | Hypercolor</a>：思路枯竭了吗？这里有一些渐变背景色挺不错的。</p>
<h3>Flutter 资源</h3>
<p><a href="https://zhuanlan.zhihu.com/p/545521148">Flutter 资源大全 - 组件、导航、模板、插件、框架和引擎，应有尽有 - 知乎</a></p>
<h3>404 页面示例</h3>
<p><a href="https://blog.stackfindover.com/html-css-404-page-templates/">35+ HTML 404 Page Templates - Stackfindover</a>：学了这几十个错误页面示例，以后再也不用害怕没思路。</p>
<h3>Until</h3>
<p><a href="https://getuntil.app/">Until App</a>：倒数日 APP，记录某个事件倒数计划，可以为苹果设备添加挂件。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我们的“互联网”犹如一个巨大的孤岛，巨大到里面的大多数人都以为互联网上只有本国人，坐着井底看着天空。]]></title>
            <link>https://i5lin.top/blog/post/1517489827</link>
            <guid>1517489827</guid>
            <pubDate>Tue, 03 Jan 2023 14:45:25 GMT</pubDate>
            <description><![CDATA[我们的“互联网”犹如一个巨大的孤岛，巨大到里面的大多数人都以为互联网上只有本国人，坐着井底看着天空。

![](https://images.unsplash.com/photo-1485965373059-f07657e9f841?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=]]></description>
            <content:encoded><![CDATA[<p>我们的“互联网”犹如一个巨大的孤岛，巨大到里面的大多数人都以为互联网上只有本国人，坐着井底看着天空。</p>
<p><img src="https://images.unsplash.com/photo-1485965373059-f07657e9f841?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>React + TypeScript 博客</h3>
<p><a href="https://react-typescript-cheatsheet.netlify.app/">React TypeScript Cheatsheets | React TypeScript Cheatsheets</a>：React + TypeScript 开发者备忘录，你需要知道的<code>React + TypeScript </code>知识几乎都在这了。</p>
<h3>React项目学习资源</h3>
<p><a href="https://github.com/alan2207/bulletproof-react">alan2207/bulletproof-react: 🛡️ ⚛️ A simple, scalable, and powerful architecture for building production ready React applications.</a>：一个简单、灵活度高、结构良好，可以作为学习 TypeScript + React 开发的必备入门项目，我从中学到了很多。</p>
<h3>Vue 学习指南</h3>
<p><a href="https://learnvue.co/tutorials">Tutorials - LearnVue</a>：囊括了大多数 Vue 开发所需要的知识体系，阅读这些英文文档很有好处。</p>
<h3>原子化CSS引擎</h3>
<p><a href="https://github.com/unocss/unocss">unocss/unocss: The instant on-demand atomic CSS engine.</a>：知名开发者<code>antfu</code>力作，让我们更好地写<code>CSS</code>。</p>
<h3>Cerebro</h3>
<p><a href="https://cerebroapp.com/">Cerebro App – open-source productivity booster with a brain</a>：开源的资源引导工具，可以用以代替<code>Alfred</code>。</p>
<h3>Xnip</h3>
<p><a href="https://www.xnipapp.com/">Xnip | Handy Screenshot App for Mac</a>: 别出心裁的Mac截图工具，支持在桌面最顶层钉住最近的截图，便于查看。</p>
<h3>些许资源</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=UmVec9VHtpE&list=PLnTPdMjBRmAYehJkVbAXqxO-0cc9ALC6V">区块链课程 - YouTube</a>：北大陈老师的区块链视频课程，录制于老师上课现场</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue的编程挑战]]></title>
            <link>https://i5lin.top/blog/post/1517485228</link>
            <guid>1517485228</guid>
            <pubDate>Tue, 03 Jan 2023 14:41:55 GMT</pubDate>
            <description><![CDATA[入职了字符跳跃后，我的技术栈从`React`切换到了`Vue`，也因此让我对`Vue`有了更多接触和认识。OK，`React`最棒，但`Vue`也不差！

![](https://images.unsplash.com/photo-1653387141060-9a9834f47777?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGV]]></description>
            <content:encoded><![CDATA[<p>入职了字符跳跃后，我的技术栈从<code>React</code>切换到了<code>Vue</code>，也因此让我对<code>Vue</code>有了更多接触和认识。OK，<code>React</code>最棒，但<code>Vue</code>也不差！</p>
<p><img src="https://images.unsplash.com/photo-1653387141060-9a9834f47777?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>Vue挑战</h3>
<p><a href="https://cn-vuejs-challenges.netlify.app/">Vue.js 挑战 | 一个 Vue.js 在线挑战平台</a>：对于vue开发者来说还挺有趣的，并且能够提升自己的经验。</p>
<h3>Vue 脚手架</h3>
<p><a href="https://vitecamp.netlify.app/">Vitecamp</a>：一个国人创建的 <code>Vue</code> 脚手架，支持：</p>
<ul>
<li>Vue3</li>
<li>TS</li>
<li>Element-Plus</li>
<li>Vue Router 4</li>
<li>Pinia</li>
<li>Auto Icon</li>
<li>Windi CSS</li>
<li>Axios</li>
<li>I18n</li>
<li>ESLint + Prettier</li>
<li>Husky</li>
<li>NProgress</li>
<li>VueUse</li>
</ul>
<p>功能齐全，非常方便。</p>
<h3>React Toast</h3>
<p><a href="https://react-local-toast.netlify.app/">Intro | React Local Toast</a>：不同于其他顶层信息提示，这是个基于包装的标签位置的本地提示弹出组件。</p>
<h3>网站动画背景</h3>
<p><a href="https://www.vantajs.com/?effect=birds">Vanta.js - Animated 3D Backgrounds For Your Website</a>：短短几行代码即可应用令人炫目的动画背景特效</p>
<h3>web 编辑器</h3>
<p><a href="https://github.com/xjh22222228/awesome-web-editor">xjh22222228/awesome-web-editor: 🔨 Open source WEB editor summary</a>：一系列多框架多风格多功能的web编辑器列表，可以选用作为自己产品的编辑器。</p>
<h3>Github Commit Emoji</h3>
<p><a href="https://gitmoji.dev/">gitmoji | An emoji guide for your commit messages</a>: 为你的提交添加一个适宜的emoji吧~</p>
<h3>IconJar</h3>
<p><a href="https://geticonjar.com/">IconJar • Your icon organizer for macOS</a>：web 开发者的 Icon 管理工具，但是（年费 170RMB）</p>
<h4>MacOS 应用清理工具</h4>
<p><a href="https://freemacsoft.net/appcleaner/">AppCleaner</a>：免费强大的APP清理工具</p>
<h3>MacOS 归档工具</h3>
<p><a href="https://aptonic.com/">Aptonic - Dropzone 4</a>：方便地移动和复制文件，归档任务，启动程序、上传多种服务等</p>
<h3>MacOS 应用切换</h3>
<p><a href="https://bahoom.com/hyperswitch">HyperSwitch</a>：像 <code>Windows</code>一样切换应用</p>
<h4>MacOS 应用缩放尺寸</h4>
<p><a href="https://manytricks.com/moom/">Moom · Many Tricks</a>：缩放和移动应用窗口，便于操作</p>
<h3>些许博客</h3>
<ul>
<li><p><a href="https://linmi.cc/42154.html">实体图书扫描导入 Notion 实践 · 豆瓣评分版 - Linmi</a>：notion 用户望周知，可以方便地通过iPhone的快捷操作扫书籍的二维码，将书籍导入到notion，自动建立自己的书库记录。</p>
</li>
<li><p><a href="https://github.com/fang0jun/Blog/issues/27">浮点数详解(IEEE 754标准） · Issue #27 · fang0jun/Blog</a></p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[工作渐忙]]></title>
            <link>https://i5lin.top/blog/post/1516414381</link>
            <guid>1516414381</guid>
            <pubDate>Mon, 02 Jan 2023 13:45:39 GMT</pubDate>
            <description><![CDATA[内容不多，本周没学到太多工作之外的东西（人变得有点懒惰，但是还是明白有很多事要做，一步步）

![](https://images.unsplash.com/photo-1519861531473-9200262188bf?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&]]></description>
            <content:encoded><![CDATA[<p>内容不多，本周没学到太多工作之外的东西（人变得有点懒惰，但是还是明白有很多事要做，一步步）</p>
<p><img src="https://images.unsplash.com/photo-1519861531473-9200262188bf?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2500&q=80" alt=""></p>
<h3>React DnD 库</h3>
<p><a href="https://react-beautiful-dnd.netlify.app/?path=/story/single-vertical-list--basic">single vertical list - basic ⋅ Storybook</a>：React 下的拖动库，简洁灵活，值得学习和使用。</p>
<h3>Web 动画技术</h3>
<p><a href="https://lottiefiles.com/">Free Lottie Animation Files, Tools &amp; Plugins - LottieFiles</a>：轻量、灵活的动画技术，完美替代<code>GIF</code></p>
<h3>分轨</h3>
<p><a href="https://ifengui.com/">分轨 | 上传文件，即刻分离人声和伴奏</a>：如果你想要一首歌的伴奏</p>
<h3>像素风格壁纸站</h3>
<p><a href="https://novocom.club/view/7626db-pixel-gif-wallpaper-for-pc/">Pixel Gif Wallpaper For Pc - Novocom.top</a>：如果你想要一张像素风的壁纸</p>
<h3>Git 仓库徽章</h3>
<p><a href="https://shields.io/">Shields.io: Quality metadata badges for open source projects</a>：为你的<code>Git</code>仓库添加喜欢的徽章吧。</p>
<h3>开源免费的 SVG 图片</h3>
<p><a href="https://undraw.co/illustrations">Illustrations | unDraw</a>：为你的项目添加一些有趣精美的免费<code>SVG</code>图片</p>
<h3>RSS 阅读器</h3>
<p><a href="https://reederapp.com/">Reeder 5</a>：Mac 平台下很好用的<code>RSS</code>阅读器</p>
<h3>些许博客</h3>
<ul>
<li><a href="http://fisherlei.blogspot.com/">水中的鱼</a>：算法、编程、博客分享</li>
<li><a href="https://www.jstips.co/zh_CN/">Js Tips - A JavaScript tip per day!</a>：日常分享，每天都能学到 JavaScript 的知识</li>
</ul>
<h5>最后</h5>
<p>😰 昨天忘了发！！！</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[撤退的发际线]]></title>
            <link>https://i5lin.top/blog/post/1516409042</link>
            <guid>1516409042</guid>
            <pubDate>Mon, 02 Jan 2023 13:39:06 GMT</pubDate>
            <description><![CDATA[我发现我发际线快撑不住了，这克制住了我熬夜的欲望。（实际上只坚持了半个月，后来熬夜依旧，怎么办

![](https://images.unsplash.com/photo-1615232784987-5de0d5f33dd6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=cro]]></description>
            <content:encoded><![CDATA[<p>我发现我发际线快撑不住了，这克制住了我熬夜的欲望。（实际上只坚持了半个月，后来熬夜依旧，怎么办</p>
<p><img src="https://images.unsplash.com/photo-1615232784987-5de0d5f33dd6?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>令人惊叹的开源<code>web editor</code>汇总</h3>
<p><a href="https://github.com/xjh22222228/awesome-web-editor#Markdown-editor">xjh22222228/awesome-web-editor: 🔨 Open source WEB editor summary</a></p>
<p>在这里或许可以找到你的项目中可用的<code>markdown</code>编辑器、或是其他富文本编辑器开源作品。</p>
<h3>免费中文编程书单</h3>
<p><a href="https://github.com/justjavac/free-programming-books-zh_CN">justjavac/free-programming-books-zh_CN: 免费的计算机编程类中文书籍，欢迎投稿</a></p>
<h3>周报</h3>
<p><a href="about:blank#blocked">可乐周报 | Revue</a>：获取新知识，专注分享作者的视野。</p>
<h3>开源的跨平台多数据库 GUI 软件</h3>
<p><a href="https://www.beekeeperstudio.io/">Open Source SQL Editor and Database Manager | Beekeeper Studio</a>，支持以下一系列数据库</p>
<ul>
<li>PostgreSQL</li>
<li>MySQL</li>
<li>SQLite</li>
<li>Redshift</li>
<li>SQL</li>
<li>CockroachDB</li>
<li>MariaDB</li>
<li>Oracle</li>
</ul>
<h3>Jiffy</h3>
<p><a href="https://www.ezfuns.com/"><a href="https://www.jiffyreader.com/">Jiffy Reader</a></a>：一款能提高多数人英文阅读速度的 chrome 扩展程序，高亮单词的前缀，体验了一下确实对我有用。</p>
<h3>自由字体</h3>
<p><a href="https://ziyouziti.com/">免费的商用字体</a></p>
<h3>Fimo</h3>
<p>苹果的一款复古相机软件</p>
<h3>有知有行</h3>
<p>记账？理财？一款不错的相关<code>APP</code></p>
<h3>小宇宙</h3>
<p>一款专注于播客分享的软件，切菜必备。</p>
<h3>上百个<code>css</code>样式：linear-gradient 示例</h3>
<p><a href="https://uigradients.com/#Jupiter">uiGradients - Beautiful colored gradients</a>：或许可以找到你喜欢的那一款，并且应用到你的项目上。</p>
<h3>JavaScript 编程</h3>
<p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园</a>：一些 JavaScript 语言的知识点，探讨和分享。</p>
<h3>93 个<code>box-shadow</code>样式</h3>
<p><a href="https://getcssscan.com/css-box-shadow-examples">93 Beautiful CSS box-shadow examples - CSS Scan</a></p>
<p>拿走急用~</p>
<h3>值得学习的原生<code>CSS</code>+<code>HTML</code>小组件</h3>
<p><a href="https://uiverse.io/">CSS Buttons, checkboxes, and more! Copy paste CSS &amp; HTML</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[天干物燥，小心感染]]></title>
            <link>https://i5lin.top/blog/post/1516403611</link>
            <guid>1516403611</guid>
            <pubDate>Mon, 02 Jan 2023 13:32:34 GMT</pubDate>
            <description><![CDATA[最近朋友感染了，大家小心点。哎，真希望疫情早点过去。

![](https://images.unsplash.com/photo-1584931423298-c576fda54bd2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)

###]]></description>
            <content:encoded><![CDATA[<p>最近朋友感染了，大家小心点。哎，真希望疫情早点过去。</p>
<p><img src="https://images.unsplash.com/photo-1584931423298-c576fda54bd2?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>付费订阅服务</h3>
<p><a href="https://www.ezfuns.com/">介绍 | 艺爪付费</a>：为<code>APP</code>提供会员、订阅、内购付费的功能，支持的渠道非常广（个人用户一百万累计收款内免费）</p>
<h3>开源可商用的 SVG 设计系素材</h3>
<p><a href="https://undraw.co/illustrations">Illustrations | unDraw</a></p>
<h3>随机印刷排版领域的乱数假数据</h3>
<p>[Lorem Ipsum - All the facts - Lipsum generator</p>
<p><a href="https://cn.lipsum.com/"></a></p>
<h3>跨平台文件管理软件</h3>
<p><a href="https://www.spacedrive.com/">Spacedrive — A file manager from the future.</a>：非常美观，使用体验很棒（目前还只能用户自己编译）</p>
<h5>可部署的 Git 服务</h5>
<p><a href="https://github.com/theonedev/onedev">theonedev/onedev: Self-hosted Git Server with CI/CD and Kanban</a>：支持<code>CI/CD</code>和体验不错的<code>看板功能</code>!</p>
<h3>跨平台剪贴板管理 Node 类库</h3>
<p><a href="https://github.com/sindresorhus/clipboardy">sindresorhus/clipboardy: Access the system clipboard (copy/paste)</a></p>
<h3>匿名临时云盘</h3>
<p><a href="https://anonfiles.com/">Anonymous File Upload - AnonFiles</a>：20G 个人限制，下载不限速！</p>
<h3>快速部署网站</h3>
<p><a href="https://docusaurus.io/">Build optimized websites quickly, focus on your content | Docusaurus</a></p>
<h3>排版系统</h3>
<p><a href="https://type-scale.com/">Type Scale - A Visual Calculator</a>：方便地通过基准值计算页面字号体系，便于设计良好的<code>UI</code>系统</p>
<h3>YouTube 上的 Figma 入门教程</h3>
<p><a href="https://www.youtube.com/watch?v=eZJOSK4gXl4">Getting started with Figma: A beginner&#39;s guide - YouTube</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[坚持做事也需要补充能量]]></title>
            <link>https://i5lin.top/blog/post/1516393502</link>
            <guid>1516393502</guid>
            <pubDate>Mon, 02 Jan 2023 13:22:08 GMT</pubDate>
            <description><![CDATA[负重前行也需要回到港湾补充能量，珍惜自己的港湾。]]></description>
            <content:encoded><![CDATA[<p><img src="https://images.unsplash.com/photo-1515634928627-2a4e0dae3ddf?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h2>windows 系统资源</h2>
<ul>
<li><a href="https://msdn.itellyou.cn/">MSDN, 我告诉你 - 做一个安静的工具站</a></li>
<li><a href="https://tb.rg-adguard.net/public.php">TechBench by WZT (v4.1.1)</a></li>
</ul>
<p>原版 Windows 系统和软件下载，需要纯净版资源的可以在这里下载。</p>
<h2>临时云盘</h2>
<blockquote>
<p><a href="https://tmp.link/">钛盘 - 超好用的文件中转站</a></p>
</blockquote>
<p>不限速不限空间的临时限时云盘</p>
<h2>EPUB 阅读器</h2>
<blockquote>
<p><a href="https://www.neat-reader.cn/">EPUB 阅读器 | TXT 阅读器 | Neat Reader | 超赞的全平台电子书阅读器，全球百万用户共同的选择</a></p>
</blockquote>
<p>免费版本的阅读器就够用了，经常看电子书的可以看看。</p>
<h2>RSS 阅读器</h2>
<blockquote>
<p><a href="https://hyliu.me/fluent-reader/">Fluent Reader</a></p>
</blockquote>
<p>作者还是伯克利的学生</p>
<h2>WeekTodo</h2>
<blockquote>
<p><a href="https://weektodo.me/">WeekToDo | Free Minimalist Weekly Planner App</a></p>
</blockquote>
<p>待办事项工具，简单有效。</p>
<h2>React Vditor 编辑器</h2>
<blockquote>
<p><a href="https://goer.icu/react-vditor/">react-vditor demo</a></p>
</blockquote>
<p>在开发者群体中，<code>markdown</code>语法非常流行，同时<code>typora</code>编辑器也很有知名度，其比大多数编辑器更吸引人的关键，或许是实时渲染、所见即所得的功能。</p>
<p><code>React-vditor</code> 是一个支持即时渲染的<code>react</code>编辑器组件，如果有使用<code>react</code>开发支持<code>markdown</code>编辑功能的产品，<code>React-vditor</code>不会让你失望。</p>
<h2>React-icons</h2>
<blockquote>
<p><a href="https://react-icons.github.io/react-icons">react-icons</a> 项目地址</p>
</blockquote>
<p>在前端开发中，<code>icon</code>几乎是绕不过的点，UI 设计中有许多地方用得上。<code>react-icons</code>项目有一系列的免费<code>icon</code>提供给开发者使用。</p>
<h2>react 滚动条</h2>
<blockquote>
<p><a href="https://minjieliu.github.io/mac-scrollbar/">Mac-like scrollbar demo</a></p>
</blockquote>
<p>国人开发的一款类 Mac 滚动条的 React 组件，非常适合美化和统一浏览器滚动条样式的需求。</p>
<h2>Windows 终端体验优化</h2>
<p><a href="https://juejin.cn/post/7108282550405038111">Windows 下终端体验优化浅解 - 掘金</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[去中心化的硝烟正浓，这会是我们这一代人的暴风吗？]]></title>
            <link>https://i5lin.top/blog/post/1516388303</link>
            <guid>1516388303</guid>
            <pubDate>Mon, 02 Jan 2023 13:16:32 GMT</pubDate>
            <description><![CDATA[去中心化的硝烟正浓，这会是我们这一代人的暴风吗？

![](https://images.unsplash.com/photo-1626968361222-291e74711449?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)

### 去]]></description>
            <content:encoded><![CDATA[<p>去中心化的硝烟正浓，这会是我们这一代人的暴风吗？</p>
<p><img src="https://images.unsplash.com/photo-1626968361222-291e74711449?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>去中心化的电子书平台</h3>
<p><a href="https://ebook2.lorefree.com/">LoreFree-去中心化免费电子书共享社区</a>：没办法不推荐这个平台，可以在这里找到很多学习和阅读的资源。</p>
<h3>北大研究员的区块链知识课程</h3>
<p><a href="https://www.youtube.com/watch?v=UmVec9VHtpE&list=PLnTPdMjBRmAYehJkVbAXqxO-0cc9ALC6V">肖臻讲区块链技术与应用</a>：这一系列的课程分享在油管上，底部评论都挺好的，有兴趣可以看看。</p>
<h3>Rough.js</h3>
<p><a href="https://roughjs.com/">Rough.js</a>:是一个小图形库(&lt; 9kB) ，可以让你画一个粗略的、手绘的样式。该库定义了绘制直线、曲线、弧线、多边形、圆和椭圆的基元。它还支持绘制 SVG 路径。</p>
<p>感受一下效果：</p>
<p><img src="https://roughjs.com/images/cap.png" alt=""></p>
<p><img src="https://roughjs.com/images/m6.png" alt=""></p>
<p><img src="https://roughjs.com/images/m14.png" alt=""></p>
<p>使用这个工具，你得懂一些<code>canvas</code>和<code>svg</code>。</p>
<h3>Apollo</h3>
<p><a href="https://apps.apple.com/cn/app/apollo-%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84%E5%BD%B1%E8%A7%86%E7%94%9F%E6%B4%BB/id1616467801">App Store 上的“Apollo-记录你的影视生活”</a>：一款 IOS 上记录影视生活的软件，你可以使用 Apollo 来给已看的电影/剧集添加评分、评论、记录自己的观影方式等，也可以用它来追踪目前在追的剧集的观看进度、或者创建自己的「待看清单」。</p>
<p>依赖 iCloud 同步，没有花哨社交，很靠谱的软件。</p>
<h3>团队协作 - Superlist</h3>
<p><a href="https://www.superlist.com/">Superlist</a>：处于 Beta 阶段的超赞团队协作应用，界面效果非常炫酷，小团队或许可以尝尝鲜。</p>
<h3>One-goal</h3>
<p><a href="https://github.com/timqian/one-goal">timqian/one-goal: A macOS menu bar APP helps you stay focused</a>：MacOS 上的一款目标提醒软件，可以在导航栏上记录下最近的工作目标，保持专注的方向。</p>
<h3>构建 Electron 开发环境</h3>
<p><a href="https://www.webtips.dev/how-to-bundle-your-react-electron-app-by-parcel">How to Bundle your React-Electron App by Parcel - Webtips</a>：介绍了如何配合 Parcel 来构建 Electron 开发环境</p>
<p>###WSL 和 Electron</p>
<p><a href="https://www.beekeeperstudio.io/blog/building-electron-windows-ubuntu-wsl2">Building an Electron App in Windows with WSL 2 and Ubuntu | Beekeeper Studio</a>：介绍如何在 windows 下利用 <code>WSL2</code> 构建和调试 Electron 应用</p>
<h3>web 开发中的字体</h3>
<p><a href="https://imweb.io/topic/5a016f791f0e50753869bfa3">自定义字体 - 腾讯 Web 前端 IMWeb 团队社区 | blog | 团队博客</a>：介绍了在<code>web</code>开发中可以实际应用到的自定义字体技术的使用示例和注意事项。</p>
<h3>字体反爬虫</h3>
<p><a href="https://juejin.cn/post/6844904014866284552">自定义字体知识整理 - 掘金</a>：自定义字体如何加密，如何防止爬虫，看看这一篇知识整理，或许对你有所帮助。</p>
<h3>公开 API 收集</h3>
<p><a href="https://apitracker.io/">Discover the best APIs and SaaS products | API Tracker</a>：收集了国外一系列的免费接口，开发者们或许可以在这里找到适合自己的免费接口。</p>
<h3>图表库</h3>
<p><a href="https://github.com/timqian/chart.xkcd">timqian/chart.xkcd: xkcd styled chart lib</a>：太强了，适用于不那么正式场合的图表数据展示，手绘风格的图让人眼前一亮。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[unsplash 最佳图片资源]]></title>
            <link>https://i5lin.top/blog/post/1516381810</link>
            <guid>1516381810</guid>
            <pubDate>Mon, 02 Jan 2023 13:09:41 GMT</pubDate>
            <description><![CDATA[图片资源、翻译软件、windows软件站、剪贴板工具 - 你值得知道的内容尽在妙才周刊

![](https://images.unsplash.com/photo-1573435567032-ff5982925350?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=]]></description>
            <content:encoded><![CDATA[<p>图片资源、翻译软件、windows软件站、剪贴板工具 - 你值得知道的内容尽在妙才周刊</p>
<p><img src="https://images.unsplash.com/photo-1573435567032-ff5982925350?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2574&q=80" alt=""></p>
<h3>图片资源网站</h3>
<p><a href="https://unsplash.com/">Beautiful Free Images &amp; Pictures | Unsplash</a>：国外的一个超级优质的图片站，这里有个人爱好者和专业的摄影师的作品，无广告可以下载超高清图片资源。其提供了官方 API 可供开发者使用，笔者的 Chrome 扩展《岚》就使用了其 API 。</p>
<h3>Windows 软件站</h3>
<p><a href="http://www.dayanzai.me/">大眼仔旭 - 专注视频剪辑、解压、录屏、思维导图等办公资源分享</a></p>
<h3>翻译软件 Bob</h3>
<p><a href="https://ripperhe.gitee.io/bob/#/">Bob</a>：小而美的翻译软件，仅供 MacOS 系统使用。</p>
<blockquote>
<p>Windows 用户可以勉强用用百度翻译桌面版</p>
</blockquote>
<h3>剪贴板管理工具</h3>
<p><a href="https://maccy.app/">Maccy - macOS clipboard manager</a>：MacOS 系统上超级好用的剪贴板管理软件，可以非常方便的查看剪贴板历史记录，如果你需要来回复制粘贴(笑)，强推。</p>
<h3>终端软件</h3>
<blockquote>
<p>各大系统都有自己默认的 terminal 软件，但是系统自带的软件最大的特点就是 UI 无特色，可定制化的内容不多，最大的优点就是稳定！如果你想试试其他类型的终端软件，以下推荐几个。</p>
</blockquote>
<ul>
<li><a href="https://iterm2.com/">iTerm2 - macOS Terminal Replacement</a> ： 知名、稳定、快速</li>
<li><a href="https://hyper.is/">Hyper™</a> ： 美</li>
<li><a href="https://tabby.sh/">Tabby - a terminal for a more modern age</a> ： 美而全，推荐</li>
<li><a href="https://alacritty.org/">Alacritty</a> ： 快！</li>
</ul>
<p>响应速度极快，支持自定义的组合键，完全本地运行，或许你可以尝试看看。</p>
<h3>编辑器</h3>
<p><a href="https://lapce.dev/">Lapce</a>：Lapce 是 Rust 语言开发的编辑器，速度非常快。但是在生态方面处于原始阶段，想用它代替成熟的编辑器还非常遥远。如果想体验体验，或者单纯使用其作为编辑器，可以试试！</p>
<h3>FFMPEG</h3>
<p><a href="https://bytefreaks.net/gnulinux/bash/ffmpeg-extract-audio-from-webm-to-mp3">ffmpeg: Extract audio from .WEBM to .MP3 – Bytefreaks.net</a>：这篇文章介绍了如何使用<code>ffmpeg</code>将<code>webm</code>转化为<code>mp3</code>资源，笔者在使用<code>youtube-dl</code>下载资源的时候手动转换格式的时候查到的，此前并未下载<code>ffmpeg</code>故无法使用内置的格式转化命令。</p>
<h3>配置文件分享</h3>
<p><a href="https://github.com/youyiqin/dotfiles-public">youyiqin/dotfiles-public: My personal dotfiles about fish / nvm / neovim / tmux</a>：日本开发者<code>devaslife</code>的个人配置分享！大赞强推大神的 YouTube 视频，我看得目瞪口呆。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[循序渐进]]></title>
            <link>https://i5lin.top/blog/post/1516378223</link>
            <guid>1516378223</guid>
            <pubDate>Mon, 02 Jan 2023 13:06:00 GMT</pubDate>
            <description><![CDATA[终端工具、素材资源、设计课程、书籍分享

![](https://images.unsplash.com/photo-1661956602868-6ae368943878?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80)

### 优质的图像素]]></description>
            <content:encoded><![CDATA[<p>终端工具、素材资源、设计课程、书籍分享</p>
<p><img src="https://images.unsplash.com/photo-1661956602868-6ae368943878?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>优质的图像素材资源站点 - Vecteezy</h3>
<blockquote>
<p><a href="https://www.vecteezy.com/">Download Free Vector Art, Stock Photos &amp; Stock Video Footage</a></p>
</blockquote>
<p>Vecteezy 提供免费+收费的优质矢量艺术图，注册即可可以在你的项目或应用中免费使用部分资源。</p>
<h3>前端学习资源</h3>
<p><a href="https://q.shanyue.tech/engineering/#%E8%AF%B7%E6%88%91%E5%96%9D%E6%9D%AF%E5%92%96%E5%95%A1">前端工程化知识体系</a></p>
<h3>Figma Tutorial</h3>
<blockquote>
<p>最火的设计软件</p>
</blockquote>
<p>学一点设计：<a href="https://www.figma.com/resources/learn-design/getting-started/">Learn Design with Figma</a></p>
<h3>谷歌前端入门 HTML/CSS 指南</h3>
<p><a href="https://google.github.io/styleguide/htmlcssguide.html">Google HTML/CSS Style Guide</a></p>
<h3>web 开发者大师 Dr.Axel Rauschmayer 书籍分享</h3>
<p><a href="https://exploringjs.com/">Exploring JS: JavaScript books for programmers</a></p>
<h3>终端补全可视化工具</h3>
<blockquote>
<p><a href="https://fig.io/">Fig</a></p>
</blockquote>
<p>Fig 是一个具有<code>IDE</code>风格的终端补全的开源工具，其支持目前主流的终端软件以及三大<code>shell</code>:</p>
<ul>
<li>bash</li>
<li>fish</li>
<li>zsh</li>
</ul>
<p>并且支持超过<code>300+</code>的 cli 工具补全功能，如果是你终端的重度用户，这个工具绝对不会让你失望。</p>
<p><img src="https://fig.io/images/slideshow/screenshots/scripts.png" alt=""></p>
<p>响应速度极快，支持自定义的组合键，完全本地运行，或许你可以尝试看看。</p>
<h3>前端脚手架 - nextarter-chakra</h3>
<blockquote>
<p><a href="https://github.com/sozonome/nextarter-chakra">sozonome/nextarter-chakra: battery packed template / boilerplate to initialize PWA ready Next.js app with Chakra UI &amp; Typescript setup</a></p>
</blockquote>
<p>印尼开发者<code>sozonome</code>开发的前端脚手架，支持:</p>
<ul>
<li><code>TypeScript</code></li>
<li><code>Chakra-UI</code></li>
<li><code>Next.js</code></li>
<li><code>Eslint/Pretter/husky/lint-staged</code></li>
<li><code>React</code></li>
<li><code>PWA option</code></li>
<li><code>SEO optimization/sitemap</code></li>
<li><code>framer-motion</code></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[起步]]></title>
            <link>https://i5lin.top/blog/post/1516374902</link>
            <guid>1516374902</guid>
            <pubDate>Mon, 02 Jan 2023 13:02:46 GMT</pubDate>
            <description><![CDATA[看了阮一峰前辈的周刊，非常精彩。于是，自己也想记录下自己关注的一些东西，于是我的周刊起步了~

![](https://images.unsplash.com/photo-1661956602153-23384936a1d3?ixlib=rb-4.0.3&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop]]></description>
            <content:encoded><![CDATA[<p>看了阮一峰前辈的周刊，非常精彩。于是，自己也想记录下自己关注的一些东西，于是我的周刊起步了~</p>
<p><img src="https://images.unsplash.com/photo-1661956602153-23384936a1d3?ixlib=rb-4.0.3&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2940&q=80" alt=""></p>
<h3>临时邮件</h3>
<blockquote>
<p><a href="https://temp-mail.org/en/">Temp Mail - Disposable Temporary Email</a></p>
</blockquote>
<p>有时候只是想用一个邮件来注册一个账户，其还有配套的<code>chrome插件</code>：<a href="https://chrome.google.com/webstore/detail/temp-mail-disposable-temp/inojafojbhdpnehkhhfjalgjjobnhomj">Temp Mail - Disposable Temporary Email - Chrome 网上应用店</a>。</p>
<h4>webFont 字体压缩工具</h4>
<blockquote>
<p><a href="https://github.com/aui/font-spider">aui/font-spider: Smart webfont compression and format conversion tool</a></p>
</blockquote>
<p>在 web 开发中，有时只想让部分内容展示特定的字体，但是字体文件整体上是非常大的，使用这个库可以自动分析页面使用的 webFont 并进行按需压缩。</p>
<h3>家用树莓派架设可供外部用户访问的站点</h3>
<blockquote>
<p><a href="https://viggy28.dev/article/setting-up-ghost-in-raspberry-pi-for-free/">Home | Setting up ghost in raspberry pi for free</a></p>
</blockquote>
<p>如果你是一个 web 开发者，自己开发或者部署了一个应用在家里的设备上，可以试试参考本篇博客，利用端口隐射来实现这个需求，笔者此前见过推特上有开发者对外架设了图书分享的应用，甚至是 NAS 影视应用。</p>
<h3>Git Commit 和 emoji ❤️</h3>
<blockquote>
<p><a href="https://gitmoji.dev/">gitmoji | An emoji guide for your commit messages</a></p>
</blockquote>
<p>开发者日常为仓库添加<code>commit</code>时，添加一个让自己心情愉悦的<code>emoji</code>如何？这个应用支持安装<code>pwa</code>，我们可以轻松找到适宜当前<code>commit</code>的<code>emoji</code>。如果你是一个终端爱好者，还可以配合<a href="https://github.com/carloscuesta/gitmoji">carloscuesta/gitmoji: An emoji guide for your commit messages. 😜</a>一起食用。</p>
<h3>创建适宜的 .gitignore 文件</h3>
<blockquote>
<p><a href="https://www.toptal.com/developers/gitignore">gitignore.io - 为你的项目创建必要的 .gitignore 文件</a></p>
</blockquote>
<p>UI 界面可以搜索关键词创建初始化<code>.gitignore</code>文件，笔者比较推荐的是使用其命令行功能，官方提供了不同系统和<code>shell</code>类型的命令功能。举个例子分享：</p>
<h3>Fish</h3>
<p>终端输入：</p>
<pre><code class="language-bash">printf &quot;function gi\n\tcurl -sL https://www.toptal.com/developers/gitignore/api/\$argv\nend\n&quot; &gt; \
~/.config/fish/functions/gi.fish
</code></pre>
<p>创建一个函数文件<code>gi</code>，再在<code>fish</code>的配置文件中添加函数：</p>
<pre><code class="language-bash">function cgi --description &#39;add .gitignore file&#39;
    gi $argv &gt; .gitignore
end
</code></pre>
<p>以后就可以用<code>cgi+关键词</code>创建初始化的<code>.gitignore</code>文件了。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[新年新气象]]></title>
            <link>https://i5lin.top/blog/post/1516214913</link>
            <guid>1516214913</guid>
            <pubDate>Mon, 02 Jan 2023 09:59:08 GMT</pubDate>
            <description><![CDATA[这是2023年的第一篇周刊，我决定把周刊从单独的仓库放到博客站下面，并且存储在github上面。总之，希望新年能坚持更多东西。



![](https://images.unsplash.com/photo-1588943011511-ef303c037195?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8]]></description>
            <content:encoded><![CDATA[<p>这是2023年的第一篇周刊，我决定把周刊从单独的仓库放到博客站下面，并且存储在github上面。总之，希望新年能坚持更多东西。</p>
<p><img src="https://images.unsplash.com/photo-1588943011511-ef303c037195?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1587&q=80" alt=""></p>
<h3>创业游戏</h3>
<blockquote>
<p><code>notacoward</code>:&quot;Entrepreneurship is like one of those carnival games where you throw darts or something.</p>
<p>Middle class kids can afford one throw. Most miss. A few hit the target and get a small prize. A very few hit the center bullseye and get a bigger prize. Rags to riches! The American Dream lives on.</p>
<p>Rich kids can afford many throws. If they want to, they can try over and over and over again until they hit something and feel good about themselves. Some keep going until they hit the center bullseye, then they give speeches or write blog posts about &quot;meritocracy&quot; and the salutary effects of hard work.</p>
<p>Poor kids aren&#39;t visiting the carnival. They&#39;re the ones working it.&quot;</p>
</blockquote>
<p>创业就像狂欢节游戏，你可以扔飞镖什么的。</p>
<p>中产阶级的孩子扔得起。大部分都没打中。有几个击中了目标，得到了一个小奖品。只有极少数射中了中心的靶心，获得了更大的奖励。白手起家！美国梦永存。</p>
<p>有钱人家的孩子可以买得起很多东西。如果他们愿意，他们可以一遍又一遍地尝试，直到他们撞到什么东西，并对自己感觉良好。有些人一直坚持下去，直到他们成为中心靶心，然后他们发表演讲或写博客文章，谈论“精英管理”和努力工作的有益影响。</p>
<p>可怜的孩子们不是来参观嘉年华的，他们才是工作人员。</p>
<h3>微信读书体验卡</h3>
<p><a href="https://weread.qnmlgb.tech/"><a href="https://weread.qnmlgb.tech/">瓦斯组队 - 无限卡 - 微信读书组队</a></a>：利用微信读书的组队机制，快速匹配陌生人组队即可获取不限次数的会员体验卡。</p>
<h3>李志音乐</h3>
<p><a href="https://lizhi.turkyden.com/#/"><a href="https://lizhi.turkyden.com/#/">李志 BB 音乐作品播放器</a></a>：民间李志音乐爱好者＆web开发者开源的在线播放器，站点资源都收集自网络，并且向李志先生发了邮件告知。</p>
<p>另外，支持打包成移动APP，如果你有MacBook也可以单独下载客户端，如果你有特斯拉😂，也提供了特斯拉车载系统应用。</p>
<h3>Web 应用打包</h3>
<p><a href="https://github.com/tw93/Pake"><a href="https://github.com/tw93/Pake">tw93/Pake: 🤱🏻 Simply make any web page a desktop application using Rust. 🤱🏻 很简单的用 Rust 打包网页生成很小的桌面 App</a></a>，已有的打包应用诸如：</p>
<ul>
<li>微信读书</li>
<li>Twitter</li>
<li>李志音乐</li>
<li>YouTube</li>
<li>...</li>
</ul>
<p>开发者可以自己定制自己的需求，小白也可以去下载某些APP，如果还没有打包也可以发起请求。</p>
<h3>安全的RM命令</h3>
<p><a href="https://github.com/nivekuil/rip"><a href="https://github.com/nivekuil/rip">nivekuil/rip: A safe and ergonomic alternative to rm</a></a>：使用<code>Rust</code>写的命令行程序，更快更安全的删除文件或目录的程序，并且支持误删除恢复。</p>
<h3>克隆CP命令</h3>
<p><a href="https://github.com/tarka/xcp">tarka/xcp: An extended `cp`</a>：依然是<code>Rust</code>重写的命令行程序，克隆了系统的<code>cp</code>命令，更快且具有以下功能：</p>
<ul>
<li>展示进度条</li>
<li>支持<code>.gitignore</code>限制不需要复制的文件</li>
</ul>
<p>并且由于底层调用系统机制的优化，其复制大文件更快，我们可以利用<code>alias</code>直接替换掉<code>cp</code>命令。</p>
<h3>JS全文搜索库</h3>
<p><a href="https://lucaong.github.io/minisearch/"><a href="https://lucaong.github.io/minisearch/">MiniSearch</a></a>：这是一个小而美的全文搜索库，可以在浏览器和<code>Node</code>环境下运行，如果你将要使用JS技术栈去做一些全文搜索，可以找到这个库。</p>
<h3>输入法应用匹配</h3>
<p><a href="https://inputsource.pro/zh-CN?utm_medium=email&utm_source=Revue%20newsletter&utm_campaign=%E5%8F%AF%E4%B9%90%E5%91%A8%E6%8A%A5"><a href="https://inputsource.pro/zh-CN?utm_medium=email&utm_source=Revue%20newsletter&utm_campaign=%E5%8F%AF%E4%B9%90%E5%91%A8%E6%8A%A5">Input Source Pro - 优化 macOS 输入法使用体验</a></a>：切换不同的应用时，自动切换为预设的输入法。</p>
<h3>世界国旗资源</h3>
<p><a href="https://seekflag.com/"><a href="https://seekflag.com/">Seek Flag | Flags of the World</a></a>：免费下载全世界的国家的国旗，提供<code>png</code>和<code>svg</code>格式。</p>
<h3>CSS 迷你课程</h3>
<p><a href="https://doc.clickup.com/37465296/d/13qb6g-64/css-mini-course/13qb6g-84/css-mini-course"><a href="https://doc.clickup.com/37465296/d/13qb6g-64/css-mini-course/13qb6g-84/css-mini-course">CSS Mini Course</a></a>，前提是你能上推特。</p>
<h3>油管私有接口</h3>
<p><a href="https://www.npmjs.com/package/youtubei.js"><a href="https://www.npmjs.com/package/youtubei.js">youtubei.js - npm</a></a>：如果有一天，你想利用油管的数据去做一些有趣的事情，可能这个库能帮到很多忙。</p>
<h3>新世代企业论坛</h3>
<p><a href="https://www.trickle.so/"><a href="https://www.trickle.so/">Trickle – A better way to align your team</a></a>：新世代的人或许会喜欢，定位是企业内的员工可以工作和交流，分享大家的想法，设计和交互非常现代化。</p>
<h3>制作猫的照片</h3>
<p><a href="https://uchinoko-maker.jp/"><a href="https://uchinoko-maker.jp/">【公式】うちのこメーカー | 猫イラストを無料で簡単作成！</a></a></p>
<h3>参考</h3>
<ul>
<li>阮一峰周刊</li>
<li>viggo讯息分享</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[谈谈JWT(Json web token) 技术]]></title>
            <link>https://i5lin.top/blog/post/1397548261</link>
            <guid>1397548261</guid>
            <pubDate>Wed, 05 Oct 2022 10:03:30 GMT</pubDate>
            <description><![CDATA[今天记录一下学习到的后端接口认证的知识，JWT 技术。
![](https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGNvZGV8ZW58MHx8MHx8&auto=format&fit=crop&w=700&q=60)
# 前]]></description>
            <content:encoded><![CDATA[<p>今天记录一下学习到的后端接口认证的知识，JWT 技术。
<img src="https://images.unsplash.com/photo-1515879218367-8466d910aaa4?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGNvZGV8ZW58MHx8MHx8&auto=format&fit=crop&w=700&q=60" alt=""></p>
<h1>前言</h1>
<p>我的小项目需要使用一种接口认证机制，为了尽量减小服务器端的资源压力，我选择了近年来非常火热的<code>JWT</code>技术。</p>
<h1>简介</h1>
<p>什么是<code>JWT</code>?</p>
<blockquote>
<p><a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p>
</blockquote>
<p>在其官网的首页上有一段非常显眼的介绍：“JSON Web Token 是一个开放的行业标准（RFC 7519），可以在两方之间安全传输信息”。</p>
<p>如下是一个经过编码的<code>token</code>：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ
.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
</code></pre>
<p>请忽视换行符，<code>token</code>由三个部分组成并且使用<code>.</code>号分隔：</p>
<ol>
<li>头部</li>
<li>载荷对象</li>
<li>验证签名</li>
</ol>
<p>让我们通过一张图片来理解这个过程：</p>
<p>![image-20211101223843693](/Users/yi/Library/Application Support/typora-user-images/image-20211101223843693.png)</p>
<p>上述例子中的：<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code>就是头部数据经过<code>base64</code>编码后的结果。<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</code>则是载体对象经过<code>base64</code>编码后的结果，而<code>SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code>则是通过某种算法对<code>头部 base64 编码</code>+<code>.</code>+<code>载荷对象 base64 编码</code>和秘钥进行加密后的结果。</p>
<h2>JWT 的优缺点</h2>
<h3>优点</h3>
<ul>
<li><p>JWT 具有较好的扩展性，且相对于传统的 Session 方案有不占服务器资源的优势</p>
</li>
<li><p>JWT 的载荷对象中可以存储信息（加密或不加密可视情况而定）</p>
</li>
</ul>
<h3>缺点</h3>
<ul>
<li>易滥用：当载荷对象中存储的信息过多的时候，<code>token</code>将会变得非常冗长，所以需要开发者进行控制，避免滥用于数据交换</li>
<li>载荷和头部对象可以直接通过 base64 进行解码得到明文信息（当然开发者可以进行额外的加密控制，或者使用 https 技术防止 token 泄露）</li>
<li>不支持撤销（可以通过增加服务器端缓存或白名单机制来弥补，但同时也增加了资源消耗）</li>
</ul>
<h2>适用场景</h2>
<ul>
<li>安全要求不高的认证场景</li>
<li>短期或一次性认证需求</li>
</ul>
<h1>Koa 和 Jwt</h1>
<p>我的个人项目使用了<code>Koa</code>框架开发后端接口应用，为了使用<code>JWT</code>的特性我需要安装以下两个包：</p>
<ul>
<li>koa-jwt</li>
<li>jsonwebtoken</li>
</ul>
<p><code>koa-jwt</code>中间件让我们能够设置使用<code>jwt</code>来保护哪些路由，并且将请求头中的<code>token</code>数据解析出来，扩展到<code>ctx</code>上下文中。</p>
<p>显然，我们可以将注册和登录的接口作为白名单，直接提供给所有用户使用，当用户注册或登录成功的时候，服务端通过<code>jsonwebtoken</code>创建一个<code>token</code>并返回给客户端。</p>
<p>此时，客户端可以将之保存在<code>localstorage</code>中，并且使用<code>axios</code>之类的库对请求进行拦截，设置拦截器将<code>token</code>放在请求头上面，形如：</p>
<pre><code class="language-bash">Authorization: Bearer &lt;token&gt;	
</code></pre>
<p>此时，<code>token</code>保存在客户端上，服务端可以通过秘钥和加密算法就能解析到<code>token</code>的信息。</p>
<blockquote>
<p>Koa-jwt 和 jsonwebtoken 的使用方法建议阅读文档。</p>
</blockquote>
<p>网上有一种<code>refresh token</code>的说法，即设置一个访问周期，当用户持续访问服务器时根据访问周期来提供新<code>token</code>来替换旧<code>token</code>，从而让保持有效期内访问的用户延长需要重新登录的时间。</p>
<p>显然这种机制需要设置一个合适的<code>token</code>过期时间和刷新周期，被替换的<code>token</code>在某些时间段依然可以访问服务器。</p>
<p>在不同的场合下选择不同的技术才是解决问题的关键！</p>
<h1>参考</h1>
<ul>
<li><a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></li>
<li><a href="https://jwt.io/introduction">JSON Web Token Introduction - jwt.io</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sass 浅解]]></title>
            <link>https://i5lin.top/blog/post/1397546849</link>
            <guid>1397546849</guid>
            <pubDate>Wed, 05 Oct 2022 10:02:23 GMT</pubDate>
            <description><![CDATA[目前对 sass 编写样式表一知半解，在写手头的项目时十分不顺，效率低下，因此打算花两个小时重学 sass]]></description>
            <content:encoded><![CDATA[<h1>前言</h1>
<p>时至今日，<code>Sass</code>已经可以视为一门编程语言了。笔者目前对 sass 编写样式表一知半解，在写手头的项目时十分不顺，效率低下，因此打算花两个小时重学 sass。</p>
<p>某种意义上而言本文仅仅是笔者对于文档的学习和思索，更好的学习方法依然是阅读文档，但是于我于有兴趣阅读此文的朋友而言都一样，我都希望我们能够有所得。</p>
<h1>大纲</h1>
<ul>
<li>语法</li>
<li>样式规则</li>
<li>变量</li>
<li>操作</li>
<li>模块</li>
<li>断点和混入</li>
</ul>
<h2>语法</h2>
<h3>基础</h3>
<p>sass 支持两种语法，二者可以互相载入，分别是：</p>
<ul>
<li>scss</li>
<li>sass</li>
</ul>
<p>二者的区别从扩展名开始，<code>scss</code>对<code>css</code>的兼容性是最好的，几乎所有的<code>css</code>都是有效的<code>scss</code>写法（除了错误的语法被忽略的那部分），正因如此，此语法广受推崇。</p>
<blockquote>
<p>当你 copy 一段让人拍案叫绝的代码到自己的样式表中时，你什么都不需要做</p>
</blockquote>
<p>笔者喜欢<code>.sass</code>第二种语法，本文内容建议使用<code>.sass</code>来理解。笔者很懒，<code>.sass</code>可以少写些许花括号和分号，唯一需要注意的是<code>.sass</code>对缩进的写法非常严格，不过这不是什么大问题。</p>
<h3>解析样式表</h3>
<blockquote>
<p>A Sass stylesheet is parsed from a sequence of Unicode code points. It&#39;s parsed directly, without first being converted to a token stream.</p>
</blockquote>
<p><code>sass</code>需要通过编译器去编译成<code>css</code>，流行的编译器如下：</p>
<ul>
<li>Dart Sass</li>
<li>LibSass</li>
<li>Ruby Sass</li>
</ul>
<p>通常我们写样式都用不上除了英文和数字外的字符，上述编译器<code>Dart Sass</code>只支持<code>UTF-8</code>字符，只有当我们需要用超过<code>UTF-8</code>字符集的字符来写样式时，才需要考虑不使用<code>Dart Sass</code>。</p>
<p>当编译器遇到无效的语法时，解析会失败并且提供错误信息以便开发者修正错误语法。</p>
<h3>样式表结构</h3>
<p>除了和<code>css</code>类似的样式属性声明外，<code>sass</code>还支持许多增强型特性。</p>
<p><code>sass</code>由一系列的语句块组成，语句块之间可以嵌套其他语句块。</p>
<h4>语句</h4>
<p>我们可以将语句分为四种：</p>
<ul>
<li>css 语句<ul>
<li>样式规则</li>
<li>css @规则，例如 <code>@media</code></li>
<li>Mixin</li>
<li>@at-root</li>
</ul>
</li>
<li>普通语句<ul>
<li>变量声明 <code>$var: value</code></li>
<li>流程控制 <code>@if</code></li>
<li>规则控制 <code>@error</code>、<code>@debug</code>等</li>
</ul>
</li>
<li>顶层语句(样式表顶层或嵌套的 css 顶层)<ul>
<li>文件引入 <code>@import</code></li>
<li>混入 <code>@minxin</code></li>
<li>函数定义 <code>@function</code></li>
</ul>
</li>
<li>其他语句<ul>
<li><code>@extend</code>语句写在样式属性中</li>
</ul>
</li>
</ul>
<p>前者易于理解，跟<code>css</code>更为接近。后者形如则是<code>sass</code>的核心，有了这些才撑起了整体结构。</p>
<p>即使对上述词汇了解不多也不需要担心，接下来逐一拆解学习。</p>
<h4>表达式</h4>
<p>表达式语法即<code>SassScript</code>。</p>
<p>表达式位于属性或变量声明的右侧，表达式产生一个<code>值</code>。显然，任意有效的<code>css</code>值都可以理解为<code>sass</code>的表达式。</p>
<p>在<code>sass</code>中，表达式用于传给<code>mixin</code>或<code>function</code>,亦或配合<code>@if</code>控制流，甚至进行<code>算术运算</code>。</p>
<p>最简单的表达式只表示静态的值，例如：</p>
<ul>
<li>Numbers: 100px</li>
<li>String: &quot;bolder&quot;</li>
<li>Colors: #eee</li>
<li>Booleans: true or false</li>
<li>Lists: 1px 2px 0 1px</li>
<li>Maps: 键值对映射，例如<code>(&quot;color&quot;: red, &quot;font-size&quot;: 12px)</code></li>
</ul>
<p>其他表达式：</p>
<ul>
<li>变量<code>$var</code></li>
<li>函数调用<code>var(--color-bg-1)</code></li>
<li>特殊函数<code>calc(1px + 100%)</code>或<code>url(...)</code></li>
<li>父选择器 <code>&amp;</code></li>
<li><code>!important</code></li>
</ul>
<h3>操作符</h3>
<p><code>sass</code>支持许多操作符语法：</p>
<ul>
<li><code>== or !=</code>比较值</li>
<li><code>+ - * / % </code>数学计算</li>
<li><code>&lt; &lt;= &gt; &gt;=</code>逻辑判断</li>
<li><code>and or not</code>布尔值判断</li>
<li><code>+ - /</code>字符串拼接</li>
<li><code>()</code>优先级控制</li>
</ul>
<h3>注释</h3>
<p><code>sass</code>是编程语言，有注释很正常。</p>
<p>在 <code>scss</code> 中写注释，可以这样写：</p>
<pre><code class="language-scss">// 这个注释不会出现在CSS中

/* 这个将会出现在CSS中，压缩模式下不会有 */

/* CSS中显示插值的计算结果
 * 1 + 1 = #{1 + 1} */

/*! 在压缩模式下也会显示 */

p /* 多行注释可以写在任何允许 */
  /* 使用空格的地方。 */ .sans {
  font: Helvetica,
    // 单行注释也是
    sans-serif;
}
</code></pre>
<p>回到正题，在<code>sass</code>中更简洁：</p>
<pre><code class="language-scss">//  这个注释不会出现在CSS中
    这个也被注释掉了

/*  这个将会出现在CSS中，压缩模式下不会有

/*  CSS中显示插值的计算结果
 *  1 + 1 = #{1 + 1}

/*! 在压缩模式下也会显示

p .sans
  font: Helvetica, /* 内联注释必须是闭合的 */ sans-serif
</code></pre>
<blockquote>
<p>当你打算编写样式库时，可以在文档的最上方使用三斜杠<code>///</code>来开头编写文档，最终<code>SassDoc</code>等工具可以读取并且生成美观的文档。</p>
</blockquote>
<h3>特殊函数</h3>
<p>此前在表达式处提及特殊函数，在此重申之。</p>
<p><code>url()</code>是<code>css</code>中常用的函数，在<code>sass</code>中需要用特殊的逻辑来解析它。简单来看，可以按<code>css</code>规则来调用，也可以使用<code>sass</code>变量或函数调用最后的值来解析。举个例子：</p>
<pre><code class="language-scss">$roboto-font-path: &quot;../fonts/roboto&quot;

@font-face
    // This is parsed as a normal function call that takes a quoted string.
    src: url(&quot;#{$roboto-font-path}/Roboto-Thin.woff2&quot;) format(&quot;woff2&quot;)

    font-family: &quot;Roboto&quot;
    font-weight: 100


@font-face
    // This is parsed as a normal function call that takes an arithmetic
    // expression.
    src: url($roboto-font-path + &quot;/Roboto-Light.woff2&quot;) format(&quot;woff2&quot;)

    font-family: &quot;Roboto&quot;
    font-weight: 300
</code></pre>
<p>此外，还有其他的特殊函数：</p>
<p>css 中的**calc()**跟<code>sass</code>算法冲突，总之一句话，除了<code>sass</code>插值用于动态注入值之外，其他内容都作为原生<code>css</code>内容解析。</p>
<p>举个例子：</p>
<pre><code class="language-scss">.logo
  $width: 800px
  width: $width
  position: absolute
  left: calc(50% - #{$width / 2})
  top: 0
</code></pre>
<p>Sass 中的<code>min()和 max()</code>二者在<code>css</code>支持之前就实现了，当这类特殊函数中不包含除了插值之外的任何<code>SassScript</code>的特性时，解析为<code>css</code>原生函数。</p>
<p>举个例子：</p>
<pre><code class="language-scss">$padding: 12px

.post
  // Since these max() calls don&#39;t use any Sass features other than
  // interpolation, they&#39;re compiled to CSS max() calls.
  // 插值和原生的 env 函数
  padding-left: max(#{$padding}, env(safe-area-inset-left))
  padding-right: max(#{$padding}, env(safe-area-inset-right))


.sidebar
  // Since these refer to a Sass variable without interpolation, they call
  // Sass&#39;s built-in max() function.
  // 变量属于 SassScript
  padding-left: max($padding, 20px)
  padding-right: max($padding, 20px)
</code></pre>
<p>除此之外，还有众多内建函数，我们在配合相关知识点时候再总结。</p>
<h2>变量</h2>
<p><code>$&lt;variable&gt;:&lt;expression&gt; </code>即变量定义，使用<code>$</code>开头进行定义，表达式求值。</p>
<blockquote>
<p>Sass 标识符和变量名都将连字符<code>-</code>和下划线<code>_</code>视为相同的字符。</p>
</blockquote>
<p>任何地方都可以申明变量，<code>sass</code>的变量会被编译，因此一次只能有一个值，可以重新定义同名的变量，使用新值覆盖旧值，再使用新的变量和值，整个过程是命令式的。</p>
<p>在开发<code>sass</code>库时可以使用<code>!default</code>来编写变量默认值，普通开发者则无需关心。</p>
<p>举例：</p>
<pre><code class="language-scss">// _library.sass
$black: #000 !default
$border-radius: 0.25rem !default
$box-shadow: 0 0.5rem 1rem rgba($black, 0.15) !default

code
  border-radius: $border-radius
  box-shadow: $box-shadow
</code></pre>
<pre><code class="language-scss">// style.sass
$black: #222
$border-radius: 0.1rem

@import &#39;library&#39;
</code></pre>
<p>显然，我们在使用他人开发的库时，可以预先定义一些变量来个性化样式表。库的开发者也可以用默认样式兜底。</p>
<p>既然有变量，当然也有<code>变量作用域</code>。</p>
<p>一个<code>sass</code>文件顶层声明的变量是整个文件全局可访问的，并且当这个文件被其他文件引入时，顶层的变量将被共享。</p>
<p>在块中声明的变量却是本地可用的，在当前块内可用，当块内变量和全局变量同名时，在块内的优先级更高。</p>
<p>但是依然有办法灵活应用规则，举个例子：</p>
<pre><code class="language-scss">$variable: first global value;

.content {
  $variable: second global value !global;
  value: $variable;
}

.sidebar {
  value: $variable;
}
</code></pre>
<p>使用<code>!global</code>标志可以显式指定此变量为全局变量。</p>
<p>另外，在<code>流程控制</code>中声明的变量具有特殊的作用域，并且流程控制内只能<code>给外部存在的变量赋值</code>，而不能声明新的变量。</p>
<p>举个<code>scss</code>的例子：</p>
<pre><code class="language-scss">$dark-theme: true !default;
$primary-color: #f8bbd0 !default;
$accent-color: #6a1b9a !default;

@if $dark-theme {
  $primary-color: darken($primary-color, 60%);
  $accent-color: lighten($accent-color, 60%);
}

.button {
  background-color: $primary-color;
  border: 1px solid $accent-color;
  border-radius: 3px;
}
</code></pre>
<p>引入此库的其他文件可以自定义暗色主题来控制当前样式的结果。</p>
<p>还有一个问题，如何判断变量是否存在？<code>sass</code>提供了以下函数：</p>
<ul>
<li>Variable-exists()</li>
<li>Global-variable-exists()</li>
</ul>
<p>二者分别判断当前作用域内变量和全局变量。</p>
<h2>插值</h2>
<p>只要我们需要将表达式的结果嵌入到<code>css</code>块中去，就可以使用<code>#{}</code>包装的表达式，这种语法被称为插值。</p>
<p>我们可以在任何地方使用插值，插值就像表达式替换。<code>sass</code>以一种直白的方式来让插值生效，举个例子：</p>
<pre><code class="language-scss">@mixin corner-icon($name, $top-or-bottom, $left-or-right) .icon-#{$name} background-image:
  url(&quot;/icons/#{$name}.svg&quot;) position: absolute #{$top-or-bottom}: 0 #{$left-or-right}:
  0 @include corner-icon(&quot;mail&quot;, top, right);
</code></pre>
<p>先不论<code>mixin</code>和<code>include</code>是什么，无论你传入什么值过去，编译后将直接在原位置进行替换：</p>
<pre><code class="language-css">.icon-mail {
  background-image: url(&quot;/icons/mail.svg&quot;);
  position: absolute;
  top: 0;
  left: 0;
}
</code></pre>
<blockquote>
<p>需要注意的是，当插值花括号中包含引号时，带引号的字符串周围的引号会被删除。</p>
</blockquote>
<h2>样式规则</h2>
<p>进入正题。</p>
<blockquote>
<p><code>css</code>也已经存在嵌套的草案，很棒。</p>
</blockquote>
<p><code>sass</code>支持嵌套，这是<code>sass</code>随处可见的知识点，但凡看过 sass 的开发者都知道，无需赘述。关键在于：<code>控制嵌套深度 </code>，嵌套很棒但过深的嵌套生成的<code>css</code>代码就越多，三层足以避免过犹不及。</p>
<p>选择器列表支持和组合选择器可以直接使用<code>css</code>语法。</p>
<p>举个例子 🌰：</p>
<pre><code class="language-scss">.enlarge
  font-size: 14px
    margin: 1rem
        top: 2rem
  transition:
    property: font-size
    duration: 4s
    delay: 2s

  &amp;:hover
    font-size: 36px
    &amp; &gt; h1
        color: #333
    &amp;r
        color: purple

    .other
        color: red
</code></pre>
<p>上述<code>enlarge</code>类内嵌套了<code>other</code>类，并且使用了<code>&amp;</code>父节点选择器实现了<code>.enlarge:hover</code>、<code>.enlarge &gt; h1</code>甚至是<code>.enlarger</code>这样的选择器效果。</p>
<p>其中<code>margin</code>属性名还可以视为命名空间嵌套着使用，编译出<code>margin-top: 2rem</code>的样式。</p>
<p>此外，编译器都能对多个父选择器做出判断：</p>
<pre><code class="language-scss">ul, ol
  text-align: left

  &amp; &amp;
    padding:
      bottom: 0
      left: 0
</code></pre>
<p>上述父选择器按顺序进行编译，不必担心<code>ul</code>和<code>ol</code>在使用父选择器时出现顺序异常。</p>
<p><code>&amp;</code>父选择器可以作为判断条件，例如：</p>
<p><code>if(&amp;, &#39;&amp;.app-background&#39;, &#39;.app-background&#39;)</code></p>
<p>当前处于子级范围时，采用前者，否则采用后者。</p>
<blockquote>
<p>即使是 css，选择器就已经非常强大了。</p>
</blockquote>
<p>此外，还可以根据特定的条件去设置属性和值，此时声明一个<code>null</code>作为表达式，最终将不会编译此属性。</p>
<p>举个例子：</p>
<pre><code class="language-scss">$rounded-corners: false

.button
  border: 1px solid black
  border-radius: if($rounded-corners, 5px, null)
</code></pre>
<p>最终的<code>css</code>文件将不包含<code>border-radius</code>属性。</p>
<p><code>css</code>支持<code>自定义属性</code>，也称为<code>css</code>变量。这个机制允许开发者灵活的设置属性，同时<code>JavaScript</code>能够访问这些值。</p>
<p>在<code>sass</code>中对<code>css</code>自定义属性的处理需要关注的核心只有一个：仅有插值是动态的，其他标记都将原样编译为<code>css</code>，举个例子：</p>
<pre><code class="language-scss">$primary: #81899b
$accent: #302e24
$warn: #dfa612
// 插值将顺利转换
:root
  --primary: #{$primary}
  --accent: #{$accent}
  --warn: #{$warn}

  // Even though this looks like a Sass variable, it&#39;s valid CSS so it&#39;s not
  // evaluated.
  // 下一行将原样编译为 css
  --consumed-by-js: $primary
</code></pre>
<p>此外，还需要了解一个非常强大的<code>sass</code>选择器：<code>占位符</code>选择器。</p>
<p>占位符选择器和其他<code>css</code>选择器类似，它以<code>%</code>开头，并且不会包含在<code>css</code>输出中，举个例子：</p>
<pre><code class="language-scss">.alert:hover, %strong-alert
  font-weight: bold


%strong-alert:hover
  color: red
</code></pre>
<p>最终编译的结果如下：</p>
<pre><code class="language-css">.alert:hover {
  font-weight: bold;
}
</code></pre>
<p>但是，我们却可以在<code>sass</code>中引用其内容对其他选择器进行扩展，减少代码量，举个例子：</p>
<pre><code class="language-scss">%toolbelt
  box-sizing: border-box
  border-top: 1px rgba(#000, .12) solid
  padding: 16px 0
  width: 100%

  &amp;:hover
    border: 2px rgba(#000, .5) solid

.action-buttons
  @extend %toolbelt
  color: #4285f4

.reset-buttons
  @extend %toolbelt
  color: #cddc39
</code></pre>
<p>如上所示，<code>.action-buttons</code>和<code>.reset-button</code>都被扩展了，最后的编译结果为：</p>
<pre><code class="language-css">.action-buttons,
.reset-buttons {
  box-sizing: border-box;
  border-top: 1px rgba(0, 0, 0, 0.12) solid;
  padding: 16px 0;
  width: 100%;
}
.action-buttons:hover,
.reset-buttons:hover {
  border: 2px rgba(0, 0, 0, 0.5) solid;
}

.action-buttons {
  color: #4285f4;
}

.reset-buttons {
  color: #cddc39;
}
</code></pre>
<p>显然我们可以灵活编写占位符选择器，并且选择适当的情况下<code>扩展</code>其他选择器，还不用关心占位符选择器这部分代码，因为最终在不引用的情况下会忽略这部分而编译整体。</p>
<h2>模块化</h2>
<p>编程语言模块化可以将复杂的单文件拆分成多个小文件，将复杂环境拆分梳理为若干小环境，降低开发者的心智压力。</p>
<p>按照惯例，开发者将以<code>下划线</code>开头的<code>sass</code>文件视为<code>片段文件</code>，这些片段文件将被<code>@import</code>指令使用，如果不然<code>sass</code>编译器将忽略编译这些片段文件。</p>
<p>一句话，使用下划线开头的文件作为片段文件，在需要用到片段文件的<code>sass</code>文件使用<code>@import</code>指令将之引入，引入时需要<code>忽略下划线</code>。</p>
<blockquote>
<p>css 具有自己的 @import 规则，浏览器在解析到 css 的导入行为时将会发起一个 http 请求获取此目标文件。</p>
</blockquote>
<p><code>sass</code>将会获取目标导入文件，并且将此文件和被导入的文件结合，编译出最终样式表。</p>
<p>当将片段文件导入到目标文件后，目标文件可以使用片段文件中的内容。</p>
<h2>规则</h2>
<p>Sass 的大部分额外功能都是在 CSS 之上添加新<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule">@规则</a></p>
<p>以下是我们可以在日常开发中使用起来的规则：</p>
<ul>
<li>@import 引入样式、mixin、函数、变量</li>
<li>@mixin、@include 增强复用样式块</li>
<li>@function 增强内置函数外的函数功能</li>
<li>@at-root 将样式放入 CSS 文档的根目录中</li>
<li>@error、@warn、@debug 用于调试</li>
<li>@if、@each、@for、@while 控制函数逻辑</li>
</ul>
<p>接着，我们逐一加深这些知识点的印象。</p>
<h3>@import</h3>
<p>原生的<code>css</code>让浏览器呈现时增加<code>http</code>请求，而<code>sass</code>则在编译期间解决问题。</p>
<p>导入多个文件时可以添加逗号作为分隔，使用<code>.sass</code>语法时不需要为<code>URL</code>添加括号。并且导入的文件内容将会放在<code>@import</code>指令出现的位置，但嵌套导入的 mixin、函数、变量依然具有原作用域。</p>
<p>另外，对于导入的文件<code>URL</code>，编译器都能很好的自动进行忽略扩展名的文件查找，并且在路径上统一使用<code>/</code>作为分隔符。开发者不需要为不同平台的地址问题费心思了。</p>
<p>对于加载路径的优先级而言，本地文件的优先级高于<code>node_modules</code>下的库文件。</p>
<p>如果导入的是一个<code>css</code>文件（本地或远程）亦或使用了<code>url()</code>或媒体查询时，最终将会直接作为原生的<code>css</code>导入使用。</p>
<h3>@mixin</h3>
<p>通过<code>@mixin</code>定义一个具名的<code>mixin</code>，通过<code>@include mixinName</code> 使用<code>mixin</code>。</p>
<blockquote>
<p>从笔者个人层面来看，<code>mixin</code>就是<code>sass</code>这门语言的&quot;函数&quot;</p>
</blockquote>
<p><code>mixin</code>能够让我们轻松通过<code>复用</code>机制减少非语义类的使用，并且<code>mixin</code>非常灵活。</p>
<p>接下来我直接看几个<code>mixin</code>及其用法：</p>
<pre><code class="language-scss">@mixin square($size, $radius: 0) width: $size height: $size @if $radius != 0 border-radius:
  $radius .avatar @include square(100px, $radius: 4px);
</code></pre>
<p>如上所示，可以预定义一个<code>mixin</code>，参数支持具有默认值的可选参数，这一点跟<code>JS</code>很像。</p>
<p>再看一个示例：</p>
<pre><code class="language-scss">@mixin square($size, $radius: 0, $n: 1) width: $size height: $size @if $n != 1 border:
  #{$n}px .avatar @include square(100px, $n: 4);
</code></pre>
<p>可以传递具名的参数，这样可以忽略传参的顺序。</p>
<p>再看：</p>
<pre><code class="language-scss">@mixin order($height, $selectors...) @for $i from 0 to length($selectors) #{nth(
    $selectors,
    $i + 1
  )} position: absolute height: $height margin-top: $i * $height @include order(150px, &quot;input.name&quot;, &quot;input.address&quot;, &quot;input.zip&quot;);
</code></pre>
<p>如果最后一个参数以<code>...</code>结尾，即可将传入的额外参数视为一个可以迭代的列表。</p>
<blockquote>
<p>nth 是内建函数</p>
</blockquote>
<p>最终的编译结果为：</p>
<pre><code class="language-css">input.name {
  position: absolute;
  height: 150px;
  margin-top: 0px;
}

input.address {
  position: absolute;
  height: 150px;
  margin-top: 150px;
}

input.zip {
  position: absolute;
  height: 150px;
  margin-top: 300px;
}
</code></pre>
<p>再看一个<code>.scss</code>示例：</p>
<pre><code class="language-scss">@mixin syntax-colors($args...) {
  @debug keywords($args); // (string: #080, comment: #800, $variable: $60b)

  @each $name, $color in keywords($args) {
    pre span.stx-#{$name} {
      color: $color;
    }
  }
}

@include syntax-colors($string: #080, $comment: #800, $variable: #60b);
</code></pre>
<p>传递多个参数，<code>mixin</code>的定义参数位不定键名参数，最终可以使用内建的函数获取到键值对。</p>
<p>再看：</p>
<pre><code class="language-scss">@mixin btn($args...) {
  @warn &quot;The btn() mixin is deprecated. Include button() instead.&quot;;
  @include button($args...);
}
</code></pre>
<p>看到这里，是否能感受到我们可以使用<code>sass</code>很方便的创建某个<code>UI</code>库的样式表，可以为团队创建基础的<code>sass</code>片段。</p>
<p>另外，<code>mixin</code>还支持内容块，只需要在<code>mixin</code>中添加一行<code>@content</code>即可，举个例子：</p>
<pre><code class="language-scss">@mixin hover &amp;: not([disabled]): hover @content .button border: 1px solid black
  @include hover border-width: 2px;
</code></pre>
<p>到这里我已经觉得复杂了，还可以支持多个<code>@content</code>和给内容块传参，善用<code>sass</code>真不容易，需要大量的使用场景和解决问题的经验。</p>
<h3>@function</h3>
<p>通过<code>@function</code>来定义函数，并且可以在任何地方直接调动函数，就像我们使用<code>css</code>原生的函数一样。</p>
<p>此前笔者提及<code>mixin</code>如<code>sass</code>的函数，然而实际上<code>sass</code>的函数由<code>@function</code>定义，二者是单独的概念。</p>
<p>来看一个基础函数<code>pow</code>：</p>
<pre><code class="language-scss">@function pow($base, $exponent) $result: 1 @for $_ from 1 through $exponent $result:
  $result * $base @return $result .sidebar float: left margin-left: pow(4, 3) * 1px;
</code></pre>
<p>如其名，计算乘方。关注函数的标识、参数、结构控制、返回值，这部分跟<code>mixin</code>是一样的。</p>
<p>此外，<code>sass</code>内建了诸多强大的函数方便我们开发使用，针对不同类型有：</p>
<ul>
<li>颜色</li>
<li>列表</li>
<li>映射表</li>
<li>数学模块</li>
<li>meta</li>
<li>选择器</li>
<li>字符串</li>
</ul>
<p><code>sass</code>有诸多语法和数据类型，根据这些数据可以配合这部分内建函数处理问题，例如我们需要调整一个颜色值：</p>
<pre><code class="language-scss">color.adjust($color,
  $red: null, $green: null, $blue: null,
  $hue: null, $saturation: null, $lightness: null,
  $whiteness: null, $blackness: null,
  $alpha: null)
adjust-color(...) //=&gt; color

@debug color.adjust(#6b717f, $red: 15); // #7a717f
@debug color.adjust(#d2e1dd, $red: -10, $blue: 10); // #c8e1e7
@debug color.adjust(#998099, $lightness: -30%, $alpha: -0.4); // rgba(71, 57, 71, 0.6)
</code></pre>
<p>这个内建函数实在是强大而方便，此刻笔者不必赘述，我也非常欠缺使用经验。</p>
<h3>@extend</h3>
<p><code>sass</code>继承指的是让某个选择器继承另一个选择器的样式。关键在于扩展的目标类是否有效，其中的扩展机制能够保证以下几点：</p>
<ul>
<li>不会生成匹配不到任何元素的选择器</li>
<li>它确保复杂的选择器是交错的，这样无论嵌套 HTML 元素的顺序如何，它们都可以工作。</li>
<li>它尽可能地减少冗余选择器，同时仍然确保选择器的特性大于或等于被扩展的选择器的特性。</li>
<li>它知道一个选择器何时匹配另一个选择器所做的一切，并可以将它们组合在一起。</li>
<li>它智能地处理<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Combinators">组合选择器</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通用选择器</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not">:not 选择器</a>。</li>
</ul>
<p>举个例子：</p>
<pre><code class="language-scss">.content nav.sidebar
  @extend .info

// 不会扩展，因为“p”与“nav”不兼容。
p.info
  background-color: #dee9fc

// 没有办法知道.guide和.content的层级关系，因此Sass安全起见会生成两种选择器。
.guide .info
  border: 1px solid rgba(#000, 0.8)
  border-radius: 2px

// Sass知道每个匹配“main”的元素。也匹配“.content”。并避免生成不必要的交错选择器。
main.content .info
  font-size: 0.8em
</code></pre>
<p>最后的结果为：</p>
<pre><code class="language-css">p.info {
  background-color: #dee9fc;
}

.guide .info,
.guide .content nav.sidebar,
.content .guide nav.sidebar {
  border: 1px solid rgba(0, 0, 0, 0.8);
  border-radius: 2px;
}

main.content .info,
main.content nav.sidebar {
  font-size: 0.8em;
}
</code></pre>
<p>最后扩展的结果非常难以理解（对于我来说），在有必要的时候尽可能写让大多数人易于理解的扩展吧。</p>
<h3>调试和信息</h3>
<ul>
<li>@error</li>
<li>@warn</li>
<li>@debug</li>
</ul>
<p>如上所示，都用于在编译时输出信息或者在调试时检查数据。</p>
<h1>参考</h1>
<ul>
<li><a href="http://www.sass-china.com/">Sass 中文文档</a></li>
<li><a href="https://www.sassmeister.com/">SassMeister | The Sass Playground!</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[HTML浅解]]></title>
            <link>https://i5lin.top/blog/post/1397545704</link>
            <guid>1397545704</guid>
            <pubDate>Wed, 05 Oct 2022 10:01:26 GMT</pubDate>
            <description><![CDATA[​ 作为一个 web 开发者，我们需要掌握的 HTML 知识到底应该有多少？HTML 真的如此简单吗，我们是否应该给与其更多的重视？]]></description>
            <content:encoded><![CDATA[<p>​ 带着这些疑问，我决定重新学习<code>HTML</code>知识，如何学习？本文将带着疑问去学习<code>HTML</code>相关的知识，并且做出一定的总结。</p>
<h2>前言</h2>
<p><strong>HTML</strong>（超文本标记语言），也是万维网的核心标记语言，对于现代浏览器来说，<code>HTML</code>已经发展到了第五个版本，在多年的演变和改进之下，许多不合时宜的内容被清除了，同时随着版本更迭也有新的内容添加进来，作为一个 web 开发者，我们需要紧跟技术的发展，保持前瞻性和技术敏感度。</p>
<p>知识无限，时间有限。</p>
<p>忽略掉那些琐碎的片段，我们将从不同的问题开启每一个知识点。</p>
<h2>Q&amp;A</h2>
<h3>1. HTML 和 XML 语法的差别</h3>
<p>HTML（超文本标记语言）和 XML（可扩展标记语言）结构类似，但是在语法上具有以下不同之处：</p>
<ul>
<li>XML 严格区分大小写</li>
<li>XML 具有严格的树状结构，禁止省略结束标记</li>
<li>XML 属性值必须用引号包裹起来，而在 HTML 中则是可选的</li>
<li>XML 所有属性必须具有值，HTML 则允许无值属性（采用默认值）</li>
<li>XML 解析器不会像 HTML 这样过滤空格</li>
<li>XML 没有固定的标记标签，所有标签都是自定义可扩展的</li>
</ul>
<p>二者在作用上也不同：</p>
<ul>
<li>XML 偏向于保存数据，可以被视为持久化结构</li>
<li>HTML 偏向于描述数据结构</li>
</ul>
<p>其他方面：</p>
<ul>
<li>在浏览器中，HTML 文件的媒体类型是<code>text/html</code>，而 XML 的媒体类型则是<code>application/xhtml+xml</code>，不同的<code>MIME</code>类型在浏览器中将会以不同的解析器去解析文档。</li>
</ul>
<h3>2. 简单快速介绍一下 HTML 的知识</h3>
<p>从最简单的一份<code>html</code>文档说起：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;Sample page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Sample page&lt;/h1&gt;
    &lt;br /&gt;
    &lt;p&gt;This is a &lt;a href=&quot;demo.html&quot;&gt;simple&lt;/a&gt; sample.&lt;/p&gt;
    &lt;!-- this is a comment --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如上述示例那样，HTML 文档具有树状结构，每一个节点标签都具备<code>开始标签</code>，但是不一定具有结束标签，标签支持<code>嵌套</code>。</p>
<p>每个标签都可能有属性和值，举个例子：</p>
<pre><code class="language-html">&lt;a href=&quot;url&quot;&gt;somewhere&lt;/a&gt;
</code></pre>
<p>标签具有各自的意义，属性值总是在<code>开始标签</code>内，并且如果属性值不包含特殊字符，则可以省略引号，但是更推荐保留引号，让整体结构的描述更准确。</p>
<p>浏览器通过自己的<code>HTML</code>解析器去解析<code>HTML</code>文档，并且将之转换为<code>DOM（文档对象模型）</code>，这种模型将保存在内存中。</p>
<p><img src="https://i.loli.net/2021/05/24/5e1l7FsB24hyqtR.png" alt="image-20210524205054501"></p>
<p>上图是上述简单文档的<code>DOM</code>树状图形式，<code>DOM</code>提供了诸多<code>API</code>可以让开发者控制和修改<code>DOM</code>的结构。</p>
<blockquote>
<p>我们可以通过：<code>caniuse.com</code>对标签和属性的兼容性进行查询</p>
</blockquote>
<p>又绕回来说上述代码，最基础的上述结构中，可以继续延伸了解一下大部分标签。</p>
<ul>
<li><code>&lt;html&gt;</code> 为根元素，页面唯一</li>
<li><code>&lt;head&gt;</code> 为头部信息标签，页面唯一，内部常嵌套一些补充信息和标题<ul>
<li><code>&lt;meta&gt;</code> 元数据，常用于设置字符集，添加相关名字和描述性内容，常用于提高<code>SEO</code></li>
<li><code>&lt;script&gt;</code> 引入 JavaScript</li>
<li><code>&lt;title&gt;</code> 标题设置</li>
<li><code>&lt;style&gt;</code> 嵌入 Css</li>
<li><code>&lt;link&gt;</code> 外部资源链接</li>
<li><code>&lt;base&gt;</code> 定义页面默认超链接的默认地址和打开方式，建议放在 head 的最前面</li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 页面主体，页面唯一，常用标签全部嵌套在内部。<ul>
<li><code>&lt;h1&gt;~&lt;h6&gt;</code> 设置标题</li>
<li><code>&lt;p&gt;</code> 设置段落文本</li>
<li><code>&lt;a&gt;</code> 超链接</li>
<li><code>&lt;pre&gt;</code>预格式化</li>
<li><code>&lt;q&gt;,&lt;blockquete&gt;</code>长短引用内容</li>
<li><code>&lt;br /&gt;</code>,<code>&lt; hr /&gt;</code> 换行标签和水平线标签</li>
<li><code>&lt;b&gt;</code> 粗体</li>
<li><code>&lt;small&gt;</code>小号字体</li>
<li><code>&lt;i&gt;</code>斜体</li>
<li><code>&lt;rt&gt;</code> 中文发音注释，顶部显示</li>
<li><code>&lt;sub&gt;</code>下标</li>
<li><code>&lt;sup&gt;</code> 上标</li>
<li><code>&lt;iframe&gt;</code>内联框架，替换<code>&lt;frame&gt;</code></li>
<li><code>&lt;cite&gt;</code>标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。默认斜体，引用分离，有助于自动摘录参考的功能。</li>
<li><code>&lt;div&gt;</code> 通用块元素</li>
<li><code>&lt;span&gt;</code> 内联文本元素</li>
<li><code>&lt;textarea&gt;</code> 输入区</li>
<li><code>&lt;input&gt;</code> 输入框<ul>
<li><code>&lt;datalist&gt;</code> 输入框可选值列表</li>
</ul>
</li>
<li><code>&lt;img&gt;</code> 图像</li>
<li><code>&lt;map&gt;</code> 图像区域映射<ul>
<li><code>&lt;area&gt;</code> 定义区域位置和映射目标地址</li>
</ul>
</li>
<li><code>&lt;figure&gt;</code>标记文档中的媒体内容<ul>
<li><code>&lt;figcaption&gt;</code>媒体的标题，常用于媒体标签的上面或者下面</li>
</ul>
</li>
<li><code>&lt;button&gt;</code> 按钮</li>
<li><code>&lt;from&gt;</code> 表单<ul>
<li><code>&lt;fieldset&gt;</code> 表单边框<ul>
<li><code>&lt;legend&gt;</code>表单边框描述，内容标题</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;video&gt;</code> 视频</li>
<li><code>&lt;audio&gt;</code> 音频<ul>
<li><code>&lt;source&gt;</code> 数据源和媒体类型说明，添加多个备用</li>
</ul>
</li>
<li><code>&lt;table&gt;</code> 表格<ul>
<li><code>&lt;col&gt;</code> 配合 <code>&lt;colgroup&gt;</code>为列添加属性</li>
<li><code>&lt;caption&gt;</code> 表格标题</li>
<li><code>&lt;tbody&gt;</code> 表格主体</li>
<li><code>&lt;td&gt;</code>表格单元</li>
<li><code>&lt;th&gt;</code> 表头单元格</li>
<li><code>&lt;tfoot&gt;</code>表格脚注</li>
<li>...</li>
</ul>
</li>
<li><code>&lt;address&gt;</code> 定义作者地址信息</li>
<li><code>&lt;ul&gt;, &lt;ol&gt;</code> 有序和无序列表<ul>
<li><code>&lt;li&gt;</code> 列表项</li>
</ul>
</li>
<li><code>&lt;dl&gt;</code> 定义列表，增加列表的灵活性<ul>
<li><code>&lt;dt&gt;</code> 定义列表标题</li>
<li><code>&lt;dd&gt;</code> 定义描述，通常在标题下方，并且具有缩进</li>
</ul>
</li>
<li><code>&lt;del&gt;</code> 被删除的文本</li>
<li><code>&lt;ins&gt;</code> 默认下划线，定义插入的行内文本</li>
<li><code>&lt;details&gt;</code> 默认不展开的内容隐藏<ul>
<li><code>&lt;summary&gt;</code> details 默认显示的描述信息，不支持<code>IE</code></li>
</ul>
</li>
<li><code>&lt;header&gt;</code> 正文中的标题</li>
<li><code>&lt;nav&gt;</code>旨在封装一组链接，常用于导航栏</li>
<li><code>&lt;footer&gt;</code> 页脚内容</li>
<li><code>&lt;main&gt;</code> 正文主体核心内容区域</li>
<li><code>&lt;article&gt;</code> 文章容器</li>
<li><code>&lt;section&gt;</code> 相关性内容，比如章节、页眉、页脚或文档中的其他部分。</li>
<li><code>&lt;aside&gt;</code> 表示与它周围文本没有密切关系的内容，通常的广告区域、搜索、分享链接。</li>
<li><code>&lt;canvas&gt;</code> canvas 图像容器</li>
<li><code>&lt;embed&gt;</code> 嵌入页面的元素，外部应用，互动插件等等，本意是不属于当前页面的内容，使用时指定外部资源类型。</li>
<li><code>&lt;diakig&gt;</code> 对话框，支持性很差</li>
<li><code>&lt;mark&gt;</code> 类似<code>strong</code>，H5 属性且更为通用</li>
<li><code>&lt;meter&gt;</code>给定的数据范围度量，需要制定相关属性</li>
<li><code>&lt;output&gt;</code>表示输出结果的行内元素</li>
<li><code>&lt;time&gt;</code>标注时间</li>
<li><code>&lt;datetime&gt;</code>标注日期</li>
<li><code>&lt;progress&gt; </code>进度条</li>
<li><code>&lt;select&gt;</code> 下拉列表<ul>
<li><code>&lt;optgroup&gt;</code> 可选组选项<ul>
<li><code>&lt;option&gt;</code> 选项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有<code>HTML</code>短语标签如下：</p>
<table>
<thead>
<tr>
<th><em></th>
<th>呈现为被强调的文本。</th>
</tr>
</thead>
<tbody><tr>
<td><strong></td>
<td>定义重要的文本。</td>
</tr>
<tr>
<td><dfn></td>
<td>定义一个定义项目。</td>
</tr>
<tr>
<td><code></td>
<td>定义计算机代码文本。</td>
</tr>
<tr>
<td><samp></td>
<td>定义样本文本。</td>
</tr>
<tr>
<td><kbd></td>
<td>定义键盘文本。它表示文本是从键盘上键入的。它经常用在与计算机相关的文档或手册中。</td>
</tr>
<tr>
<td><var></td>
<td>定义变量。您可以将此标签与 <code>&lt;pre&gt;</code> 及 <code>&lt;code&gt;</code> 标签配合使用。</td>
</tr>
</tbody></table>
<h3>3. HTML 和语义化有何意义</h3>
<p>我们知道，<code>HTML</code>标签都具有独特的语义，使用合适的标签来组织整体的结构却不是开发者“必须”去做的一件事，在很多情况下，开发者混用不适宜的标签去达到相同的效果屡见不鲜。</p>
<p>清晰的语义能带来良好的页面结构，并且非常有利于搜索引擎和网络爬虫解析页面内容，大大提高页面内容的识别准确性，优化<code>SEO</code>让页面得到更好的传播和搜索权重。</p>
<h3>4. 谈谈 HTML 中的语法错误问题</h3>
<p>HTML 的语法错误的处理措施非常宽松，某种程度上 HTML 语法的灵活性让错误的语法产生了不完整的行为。</p>
<p><code>HTML</code>的语法错误在浏览器中是可以被允许的，不良的语法结构将导致 DOM 语法树的结构不够直观。</p>
<p>来看看如下语法结构：</p>
<pre><code class="language-html">&lt;p&gt;
  &lt;i
    &gt;She dreamt.
    &lt;p&gt;
      &lt;i
        &gt;She dreamt that she ate breakfast.
        &lt;p&gt;
          &lt;i
            &gt;Then lunch.
            &lt;p&gt;&lt;i&gt;And finally dinner.&lt;/i&gt;&lt;/p&gt;&lt;/i
          &gt;
        &lt;/p&gt;&lt;/i
      &gt;
    &lt;/p&gt;&lt;/i
  &gt;
&lt;/p&gt;
</code></pre>
<p>浏览器通过解析器解析此结构最终在 DOM 语法树中的结果如下：</p>
<p><img src="https://i.loli.net/2021/05/26/bfOFlSEG73CZqLn.png" alt="image-20210526223813242"></p>
<p>也许这与我们的期望相去甚远，原来两层的语法树却形成了多层的嵌套结构，我们可以从中看出几个语法错误的特点：</p>
<ul>
<li>HTML 的语法非常宽松，语法错误是可以被允许和正常解析的</li>
<li>错误的语法将在解析后产生意想不到的 DOM 结构，并且很有可能降低性能</li>
</ul>
<h3>5. 简单谈谈你对于 HTML 元标签的理解</h3>
<p><code>HTML</code>文档信息可以在其<code>head</code>标签内使用<code>meta</code>标签进行补充说明，一般的形式是以<code>key/value</code>键值对为结构描述关于文档的额外说明。</p>
<p><code>&lt;meta&gt;</code>不支持嵌套，没有闭合标签，其内容不会再页面显示，通常我们会增加一些额外信息描述，这往往有利于搜索引擎和提高<code>SEO</code>效率，对于机器是可读的</p>
<p><code>meta</code>的有效属性包含以下四个：</p>
<ul>
<li><code>name</code> 属性名</li>
<li><code>content</code>属性值</li>
<li><code>scheme</code> 指定<code>content</code>的格式，但<code>H5</code>不支持</li>
<li><code>http-equiv</code> 把<code>content</code>关联到<code>HTTP</code>头部，例如控制页面刷新时间，设置字符集类型和文档类型</li>
<li><code>charset</code> 字符集</li>
</ul>
<p>以下是我们日常工作中可能会用到的键值对数据，。</p>
<pre><code class="language-html">&lt;head&gt;
  &lt;meta name=&quot;description&quot; content=&quot;博客&quot; /&gt;
  &lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,XML,JavaScript&quot; /&gt;
  &lt;meta name=&quot;author&quot; content=&quot;someone&quot; /&gt;
  &lt;meta name=&quot;revised&quot; content=&quot;Tutorialspoint, 5/27/2021&quot; /&gt;
  &lt;meta charset=&quot;UTF-8&quot; /&gt;
  &lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url = https://www.google.com&quot; /&gt;
&lt;/head&gt;
</code></pre>
<h3>6. HTML 无障碍方面有何了解</h3>
<p>无障碍设计的目标是让健全或者残疾人，年轻人或老年人都可以平等，便捷地获取站点的服务，增加受益群体。</p>
<p>通常，最大的受益人群是不擅长访问互联网的普通人或者视力障碍用户，甚至是听力、精神、肢体障碍用户。</p>
<p><code>W3C</code>推动了无障碍化实施规范，主要的辅助即使包括硬件放大镜或者软件放大镜，盲文显示器和读屏软件等。</p>
<p>在开发的时候，可以采用可读性高的设计方案，甚至是对比度高的字体和图片等。另外，编写语义化的<code>HTML</code>将会对屏幕阅读器非常友好。</p>
<p>在时间充分的情况下，建议遵循<code>WAI-ARIA</code>规范或者<a href="http://www-03.ibm.com/able/guidelines/web/accessweb.html">IBM 无障碍化网站开发检查项(IBM Web accessibility checklist – Version 5.2 )</a>进行开发。</p>
<p>在测试的时候，可以使用<code>webking</code>静态检测工具进行测试。</p>
<h3>7. 关于 HTML 注释的知识点</h3>
<p>对于任何语言来说，注释都是很有必要的，在浏览器中注释将会被忽略，但是对于复杂的页面来说，必要的注释能让阅读源码的人提高阅读效率。</p>
<p><code>HTML</code>使用<code>&lt;!-- ... --&gt;</code>作为注释标签（注意，边界不能有多余的空格，否则注释将被视为普通字符串），注释可以跨行。</p>
<p>还有一种注释被称为条件注释：<code>&lt;!--[if IE 8]&gt; ... &lt;![endif]--&gt;</code>，这种注释在<code>IE</code>中能被有效识别，在其他浏览器中被忽略，因此尝尝被用于为<code>IE</code>浏览器设置兼容性属性。</p>
<blockquote>
<p><code>&lt;comment&gt;</code>标签内部也可以被视为注释（IE 浏览器有效），但是在<code>HTML5</code>中已经无效</p>
</blockquote>
<p>在一些旧浏览器中，依然支持如下两种注释：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Commenting Style Sheets&lt;/title&gt;
    &lt;style&gt;
      &lt;!-- .example {
        border: 1px solid #4a7d49;
      }
      //--&gt;
    &lt;/style&gt;
    &lt;script&gt;
      &lt;!--
      document.write(&quot;Hello World!&quot;);
      //--&gt;
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class=&quot;example&quot;&gt;Hello , World!&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>但是在现代浏览器中，上述<code>JS</code>和<code>CSS</code>部分注释都无效。</p>
<h3>8. 对于 img 标签的理解</h3>
<p><code>img</code>标签必须设置<code>src</code>和<code>alt</code>属性，添加具有实际意义的<code>alt</code>属性可以让页面更友好。</p>
<p><code>img</code>是替换内联元素，可以理解为<code>inline-block</code>。</p>
<p>可以提前为<code>img</code>标签添加<code>width</code>和<code>height</code>属性值和对齐方向属性<code>align</code>(H5 已弃用)，如此一来在加载过程中也能具有稳定的宽高显示，从而保证页面的稳定。如果要实现固定的宽高比，自适应宽高比，则可以预设宽高值之一为固定值，另一个为<code>auto</code>。</p>
<blockquote>
<p><code>img</code>此类自闭合标签是无法在内部嵌套子元素的，因此也就没法使用伪类<code>::before</code>和<code>::after</code></p>
</blockquote>
<p><code>img</code>标签的事件监听如下：</p>
<ul>
<li><code>onload</code>: 图像顺利加载完成</li>
<li><code>onerror</code>: 图像资源 404、403、500、请求超时或者返回的资源不是有效的图片</li>
<li><code>onabort</code>: 图像加载被强制停止，例如主动点击浏览器<code>stop</code>按钮</li>
</ul>
<p><code>HTML5</code>的趋势之一，就是减少元素标签的属性值，关于样式的部分尽可能使用<code>CSS</code>文件来描述。</p>
<p>另外，<code>img</code>支持<code>usemap</code>属性，配合<code>map</code>标签内嵌<code>area</code>可以实现点击图片不同区域跳转到不同的目标区域或者地址的功能。</p>
<h3>9. 列举几个 HTML 最佳实践</h3>
<ul>
<li>编写有效可读的<code>DOM</code><ul>
<li>全部小写</li>
<li>保持缩进</li>
<li>自动关闭标签</li>
<li>避免过渡注释</li>
<li>组织<code>DOM</code>，尽量减少元素</li>
</ul>
</li>
<li>尽量不使用内联样式和内联脚本，内联的样式必须是关键样式（渲染页面顶部所需的最小 CSS 集）</li>
<li>将脚本标签放在 body 底部</li>
<li>照顾无障碍用户，使用意义明确的标签和描述性属性值</li>
<li>正确使用 title 和 meta 标签，增强<code>SEO</code></li>
<li>压缩文件和使用<code>CDN</code>加速</li>
<li>对数据交互进行验证，永远不要相信用户的输入，提高应用的安全性</li>
</ul>
<h3>10. 谈谈你所理解的 table 标签</h3>
<p>曾经开发者们使用表格进行布局，现在<code>table</code>标签更纯粹了，绝大多数用来展示表格数据。</p>
<p>表格允许开发者们将图片、图像、链接等数据排列到单元格的行和列中。</p>
<p>一个表格标签，内部嵌套着行盒子<code>tr</code>(table row)和单元格<code>td</code>。如果有必要，可以添加一行<code>th</code>表格列标题。</p>
<p>甚至是使用<code>thead</code>、<code>tbody</code>、<code>tfoot</code>将整体结构拆开：</p>
<pre><code class="language-html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Month&lt;/th&gt;
      &lt;th&gt;Savings&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;January&lt;/td&gt;
      &lt;td&gt;$100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;February&lt;/td&gt;
      &lt;td&gt;$80&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;Sum&lt;/td&gt;
      &lt;td&gt;$180&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
&lt;/table&gt;
</code></pre>
<p>表格标签支持多属性控制样式，但是推荐使用<code>CSS</code>控制样式。</p>
<h3>11. 关于列表</h3>
<p>列表分为三种：</p>
<ul>
<li>有序列表 <code>ol</code></li>
<li>无序列表<code>ul</code></li>
<li>自定义列表 <code>dl</code></li>
</ul>
<p>而非自定义列表项则统一使用<code>li</code>,列表可以使用类型属性<code>type</code>和排序起始属性<code>start</code>控制列表项前面的标志。</p>
<p>自定义列表则使用<code>dt</code>作为列表标题，<code>dd</code>作为列表项，且默认存在缩进。</p>
<p>如果需要对列表前的类型样式做修改，则可以使用<code>list-style-type</code>设置浏览器默认支持的几个元素。</p>
<p>如果需要自定义样式，则可以配合伪类<code>::marker</code>使用。</p>
<p>甚至只要是<code>display: list-item</code>且可内嵌子元素的标签，都支持左边自定义一个显示顺序内容，合理使用<code>counter()</code>可以为多个项设置计算后的顺序前缀内容，这对于创建菜单序号和级联序号非常有用。</p>
<h3>12. 超链接</h3>
<p>超链接可以在用户点击链接后进行当前页面跳转或打开新的标签页进行跳转，为用户提供不同站点之间的导航功能，开发者可以通过<code>a</code>标签创建超链接，点击超链接后的行为取决于 <code>a</code>标签的<code>target</code>属性值。</p>
<p>可以为<code>target</code>设置以下几个不同属性值：</p>
<ul>
<li><code>_blank</code>：在新的浏览器标签页打开链接的地址</li>
<li><code>_self</code>：在相同的<code>frame</code>内打开链接地址（默认值）</li>
<li><code>_parent</code>：在父级<code>frame</code>打开链接地址</li>
<li><code>_top</code>：在当前标签顶层<code>body</code>下打开链接地址（chrome 将会提示离开当前页面）</li>
<li><code>targetframe</code>：在目标<code>frame</code>内打开链接地址</li>
</ul>
<p>除了作为导航外，还可以实现下载功能：</p>
<pre><code class="language-html">&lt;a href=&quot;large.jpg&quot; download&gt;下载&lt;/a&gt;
</code></pre>
<blockquote>
<p>IE 不支持<code>dowload</code>属性</p>
</blockquote>
<p>提供一个<code>download</code>属性让浏览器处理下载功能，并且可以为<code>download</code>属性提供值作为下载的文件名。</p>
<p>但是此方案在跨域场景下各厂家实现区别很大，因此不同源的方案不如使用<code>download.js</code>这个第三方库。</p>
<p>另外，我们在使用邮件类型的地址的时候，需要为<code>href</code>属性值之前添加协议类型：<code>mailto:</code>，例如：</p>
<pre><code class="language-html">&lt;a href=&quot;mailto: abc@example.com&quot;&gt;Send Email&lt;/a&gt;
</code></pre>
<p>浏览器对此链接的点击行为做出反应，调用默认的邮件处理程序预置目标邮件地址，并且可以在<code>mail</code>地址后添加参数，邮件处理程序会解析类似<code>主题</code>或<code>body</code>的预置内容。</p>
<h3>13. Frames</h3>
<p>浏览器可以通过创建不同的<code>Frame</code>分割视图区域，并且每个<code>Frame</code>有单独的<code>HTML</code>结构，浏览器标签所有的<code>Frame</code>的集合被称为<code>frameset</code>。</p>
<blockquote>
<p><code>frameset</code>代替<code>body</code>标签，定义页面的行与列的布局。</p>
</blockquote>
<p>这种技术的缺点也很明显：</p>
<ul>
<li>小屏幕设备显示功能效果不好，难以让分割视图的特性发挥效果。</li>
<li>不同分辨率的终端显示效果可能不同</li>
<li>浏览器的返回按钮可能会出乎意料，甚至无法实现用户想要的效果</li>
<li>少数浏览器不支持此标签</li>
<li>跨<code>Frame</code>通信较为复杂</li>
</ul>
<p>示例:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;HTML Frames&lt;/title&gt;
  &lt;/head&gt;

  &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;
    &lt;frame name=&quot;left&quot; src=&quot;https://www.baidu.com&quot; /&gt;
    &lt;frame name=&quot;center&quot; src=&quot;https://www.baidu.com&quot; /&gt;
    &lt;frame name=&quot;right&quot; src=&quot;https://www.baidu.com&quot; /&gt;

    &lt;noframes&gt;
      &lt;body&gt;
        Your browser does not support frames.
      &lt;/body&gt;
    &lt;/noframes&gt;
  &lt;/frameset&gt;
&lt;/html&gt;
</code></pre>
<p>还有一个标签：<code>iframe</code>也是提供一个内嵌的<code>frame</code>功能，不过它可以脱离<code>frameset</code>使用，更具有灵活性。</p>
<p>这种技术的应用较为少见，请谨慎使用（笔者在广告功能中常能见到其踪影）。</p>
<h3>14. 字体滚动</h3>
<p><code>marquee</code>的兼容性良好，但是此元素已经不再推荐使用，规范随时可能删除此标签，开发者们更应该通过<code>CSS</code>动画来实现文字滚动。</p>
<h3>15. HTML 通用属性</h3>
<blockquote>
<p>在 base、head、html、meta、param、script、style、title 元素上无效</p>
</blockquote>
<p>H5 之前有五个除了上述几个元素外其他所有元素共有的可用属性：</p>
<ul>
<li>class</li>
<li>id</li>
<li>style</li>
<li>title</li>
<li>tabindex</li>
<li>accesskey</li>
</ul>
<p>前四者较为常用，后两者却容易被忽视。<code>tabindex</code>属性用于获取或指定当前元素的<code>tab</code>键激活顺序，其值范围为：<code>0~32767</code>。</p>
<p>如果不设置，则默认值是 0，并且按出现顺序进行跳转，但是可以设置值为<code>-1</code>，使得元素不能被<code>TAB</code>键访问，如果某些元素是隐藏的，在其未显示之前不应该被<code>TAB</code>键访问到，因此可以设置<code>tabindex=-1</code>。</p>
<blockquote>
<p>如果为<code>div</code>设置了<code>tabindex</code>，则其内部嵌套的元素如果没有设置<code>tabindex</code>，则无法通过方向键跳转。</p>
</blockquote>
<p>如果针对某些元素设置了<code>tabindex</code>，则<code>tab</code>键将从大到小进行跳转，慎用此特性以免给惯用快捷键访问的用户造成困扰，但如果良好地设计<code>tabindex</code>，则可以提供良好的无障碍访问功能。</p>
<p>同样的，<code>accesskey</code>也容易被人忽略，即使其功能强大。</p>
<p>我们可以为元素设置<code>accesskey</code>的值，然后通过不同系统的浏览器快捷键+此属性的值进行快速访问。</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/image-20210616060934949.png" alt="image-20210616060934949"></p>
<blockquote>
<p><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-accesskey/comment-page-1/#comment-414139">HTML accesskey 属性与 web 自定义键盘快捷访问 « 张鑫旭-鑫空间-鑫生活</a></p>
</blockquote>
<p>如果你喜欢<code>vimium</code>的功能，我猜这个属性的功能能够让你很开心。但是很多应用都没有使用到这个属性，这是无障碍访问功能的一部分，常常被人忽视，使其看起来犹如屠龙之技。</p>
<p>并且不同浏览器之间快捷键不同，对于元素的交互行为也不一样，这两个缺陷使其应用性大打折扣。浏览器快捷键和操作系统之间的影响可以从上图中看出端倪，而行为上的不一致，最简明的例子就是<code>IE</code>浏览器和<code>chrome</code>浏览器之间对<code>&lt;a&gt;</code>元素的行为不一致。前者只是让其获得焦点，后者却可以触发点击行为。</p>
<p><a href="https://www.npmjs.com/package/accesskey">accesskey - npm</a>这里有一个支持增强<code>accesskey</code>功能和处理一致性行为的第三方库，或许以后用得上。</p>
<blockquote>
<p>不过话说回来，这个属性提醒了我可以在<code>electron</code>技术上使用这个功能，这样就可以减少使用系统快捷键绑定的逻辑代码。</p>
</blockquote>
<p><code>HTML5</code>版本出来之后，新增了部分全局属性：</p>
<ul>
<li>contenteditable：是否可编辑</li>
<li>Data-*：自定义的元素数据存储，可以配合<code>JavaScript</code>或者<code>CSS</code>属性选择器使用</li>
<li>draggable：实验中的属性，是否可以拖动</li>
<li>dropzone：较为少见的属性，不如使用此名第三方库（<a href="https://github.com/dropzone/dropzone">dropzone/dropzone: Dropzone is an easy to use drag'n'drop library. It supports image previews and shows nice progress bars.</a>）</li>
<li>hidden：常用</li>
<li>spellcheck：拼写检查，也是实验中的功能</li>
</ul>
<h3>16. 字体知识</h3>
<p>字体是相对于操作系统而言的，不同操作系统默认支持某些特定的字体，因此在样式表中我们可以指定多种字体以支持不同的操作系统，如果没有指定字体，则使用系统默认的字体。</p>
<p>CSS 定义了 5 个常用的字体名称: <code>serif, ``sans-serif, ``monospace</code>, <code>cursive,</code>和 <code>fantasy. </code>这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。</p>
<p>示例样式如下：</p>
<pre><code class="language-css">p {
  font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif;
}
</code></pre>
<p>提供了三种字体，前面的优先，如果系统不支持此字体则一次往后递增，最后使用默认字体。</p>
<p>我们可以使用<code>@font-face</code>自定义字体：</p>
<pre><code class="language-css">@font-face {
    font-family: &lt;fontFamily&gt;; /* 自定义的字体名称; */
    src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;  /* 自定义的字体的存放路径、格式; */
    [font-weight: &lt;weight&gt;]; /*  是否为粗体 */
    [font-style: &lt;style&gt;]; /*  定义字体样式，如斜体 */
}
</code></pre>
<p>字体具有不同的格式，源文件格式可能会是：</p>
<ul>
<li>.tff</li>
<li>.otf</li>
</ul>
<p>前者字体格式值为<code>TrueType</code>，后者为<code>OpenType</code>，甚至还有：</p>
<ul>
<li>Embedded Open Type (.eot)</li>
<li>Web Open Font Format (.woff)</li>
</ul>
<p>为了保证兼容性，可以同时提供多种自定义字体：</p>
<pre><code class="language-css">@font-face {
  font-family: &quot;myFont&quot;;
  src: url(&quot;myFont.eot&quot;); /* IE9 Compat Modes */
  src: url(&quot;myFont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), /* IE6-IE8 */
      url(&quot;myFont.woff&quot;) format(&quot;woff&quot;); /* Modern Browsers */
}
</code></pre>
<p>自定义字体的另一个广泛使用案例：<code>图标字体</code>。</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/image-20210618003909597.png" alt="image-20210618003909597"></p>
<p>图标字体可以很方便的配合伪类使用，并且非常灵活，开发者可以轻松修改其颜色和大小等。另外，兼容性很好，在某些需要兼容<code>IE</code>的项目中可以放心使用。</p>
<p>使用图标字体还有以下几个优点：</p>
<ul>
<li>轻松替换</li>
<li>不会失真</li>
<li>便捷，可压缩</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ECMAScript 2022新规范]]></title>
            <link>https://i5lin.top/blog/post/1397544441</link>
            <guid>1397544441</guid>
            <pubDate>Wed, 05 Oct 2022 10:00:26 GMT</pubDate>
            <description><![CDATA[一年一度的ECMAScript规范发布，看看今年有什么新内容！

## 前言

`ECMAScript` 是标准化的 `JavaScript` 语言，于 1997 年发布了第一版，现已发展成为世界上使用最广泛的通用编程语言之一。

`ECMAScript 2022 Language`是 ECMAScript 语言规范的第 13 版，因此我们也可以称之为`ES13`!

那么，今年新]]></description>
            <content:encoded><![CDATA[<p>一年一度的ECMAScript规范发布，看看今年有什么新内容！</p>
<h2>前言</h2>
<p><code>ECMAScript</code> 是标准化的 <code>JavaScript</code> 语言，于 1997 年发布了第一版，现已发展成为世界上使用最广泛的通用编程语言之一。</p>
<p><code>ECMAScript 2022 Language</code>是 ECMAScript 语言规范的第 13 版，因此我们也可以称之为<code>ES13</code>!</p>
<p>那么，今年新增了哪些内容呢？</p>
<h3>类增强</h3>
<p>简单来说有以下三点：</p>
<ul>
<li>属性可以通过以下方式创建<ul>
<li>公共的实例字段</li>
<li>静态的公共字段</li>
</ul>
</li>
<li>新增私属性插槽（井号）<ul>
<li>私有字段（私有实例字段和私有静态字段）</li>
<li>私有方法和访问器（非静态）</li>
</ul>
</li>
<li>静态的初始化块</li>
</ul>
<p>直接看代码：</p>
<pre><code class="language-js">class MyClass {
  instancePublicField = 1; // 公共实例字段
  static staticPublicField = 2; // 静态公共字段

  #instancePrivateField = 3; // 私有实例字段
  static #staticPrivateField = 4; // 静态私有字段

  #nonStaticPrivateMethod() {}
  get #nonStaticPrivateAccessor() {} // 非静态私有访问器
  set #nonStaticPrivateAccessor(value) {}

  static #staticPrivateMethod() {} // 私有静态方法
  static get #staticPrivateAccessor() {} // 静态访问器
  static set #staticPrivateAccessor(value) {}

  static {
    // 静态的初始化块
  }

    constructor(value) {
    this.property = value; // 公共实例字段
  }
}
</code></pre>
<p>举一个静态初始化块的例子：</p>
<pre><code class="language-js">class Translator {
  static translations = {
    yes: &#39;ja&#39;,
    no: &#39;nein&#39;,
    maybe: &#39;vielleicht&#39;,
  };
  static englishWords = [];
  static germanWords = [];
  static { // (A)
    for (const [english, german] of Object.entries(this.translations)) {
      this.englishWords.push(english);
      this.germanWords.push(german);
    }
  }
}
</code></pre>
<p>通过使用静态初始化块，我们可以将所有类相关的代码放在类的内部。</p>
<p>上述例子中，可以将初始化两个<code>word</code>数组的过程优化到静态初始化块内部，从而实现我们需要的效果，如果需要还可以访问私有插槽属性。</p>
<p>需要注意的是：</p>
<ul>
<li>一个类可以有多个静态初始化块</li>
<li>静态初始化块和静态属性可以交错初始化</li>
<li>超类（superclass）的静态初始化块在子类的静态初始化块之前执行</li>
</ul>
<p>此外，类的私有化属性插槽可以通过<code>in</code>操作符检查，举个例子：</p>
<pre><code class="language-js">class ClassWithPrivateSlot {
  #privateSlot = true;
  static hasPrivateSlot(obj) {
    return #privateSlot in obj;
  }
}

const obj1 = new ClassWithPrivateSlot();
assert.equal(
  ClassWithPrivateSlot.hasPrivateSlot(obj1), true
);

const obj2 = {};
assert.equal(
  ClassWithPrivateSlot.hasPrivateSlot(obj2), false
);
</code></pre>
<h3>顶层 await</h3>
<p>规范新增顶层<code>await</code>支持，现在我们可以直接在模块内使用顶层<code>await</code>，而不必再额外进入异步函数内再使用<code>await</code>。</p>
<p>看实例：</p>
<pre><code class="language-js">const res = await fetch(&quot;https://jsonplaceholder.typicode.com/todos/1&quot;).then(
  (response) =&gt; response.json()
);

console.log(&quot;res is:&quot;, res);
</code></pre>
<p>保存上述内容为文件<code>index.mjs</code>，使用<code>node v17.5</code>以上版本或<code>bunjs</code>直接运行：</p>
<p><code>node index.mjs</code>即可直接获取到输出。</p>
<p>那么，我们可以在什么地方使用这个特性呢？举个例子：</p>
<pre><code class="language-js">// first.mjs
const response = await fetch(&#39;http://example.com/first.txt&#39;);
export const first = await response.text();

// main.mjs
import {first} from &#39;./first.mjs&#39;;
import {second} from &#39;./second.mjs&#39;;
assert.equal(first, &#39;First!&#39;); // true
assert.equal(second, &#39;Second!&#39;); // true
</code></pre>
<p>有了顶层<code>await</code>，我们可以像使用同步导出那样直接导出异步的值。</p>
<p>大致等同于以下代码：</p>
<p><code>first.mjs</code>:</p>
<pre><code>export let first;
export const promise = (async () =&gt; { // (A)
  const response = await fetch(&#39;http://example.com/first.txt&#39;);
  first = await response.text();
})();
</code></pre>
<p><code>main.mjs</code>:</p>
<pre><code>import {promise as firstPromise, first} from &#39;./first.mjs&#39;;
import {promise as secondPromise, second} from &#39;./second.mjs&#39;;
export const promise = (async () =&gt; { // (B)
  await Promise.all([firstPromise, secondPromise]); // (C)
  assert.equal(first, &#39;First content!&#39;);
  assert.equal(second, &#39;Second content!&#39;);
})();
</code></pre>
<p>方便了不少，不是吗？</p>
<h3>error.cause</h3>
<p>为<code>Error</code>及其子类添加<code>cause</code>属性，更方便地传递错误原因，增强传递错误信息的能力。</p>
<pre><code class="language-js">function readFiles(filePaths) {
  return filePaths.map(
    (filePath) =&gt; {
      try {
        // ···
      } catch (error) {
        throw new Error(
          `While processing ${filePath}`,
          {cause: error}
        );
      }
    });
}
</code></pre>
<p>现在，可以访问错误对象的<code>cause</code>属性获取更多详情。</p>
<h3>.at()</h3>
<p>就像使用<code>python</code>一样使用<code>JavaScript</code>，通过下标访问数组变得容易，具有显式的函数支持，此外跟直接使用<code>[]</code>访问不一样的是，<code>.at()</code>支持传负数参数进行逆序取值。</p>
<h3>正则表达式Flag：/d</h3>
<p>看例子：</p>
<pre><code class="language-js">const matchObj = /(a+)(b+)/d.exec(&#39;aaaabb&#39;);

assert.equal(
  matchObj[1], &#39;aaaa&#39;
);
assert.deepEqual(
  matchObj.indices[1], [0, 4] // (A)
);

assert.equal(
  matchObj[2], &#39;bb&#39;
);
assert.deepEqual(
  matchObj.indices[2], [4, 6] // (B)
);
</code></pre>
<p>通过<code>d</code>执行的正则表达式匹配，可以得到匹配的元素的起始下标。</p>
<h3>Object.hasOwn(obj, propKey)</h3>
<p><code>Object.hasOwn(obj, propKey)</code>提供了一种安全的方式通过属性<code>key</code>检查对象是否含有非继承的目标属性。</p>
<pre><code class="language-js">const proto = {
  protoProp: &#39;protoProp&#39;,
};
const obj = {
  __proto__: proto,
  objProp: &#39;objProp&#39;,
}

assert.equal(&#39;protoProp&#39; in obj, true); // (A)

assert.equal(Object.hasOwn(obj, &#39;protoProp&#39;), false); // (B)
assert.equal(Object.hasOwn(proto, &#39;protoProp&#39;), true); // (C)
</code></pre>
<h2>最后</h2>
<p>众所周知：</p>
<p><code>JavaScript</code>和<code>ECMAScript</code>的区别在于，前者是一个不同平台实现的编程语言，后者是这门语言的标准规范，平台基于此规范实现这门语言。</p>
<p><code>ECMAScript</code>由<code>TC39</code>标准委员会设计，其成员来自各大科技公司和其他平台等等，每年都会在年中发布最新的规范。</p>
<p>不同的提案经过四个阶段，最终才会进入规范，在进入规范之前不建议使用，因为其始终是不稳定的，关注每年的新增内容即可。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Babel 7: polyfill方案浅解 ]]></title>
            <link>https://i5lin.top/blog/post/1397543780</link>
            <guid>1397543780</guid>
            <pubDate>Wed, 05 Oct 2022 09:59:52 GMT</pubDate>
            <description><![CDATA[前端工程化中，使用 babel 对新语法和 API 预置 polyfill 是非常流行的做法之一，但之前笔者对这个过程和其中使用到的插件不够了解，因此在网上搜寻了一些博客和知识分享，学习一番，再次总结一下。

## 前言

本文将对`babel7`的语法转换和`polyfill`的相关知识进行分析，主要内容为`@babel/preset-env`和`plugin-transform-run]]></description>
            <content:encoded><![CDATA[<p>前端工程化中，使用 babel 对新语法和 API 预置 polyfill 是非常流行的做法之一，但之前笔者对这个过程和其中使用到的插件不够了解，因此在网上搜寻了一些博客和知识分享，学习一番，再次总结一下。</p>
<h2>前言</h2>
<p>本文将对<code>babel7</code>的语法转换和<code>polyfill</code>的相关知识进行分析，主要内容为<code>@babel/preset-env</code>和<code>plugin-transform-runtime</code>，Babel 7.4 之后不再推荐使用<code>@babel/polyfill</code>。</p>
<h2>Preset-env</h2>
<blockquote>
<p>Preset-env 会污染全局环境。</p>
</blockquote>
<p>babel 7 版本推荐使用<code>@babel/preset-env</code>代替以往的诸多<code>polyfill</code>方案，现今我们可以使用<code>preset-env</code>简单地实现语法和功能特性的需求。</p>
<blockquote>
<p>@babel/preset-env is a smart preset that allows you to use the latest JavaScript without needing to micromanage which syntax transforms (and optionally, browser polyfills) are needed by your target environment(s).</p>
</blockquote>
<p>可知，<code>preset-env</code>可以转换新语法，甚至可以配置转换新的<code>API</code>，通过配置其可选项来实现功能支持。</p>
<p><code>@babel/preset-env</code>有三个常用的关键可选项:</p>
<ul>
<li><p>targets</p>
</li>
<li><p>useBuiltIns</p>
</li>
<li><p>corejs</p>
</li>
</ul>
<h3>target</h3>
<p>首先是<code>targets</code>，这个字段可以填写<code>browserslist</code>的查询字符串，官方推荐使用<code>.browserslistrc</code>文件去指明编译的<code>target</code>，这个配置文件还可以和<code>autoprefixer</code>、<code>stylelint</code>等工具一起共享配置。</p>
<p>所以某种程度上不推荐在<code>.babelrc</code>的<code>preset-env</code>配置中直接使用<code>targets</code>进行配置。</p>
<blockquote>
<p>如果<code>preset-env</code>中指明<code>ignoreBrowserslistConfig</code>，则忽略<code>.browserslistrc</code>的配置项。</p>
</blockquote>
<h3>useBuiltIns</h3>
<p>其次是用于指定<code>polyfill</code>方案的<code>useBuiltIns</code>，其默认值是<code>false</code>，在不主动<code>import</code>的情况下不使用<code>preset-env</code>来实现<code>polyfills</code>，只使用其默认的语法转换功能。</p>
<blockquote>
<p>如果使用默认值<code>false</code>，则应该避免在入口文件引入<code>polyfill</code>，使得打包体积过大。</p>
</blockquote>
<p>但是如果我们需要使用其<code>polyfill</code>功能，则可以选择两种方式：</p>
<ul>
<li>entry</li>
<li>usage</li>
</ul>
<p><code>entry</code>指的是将会根据浏览器目标环境(<code>targets</code>)的配置，引入全部浏览器暂未支持的<code>polyfill</code>模块，无论在项目中是否使用到。</p>
<p>先安装两个包：</p>
<pre><code class="language-bash">yarn add core-js@3 regenerator-runtime
</code></pre>
<p>我们需要做的就是在入口处引入<code>polyfill</code>（或者在 webpack 配置文件中新增这两个包作为额外的入口）:</p>
<pre><code class="language-js">import &quot;core-js/stable&quot;;
import &quot;regenerator-runtime/runtime&quot;;
</code></pre>
<p>对于项目开发来说，这种方案较为稳妥。尽管将浏览器暂不支持的模块全部引入可能会让某些项目中未使用的模块占据一定的额外体积，但是可以避免项目中引入的第三方库<code>polyfill</code>处理不当，导致引用异常。</p>
<p>其次，设置<code>useBuiltIns</code>的值为<code>usage</code>时，我们不需要手动在入口文件引入<code>polyfill</code>，<code>Babel</code>将会根据我们的代码使用情况自动注入<code>polyfill</code>，如此一来在打包的时候将会相对地减少打包体积。</p>
<p><code>唯一的问题</code>:当项目中引入的第三方库有<code>polyfill</code>处理不当的情况下，将会出现引用异常的问题，使用社区广泛使用的流行库能降低这个风险。</p>
<h3>corejs</h3>
<p>core-js 是完全模块化的 javascript 标准库。</p>
<p>推荐让浏览器的<code>polyfill</code>统一由<code>corejs</code>来管理。</p>
<blockquote>
<p>core-js v2 已经不再维护，推荐一致使用 v3 版本</p>
</blockquote>
<p>我们来看一个使用<code>entry</code>的整体<code>preset-env</code>配置示例：</p>
<pre><code class="language-js">// .babelrc
{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;targets&quot;: {
          &quot;chrome&quot;: &quot;80&quot; // 推荐使用 .browserslistrc
        },
        &quot;useBuiltIns&quot;: &quot;entry&quot;,
        &quot;corejs&quot;: {
          &quot;version&quot;: 3, // 2 和 3 版本都需要手动安装库：yarn add core-js@3
          &quot;proposals&quot;: false
        }
      }
    ]
  ],
  &quot;plugins&quot;: []
}
</code></pre>
<blockquote>
<p>笔者个人而言，不推荐使用 proposals 功能，只使用最新规范中的特性。</p>
</blockquote>
<p>之后再在入口文件手动引入<code>polyfill</code>:</p>
<pre><code class="language-js">import &quot;core-js/stable&quot;;
import &quot;regenerator-runtime/runtime&quot;;
// other code
</code></pre>
<h2>Plugin-transform-runtime</h2>
<p>使用之前请安装库:</p>
<pre><code class="language-bash">yarn add @babel/runtime //默认 corejs为 false，如果使用 core-js v3 的 runtime，则需要安装 @babel/runtime-corejs3
yarn add -D babel-plugin-transform-runtime
</code></pre>
<p>之前提过<code>preset-env</code>的<code>polyfill</code>会污染全局，作为项目开发无可厚非，但是如果我们在开发提供给其他开发者使用的<code>library</code>，我想我们不应该污染全局，并且应该提供更好的打包体积和效率。</p>
<blockquote>
<p>A plugin that enables the re-use of Babel&#39;s injected helper code to save on codesize.</p>
</blockquote>
<p><code>plugin-transform-runtime</code>可以主要做了三件事：</p>
<ul>
<li>当开发者使用异步或生成器的时候，自动引入<code>@babel/runtime/regenerator</code>，开发者不必在入口文件做额外引入</li>
<li>提供沙盒环境，避免全局环境的污染</li>
<li>移除<code>babel</code>内联的<code>helpers</code>，统一使用<code>@babel/runtime/helpers</code>代替，减小打包体积</li>
</ul>
<p>当使用此方案时，不需要在入口文件处手动引入<code>core-js</code>和<code>regenerator-runtime</code>。详细的配置项建议在需要用的时候查看官方文档。</p>
<h2>总结</h2>
<p><code>@babel/preset-env</code>和<code>plugin-transform-runtime</code>二者都可以设置使用<code>corejs</code>来处理<code>polyfill</code>，二者各有使用场景，在项目开发和类库开发的时候可以使用不同的配置。</p>
<p><code>不要同时为二者配置core-js的功能</code>，以免产生复杂的不良后果。</p>
<p>最后，让我们来看看两个场景下的<code>babel</code>配置项：</p>
<h3>项目开发</h3>
<p><code>useBuiltIns</code>使用<code>usage</code>，尽量使用社区广泛使用的优质库以优化打包体积，不使用暂未进入规范的特性。<code>plugin-transform-runtime</code>只使用其移除内联复用的辅助函数的特性，减小打包体积。</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        // targets 官方推荐使用 .browserslistrc 配置
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;corejs&quot;: {
          &quot;version&quot;: 3,
          &quot;proposals&quot;: false
        }
      }
    ]
  ],
  &quot;plugins&quot;: [
    [
      &quot;@babel/plugin-transform-runtime&quot;,
      {
        &quot;corejs&quot;: false // 默认值，即使如此依然需要 yarn add @babel/runtime
      }
    ]
  ]
}
</code></pre>
<h3>类库开发</h3>
<p>类库开发尽量不使用污染全局环境的<code>polyfill</code>，因此<code>@babel/preset-env</code>只发挥语法转换的功能，<code>polyfill</code>由<code>plugin-transform-runtime</code>来处理，推荐使用<code>core-js@3</code>，并且不使用未进入规范的特性。</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
    ]
  ],
  &quot;plugins&quot;: [
    [
      &quot;@babel/plugin-transform-runtime&quot;,
      {
        &quot;corejs&quot;: {
          &quot;version&quot;: 3,
          &quot;proposals&quot;: true
        },
        &quot;useESModules&quot;: true
      }
    ]
  ]
}
</code></pre>
<p>总的来说，在配置开发环境的时候还是要参考官方文档的说明，这样才能减少出错的可能。</p>
<h2>参考</h2>
<ul>
<li><p><a href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins">@babel/preset-env · Babel</a></p>
</li>
<li><p><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime#docsNav">@babel/plugin-transform-runtime · Babel</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/361874935">吃一堑长一智系列: 99% 开发者没弄明白的 babel 知识</a></p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CSS之Grid布局]]></title>
            <link>https://i5lin.top/blog/post/1397542082</link>
            <guid>1397542082</guid>
            <pubDate>Wed, 05 Oct 2022 09:58:26 GMT</pubDate>
            <description><![CDATA[善用网格布局，可以轻松实现界面布局，并且具有现代浏览器良好的支持度。]]></description>
            <content:encoded><![CDATA[<p>网格布局<code>(Grid)</code>被视为当前最强大的<code>CSS</code>布局方案。</p>
<p><img src="https://images.unsplash.com/photo-1671725501844-1e6d0081bf64?ixlib=rb-4.0.3&ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=3540&q=80" alt=""></p>
<h2>1. 前言</h2>
<p>我需要的布局大致如下：</p>
<p><img src="https://i.loli.net/2021/06/10/GlXYwLiM4uyUIst.png" alt=""></p>
<p>可以看到，此布局并不复杂，我们可以使用多种方式来实现它，但今天我的计划是使用<code>Grid</code>布局。</p>
<p><code>Grid</code>布局将容器划分为“行”与“列”，产生单元格，然后指定“item”所在的单元格，因此也常被视为“二维布局”。</p>
<h2>2. 基本概念</h2>
<h3>2.1 容器和项目</h3>
<p>如名所示，最外层的元素作为容器<code>(container)</code>，内部每一个最外层的元素作为一个单独的项目<code>(item)</code>。</p>
<pre><code class="language-html">&lt;main&gt;
  &lt;section&gt;a&lt;/section&gt;
  &lt;section&gt;b&lt;/section&gt;
  &lt;section&gt;c&lt;/section&gt;
&lt;/main&gt;
</code></pre>
<p><code>Grid</code>布局针对<code>main</code>生效，<code>section</code>作为<code>item</code>，其内部元素与布局无关。</p>
<h3>2.2 行和列</h3>
<p><img src="https://i.loli.net/2021/06/10/IFci7q2pKmdLsG6.png" alt=""></p>
<p>我想这一张图已经非常明显地使用深色体现出行<code>(row)</code>与列<code>(column)</code>的区别，行和列是有交叉的。</p>
<h3>2.3 单元格和网格线</h3>
<p>行列交叉的区域，我们称之为<code>Cell(单元格)</code>，如前言所示，我们将子元素放在单元格中。而深色区域，我们将之称为<code>Grid line(网格线)</code>，通常<code>n</code>行<code>m</code>列，即可产生可供布局的<code>n*m</code>个<code>Cell</code>。</p>
<p>不要讲空白区域视为单元格，单元格始终是<code>行</code>和<code>列</code>相交产生的。</p>
<h2>3. 容器属性和项目属性</h2>
<p><code>Grid</code>布局属性分为定义在<code>container</code>上的<code>容器属性</code>,定义在<code>item</code>上的<code>项目属性</code>。</p>
<h3>3.1 容器属性</h3>
<h4>3.1.1 display</h4>
<p>显示为<code>container</code>设置<code>display: grid</code>显示属性布局为<code>grid</code>。</p>
<pre><code class="language-css">div {
  display: grid;
}
</code></pre>
<p>此时，<code>container</code>是一个单独的容器，默认是块级元素，也可以设置<code>display: inline-grid</code>为行内<code>Grid</code>布局，使其整体视为一个行内块级元素。</p>
<blockquote>
<p>网格布局将使得子项（item）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>display: vertical-align</code>、<code>display: column-*</code>等设置失效。</p>
</blockquote>
<h4>3.1.2 grid-template-rows 、grid-template-columns</h4>
<p><code>grid</code>布局除了需要显示指定布局类型为<code>grid</code>外，还需要指定行和列的值。</p>
<p><code>grid-template-rows</code>定义行高，有多少行就提供多少个值。</p>
<p><code>grid-template-column</code>定义列宽，同样，有多少列就提供多少个值。</p>
<p>例如，如果我们要设置一个九宫格，则分别需要三行三列：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-rows: 100px 100px 100px;
  grid-template-column: 100px 100px 100px;
}
</code></pre>
<p>如此一来配上<code>item</code>(css 提供一些颜色值):</p>
<pre><code class="language-html">&lt;div id=&quot;container&quot;&gt;
  &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt;
  &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt;
  &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt;
  &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;
  &lt;div class=&quot;item item-5&quot;&gt;5&lt;/div&gt;
  &lt;div class=&quot;item item-6&quot;&gt;6&lt;/div&gt;
  &lt;div class=&quot;item item-7&quot;&gt;7&lt;/div&gt;
  &lt;div class=&quot;item item-8&quot;&gt;8&lt;/div&gt;
  &lt;div class=&quot;item item-9&quot;&gt;9&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们可以得到一个九宫格布局：</p>
<p><img src="https://i.loli.net/2021/06/10/ACZfnmovTdDsiwk.png" alt=""></p>
<p>除了使用<code>px</code>这样的绝对单位，也可以使用百分数，甚至可以使用<code>repeat</code>类函数简化赋值：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: repeat(3, 33.33%);
  grid-template-rows: repeat(3, 33.33%);
}
</code></pre>
<p>甚至是：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: repeat(2, 100px 40px 50px);
  grid-template-rows: 50px 50px 50px;
}
</code></pre>
<p>定义了<code>100px 20px 80px 100px 20px 80px</code>，6 列宽度不一的列。</p>
<p><img src="https://i.loli.net/2021/06/10/1UQYPNlAax5rodI.png" alt="image-20210610012604962"></p>
<p>如上所示，第三行由于没有<code>item</code>，默认空白。</p>
<p>某些场合下，我们希望容器尽可能填充每一行的<code>item</code>，可以使用<code>auto-fill</code>关键字：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: repeat(auto-fill, 100px);
}
</code></pre>
<p><img src="https://i.loli.net/2021/06/10/RkMNLhud9IpliCw.png" alt="image-20210610012923160"></p>
<p>容器根据最大宽度进行自动列填充，此时行与列的数量是根据宽度变化的。</p>
<p>某些场合下，我们希望动态根据片段比例对行数进行判断，次数可以使用<code>fr(fraction)</code>关键字，表示列的宽度片段，例如：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: 2fr 1fr;
}
</code></pre>
<p>上述示例表示，第一列宽度为整个容器宽度的<code>2/3</code>，第二列为<code>1/3</code>，一般配合绝对宽度使用可以实现很灵活的布局效果：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: 150px 1fr 2fr;
}
</code></pre>
<p>上述示例，每一行先扣除第一列的<code>150px</code>宽度，剩下的再动态计算分配。也可以使用<code>auto</code>关键字，由浏览器决定长度。</p>
<pre><code class="language-css">grid-template-columns: 100px auto 100px;
</code></pre>
<p>网格线可以具有名字，并且可以有多个名字<code>（使用中括号括起来）</code>，方便后续复用。</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
}
</code></pre>
<h4>3.1.3 gap</h4>
<p>网格线间距属性<code>gap</code>，其属性为行和列的简写：</p>
<pre><code class="language-css">.container {
  gap: &lt;row-gap&gt; &lt;column-gap&gt;;
  gap: 20px 20px;
}
</code></pre>
<p>如果简写忽略了第二个值，则默认等于第一个值。</p>
<h4>3.1.4 grip-template-areas</h4>
<p>网格布局可以通过字符串，抽象画的划分不同<code>item</code>所属的区域。</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas:
    &quot;a b c&quot;
    &quot;d e f&quot;
    &quot;g h i&quot;;
}

.area-a {
  grid-area: a;
  ....;
}
</code></pre>
<p><code>grid-template-areas</code>通过空格将不同区域分割开来，然后可以在<code>css</code>中直接使用<code>grid-area</code>属性和区域名作为值，再为标签添加类即可针对性的设置样式。</p>
<p>不使用的区域可以使用<code>.</code>占位，可以不同<code>cell</code>具有相同的<code>area</code>名，以便于指定样式，例如：</p>
<pre><code class="language-css">grid-template-areas:
  &quot;a . a&quot;
  &quot;b . b&quot;
  &quot;c . d&quot;;
</code></pre>
<blockquote>
<p><code>grip-template-rows</code>可以定义子项高度，同时也可以为网格线命名，而网格线可以有多个名字。<code>grid-template-areas</code>指定区域名的时候，也默认生成了<code>areaName-start</code>和<code>areaName-end</code>这样的网格线别名。</p>
</blockquote>
<h4>3.1.5 grid-auto-flow</h4>
<p>容器划分好网格后，容器内<code>item</code>按顺序放置，默认先行后列，这个顺序是可以更改的。<code>grid-auto-flow</code>就是设置这个顺序的属性，默认值为<code>row</code>,先行后列，如果需要先列后行，则设置值为<code>column</code>。</p>
<p>当某行或者某列按次序放置子项的时候，存在剩余宽度不足的情形，如果需要可以在<code>row</code>或<code>column</code>后添加一个<code>dense</code>值，二者用空格分开，意为尽可能让子项连续密集显示，如此一来就会跳过宽度超过剩余宽度的子项，按序优先使用后续满足条件的子项。例如：</p>
<p><img src="https://i.imgur.com/P3bSu2L.png" alt=""></p>
<p>属性：</p>
<pre><code class="language-css">grid-auto-flow: row dense;
</code></pre>
<p>结果：</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032514-20210612221449095.png" alt=""></p>
<p>对于某些严格需要避免中间空白的布局来说，这个属性非常有效。</p>
<h4>3.1.6 单元格位置</h4>
<p><code>justify-items</code>设置单元格水平布局，<code>align-items</code>设置单元格垂直布局，二者可选的值为：</p>
<ul>
<li>start</li>
<li>end</li>
<li>center</li>
<li>Stretch （默认值，拉伸）</li>
</ul>
<p>如果要设置整个容器内的单元格位置，也就是将容器内所有单元格视为一个整体，其布局属性可用：</p>
<ul>
<li>justify-content:：整体水平对齐</li>
<li>align-content： 整体垂直对齐</li>
<li>place-content：此为上述两个属性的简写方式，如果忽略第二个值则采用第一个值</li>
</ul>
<p>这几个布局属性的值类似<code>flex</code>的布局值，分别是：</p>
<ul>
<li>start</li>
<li>end</li>
<li>center</li>
<li>stretch（拉伸）</li>
<li>Space-around 项目两侧间隔相等，子项之间距离两个间隔</li>
<li>Space-between 子项之间距离相等，第一个子项和最后一个子项左边或右边没有空白，紧贴容器</li>
<li>Space-evenly 子项左右空白距离相等</li>
</ul>
<h4>3.1.7 grid-auto-rows and grid-auto-columns</h4>
<p>当<code>容器网格</code>只有三行的时候，如果需要指定某个<code>子项</code>在第五行，这时候浏览器自动<code>根据子项大小</code>创建新的网格以放置额外的子项，我们可以通过<code>grid-auto-rows</code>和<code>grid-auto-columns</code>指定自动创建的网格的高度和宽度。</p>
<p>例如：</p>
<pre><code class="language-css">.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-auto-rows: 50px;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032525.png" alt=""></p>
<p>之所以<code>8</code>和<code>9</code>会占据图中的位置，是因为我们使用<code>css</code>指定其行和列的位置值：</p>
<pre><code class="language-css">.item-8 {
  background-color: #d0e4a9;
  grid-row-start: 4;
  grid-column-start: 2;
}

.item-9 {
  background-color: #4dc7ec;
  grid-row-start: 5;
  grid-column-start: 3;
}
</code></pre>
<p>由此引出<code>grid-row-start</code>和<code>grid-column-start</code>属性，可以指定其元素的位置。</p>
<p>除了<code>start</code>还有<code>end</code>可以指定，看示例：</p>
<pre><code class="language-css">.item-1 {
  grid-column-start: 2;
  grid-column-end: 4;
}
</code></pre>
<p>此时如果没有指定<code>grid-auto-flow: row dense;</code>,则会让布局看起来如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032526.png" alt=""></p>
<p>为了方便记忆，可以将网格线数字改为网格线名。</p>
<p>这四个属性的值还可以使用<code>span</code>关键字，表示&quot;跨越&quot;，即左右边框（上下边框）之间跨越多少个网格。</p>
<pre><code class="language-css">.item-1 {
  grid-column-start: span 2;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032528.png" alt=""></p>
<h4>3.1.8 属性简写</h4>
<p>此前我有翻译过<code>google html &amp; css guide</code>文档风格指南，其中有一条建议是尽量在<code>css</code>中使用简写，我认为这是一个很好的准则。</p>
<p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p>
<p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p>
<blockquote>
<p>如果你喜欢简写，务必不要弄错简写的属性顺序。</p>
</blockquote>
<p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p>
<pre><code class="language-css">.item {
  grid-column: &lt;start-line&gt; / &lt;end-line&gt;;
  grid-row: &lt;start-line&gt; / &lt;end-line&gt;;
}
</code></pre>
<p>下面是一个例子。</p>
<pre><code class="language-css">.item-1 {
  grid-column: 1 / 3;
  grid-row: 1 / 2;
}
/* 等同于 */
.item-1 {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 2;
}
</code></pre>
<p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p>
<p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>
<pre><code class="language-css">.item-1 {
  background: #b03532;
  grid-column: 1 / 3;
  grid-row: 1 / 3;
}
/* 等同于 */
.item-1 {
  background: #b03532;
  grid-column: 1 / span 2;
  grid-row: 1 / span 2;
}
</code></pre>
<p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/bg2019032529.png" alt=""></p>
<p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p>
<pre><code class="language-css">.item {
  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;
}

.item-1 {
  grid-area: 1 / 1 / 3 / 3;
}
</code></pre>
<p>效果如上图所示。</p>
<h3>3.2 子项属性</h3>
<p>子项和容器的属性可以拆分开来，通过诸如<code>justify-self</code>等带<code>self</code>关键字的属性控制单独的子项的样式，并且优先级高于容器上相关的样式属性。</p>
<h4>3.2.1 justify-self 、align-self、place-self</h4>
<p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>
<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<pre><code class="language-css">.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
</code></pre>
<p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p>
<pre><code class="language-css">place-self: center center;
</code></pre>
<p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>
<h2>4. 解题</h2>
<p>学习了<code>grid</code>布局的知识后，让我们将之运用到一开头我的需求中来，再次看这个图：</p>
<p><img src="https://raw.githubusercontent.com/youyiqin/markdown_imgs/master/GlXYwLiM4uyUIst-20210613022942072.png" alt=""></p>
<p>针对性的容器<code>CSS</code>如下：</p>
<pre><code class="language-css">.container {
}
</code></pre>
<h2>参考</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰的网络日志</a></li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Javascript-ES6-函数式编程阅读随写]]></title>
            <link>https://i5lin.top/blog/post/1397540450</link>
            <guid>1397540450</guid>
            <pubDate>Wed, 05 Oct 2022 09:57:04 GMT</pubDate>
            <description><![CDATA[第一次看到这本书的时候,记得是几年前在桂电图书馆里,断断续续看了六章,后来便离开了学校.现在买了纸质书打算重新看一遍,这里记录下阅读随想.]]></description>
            <content:encoded><![CDATA[<h1>函数式编程简介</h1>
<blockquote>
<p>函数要小,要更小.</p>
</blockquote>
<p>函数式编程,远离外部环境的依赖,隔绝突变与状态.</p>
<p>数学的函数定义中,函数必须接收一个<code>参数</code>,返回一个值.函数根据接收的参数运行.给定的参数下,返回值是不变的.</p>
<p><code>JavaScript函数式编程</code>基于数学函数及其思想进行发展.运用函数式的范式进行开发能创造可缓存和可测试的代码库.</p>
<blockquote>
<p>简单分辨函数与方法 - JS,不必深究 window 和 global 对象.</p>
</blockquote>
<ul>
<li>函数: 一段通过名称可调用的代码</li>
<li>方法: 通过名称且关联对象的名称被调用的代码</li>
</ul>
<p>函数的引用透明性指的是,函数对相同的输入返回相同的值.不依赖全局数据的函数,能够自由地在多线程状态下运行,全程无锁.并且函数是<code>可缓存</code>的,合理运用这一点,可以节省大量重复计算的资源消耗和时间消耗.</p>
<blockquote>
<p>引用透明性是一种哲学</p>
</blockquote>
<p><strong>命令式?声明式?</strong></p>
<pre><code class="language-js">const arr = [1, 2, 3];
for (i = 0; i &lt; arr.length; i++) console.log(i);
</code></pre>
<p>上述代码示例,我们告诉编译器如何去做,这就是<code>命令式</code>.</p>
<pre><code class="language-js">const arr = [1, 2, 3];
arr.forEach((i) =&gt; console.log(i));
</code></pre>
<p><code>forEach</code>是一个高阶函数,意在告知编译器<code>做什么</code>,<code>如何做</code>的部分则在高阶函数内的普通函数中实现.这便是<code>声明式</code>.</p>
<p><strong>纯函数</strong>:对给定的输入,返回相同的输出的函数.纯函数不依赖于外部环境.也不会改变外部环境.易于对函数进行<code>测试</code>.</p>
<p>纯函数是<code>易于阅读</code>的.为纯函数设置<code>具有意义</code>的函数名是一种最佳实践.</p>
<blockquote>
<p>纯函数应该被设计为只做一件事,并且把它做到完美,这也会是 Unix 的哲学.</p>
</blockquote>
<p>纯函数支持<code>管道和组合</code>.</p>
<pre><code class="language-shell">cat package.json | grep axios
</code></pre>
<p><code>bash</code>命令的管道和组合威力巨大,组合是函数式编程的核心.我们称之为<code>function composition</code>.</p>
<h1>JavaScript 函数式基础</h1>
<p>略,简述基础<code>JavaScript</code>.</p>
<h1>高阶函数 HOF</h1>
<p><strong>JavaScript 数据类型</strong>:</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Null</li>
<li>Object</li>
<li>undefined</li>
<li>Symbol</li>
<li>BigInt</li>
</ul>
<p>除了<code>object</code>外,都是原始数据类型.</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中，<strong>抽象化</strong>（英语：Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是隐藏起它的实现细节。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。一个电脑系统可以分割成几个<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B1%A4">抽象层</a>（Abstraction layer），使得程序员可以将它们分开处理。</p>
</blockquote>
<p>抽象化,让我们专注于可控层面的工作,将复杂的内容简单化,让开发者专注于预订的目标,不必<code>事事关心</code>.</p>
<p>我们通过<code>高阶函数</code>实现抽象.</p>
<pre><code class="language-js">const forEach = (arr, Fn) =&gt; {
  for (let i = 0; i &lt; arr.length; i++) Fn(arr[i]);
};
</code></pre>
<p>这是一个简单的高阶函数,抽象了<code>遍历数组</code>的问题,如果你使用这个函数,你并不需要关注内部代码是如何实现的.上述例子是一个简单逻辑,同理也可以是更为复杂的逻辑,这样一来就将复杂问题<code>抽象</code>出来了.</p>
<p>让我们开始学习构建复杂的高阶函数.</p>
<p>创建一个<code>every</code>函数如下:</p>
<pre><code class="language-js">const every = (arr, fn) =&gt; {
  let result = true;
  for (const i = 0; i &lt; arr.length; i++) {
    result = result &amp;&amp; fn(arr[i]);
  }
  return result;
};

// for..of.. 版本
// for...of..是 es6 的函数,可以方便遍历数组
const every = (arr, fn) =&gt; {
  let result = true;
  for (const value of arr) {
    result = result &amp;&amp; fn(arr[value]);
  }
  return result;
};
</code></pre>
<p>如此一来,我们抽象了对数组遍历的操作.</p>
<p>接着,编写一个<code>some</code>函数,其接受一个数组和一个函数,如果数组中一个元素通过接收的函数返回<code>true</code>,则<code>some</code>函数返回<code>true</code>:</p>
<pre><code class="language-js">const every = (arr, fn) =&gt; {
  let result = true;
  for (const value of arr) {
    result = result || fn(arr[value]);
  }
  return result;
};
</code></pre>
<blockquote>
<p>some 函数和 every 函数都不算高效,这里只是作为对高阶函数的展示.</p>
</blockquote>
<p><code>JavaScript</code>的<code>array</code>原型内置<code>sort</code>函数,可以给数组排序.这是一个典型的<code>高阶函数</code>.它接收一个可选的函数来决定排序顺序逻辑.极大的提高了排序的灵活性.我们知道,默认的<code>sort</code>排序是将数组元素转换为<code>string</code>并且按<code>Unicode</code>编码点进行排序,因此数字 2 在默认排序算法中小于 12.让我们看看此可选的<code>compare</code>函数的骨架:</p>
<pre><code class="language-js">function compare(a, b) {
  if (条件) {
    // a 小于 b
    return -1;
  }
  if (条件) {
    // a 大于 b
    return 1;
  }
  // a 等于 b
  return 0;
}
</code></pre>
<p>举个例子,现在我们有一个用户数组,每个元素是一个用户的信息.</p>
<pre><code class="language-js">const people = [
  {
    name: &quot;Aaron&quot;,
    age: 10,
  },
  {
    name: &quot;Rose&quot;,
    age: 11,
  },
];
</code></pre>
<p>而需求则是,通过姓名排序或者通过年龄排序.根据前置知识,可以写出如下代码:</p>
<pre><code class="language-js">// 简化逻辑,忽略相等的情况
people.sort((a, b) =&gt; (a.name &gt; b.name ? 1 : -1));
people.sort((a, b) =&gt; (a.age &gt; b.age ? 1 : -1));
</code></pre>
<p>上述代码,我们将雷同的部分写了两遍.现在我们来设计一个函数,接收一个参数,返回一个函数.是的,将要设计的这个函数是一个<code>高阶函数</code>.</p>
<pre><code class="language-js">const sortBy = (property) =&gt; {
  return (a, b) =&gt; {
    return a[property] &gt; b[property] ? 1 : -1;
  };
};
// 简化版
const sortBy = (property) =&gt; (a, b) =&gt; a[property] &gt; b[property] ? 1 : -1;
</code></pre>
<p>现在,我们可以重写按<code>name</code>或者<code>age</code>的排序代码了.</p>
<pre><code class="language-js">people.sort(sortBy(&quot;name&quot;));
people.sort(sortBy(&quot;age&quot;));
</code></pre>
<p>这就是<code>高阶函数</code>的魅力.运用高阶函数,提高代码质量,降低代码数量.</p>
<h1>闭包与高阶函数</h1>
<p>简而言之,闭包就是一个内部函数.在一个函数内部的函数,可以称为<code>闭包函数</code>.</p>
<p>从<code>技术上</code>来讲,上述闭包函数的闭包场景存在三个可访问的作用域:</p>
<ul>
<li>自身声明内变量</li>
<li>外部函数变量</li>
<li>全局变量</li>
</ul>
<p><strong>闭包可以记住上下文环境</strong>.话说回来,由于我们要在函数式编程中处理很多函数,因此需要一种调试方法.</p>
<p>举个例子,一个字符串数组,想要解析成整数数组,如下代码会有问题:</p>
<pre><code class="language-js">[&quot;1&quot;, &quot;2&quot;].map(parseInt);
</code></pre>
<p><code>map</code>函数用三个参数调用了<code>parseInt</code>,分别是:</p>
<ol>
<li>element</li>
<li>index</li>
<li>arr</li>
</ol>
<p>而<code>parseInt</code>函数全盘接纳,来看看此函数的定义:</p>
<pre><code class="language-js">parseInt(string, radix);
</code></pre>
<p><code>radix</code>是可选的基数,如果提供 10,则转换为十进制的整数.</p>
<p>如果 <code>radix</code> 是 <code>undefined</code>、<code>0</code>或未指定的，JavaScript 会假定以下情况：</p>
<ol>
<li>如果输入的 <code>string</code>以 &quot;<code>0x</code>&quot;或 &quot;<code>0x</code>&quot;（一个 0，后面是小写或大写的 X）开头，那么 radix 被假定为 16，字符串的其余部分被当做十六进制数去解析。</li>
<li>如果输入的 <code>string</code>以 &quot;<code>0</code>&quot;（0）开头， <code>radix</code>被假定为<code>8</code>（八进制）或<code>10</code>（十进制）。具体选择哪一个 radix 取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。<strong>因此，在使用 <code>parseInt</code> 时，一定要指定一个 radix</strong>。</li>
<li>如果输入的 <code>string</code> 以任何其他值开头， <code>radix</code> 是 <code>10</code> (十进制)。</li>
</ol>
<p>如果第一个字符不能转换为数字，<code>parseInt</code>会返回 <code>NaN</code>。</p>
<p>此时,<code>[&#39;1&#39;, &#39;2&#39;].map(parseInt)</code>的结果是: [1, NaN].</p>
<p>如何用函数式的思维,创建一个高阶函数,对<code>parseInt</code>进行抽象.</p>
<pre><code class="language-js">const unary = (fn) =&gt;
  fn.length === 1 ? fn : (arg) =&gt; fn(arg)[(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)].map(unary(parseInt));
</code></pre>
<p>现在,即使<code>map</code>以三个参数调用<code>unary</code>函数执行后返回的函数,都只会让<code>element</code>参数生效.</p>
<p>我们得到了预期中的结果:<code>[1,2,3]</code> :seedling:</p>
<p>现在,让我们为自己的工具库添加一个工具函数,这个函数接收一个函数作为参数,让这个接收的函数只能被执行一次.</p>
<pre><code class="language-js">const once = (fn) =&gt; {
  let done = false;
  return () =&gt; (done ? undefined : ((done = true), fn.apply(this, arguments)));
};
</code></pre>
<p>现在用一个变量<code>done</code>保存函数的执行状态.</p>
<pre><code class="language-js">const demoFn = (a, b) =&gt; {
  console.log(a, b, &quot;just called once.&quot;);
};
const newDemoFn = once(demoFn);
newDemoFn(1, 2); // output: 1 2 just called once.
newDemoFn(3, 4); // no output
</code></pre>
<p>继续,创建下一个函数<code>memoized</code>,使函数记住其计算结果:</p>
<pre><code class="language-js">const memoized = (fn) =&gt; {
  const lookupTable = {};
  return (arg) =&gt; lookupTable[arg] || (lookupTable[arg] = fn(arg));
};
</code></pre>
<p>一个速查<code>table</code>保存了函数解构,如果不存在则执行此函数,保存到速查表中并且返回此结果.</p>
<p><strong>memoized 函数是经典的函数式编程,是闭包与纯函数的实战</strong></p>
<h1>数组的函数式编程</h1>
<p>我们将创建一组函数用于解决常见的数组问题,关键在于函数式的方法,而非命令式的方法.</p>
<blockquote>
<p>把函数应用于一个值,并且创建新的值的过程被称为&quot;投影&quot;</p>
</blockquote>
<p><code>Array.map</code>就是典型的投影函数.我们来试着创建一个<code>map</code>函数.</p>
<pre><code class="language-js">const map = (arr, fn) =&gt; {
  const result = [];
  for (const v of arr) {
    result.push(fn(v));
  }
  return result;
};
</code></pre>
<p>一个<code>filter</code>函数,对数组内容进行过滤.</p>
<pre><code class="language-js">const filter = (arr, fn) =&gt; {
  const result = [];
  for (const v of arr) {
    if (fn(v)) result.push(v);
  }
  return result;
};
</code></pre>
<p>一个<code>reduce</code>函数,对数组的所有值进行<code>归约</code>操作.</p>
<pre><code class="language-js">var reduce = (arr, fn, defaultAccumlator) =&gt; {
  let accumlator;
  if (defaultAccumlator !== undefined) {
    accumlator = defaultAccumlator;
    for (const v of arr) {
      accumlator = fn(accumlator, v);
    }
  } else {
    accumlator = arr[0];
    for (let i = 1; i &lt; arr.length; i++) {
      accumlator = fn(accumlator, arr[i]);
    }
  }
  return [accumlator];
};
</code></pre>
<p><strong>继续</strong>,上<code>zip</code>函数,用于合并两个单独的数组,返回一个处理过的新数组.这个函数可以对给定的两个数组的限定对象进行结对处理,如何处理取决于具体的函数逻辑.结对的结果就是返回一个新的数组.</p>
<pre><code class="language-js">const zip = (arr1, arr2, fn) =&gt; {
  let index,
    result = [];
  for (index = 0; index &lt; Math.min(arr1.length, arr2.length); index++) {
    result.push(fn(arr1[index], arr2[index]));
  }
  return result;
};
</code></pre>
<h1>currying 和偏应用</h1>
<p><strong>一些术语</strong>:</p>
<ul>
<li>unary function: 一元函数,只接收一个参数的函数.</li>
<li>binary function: 二元函数</li>
<li>变参函数:接受可变数量参数的函数</li>
<li>currying: 柯里化,这是一个过程,将一个多参函数转变为一个嵌套的一元函数.</li>
</ul>
<p>上代码:</p>
<pre><code class="language-js">const curry = (binaryFn) =&gt; {
  return (firstArg) =&gt; {
    return (secondArg) =&gt; {
      return binaryFn(firstArg, secondArg);
    };
  };
};
// 简化
const curry = (binaryFn) =&gt; (firstArg) =&gt; (secondArg) =&gt;
  binaryFn(firstArg, secondArg);
</code></pre>
<p>完美利用了闭包的特性,也许对于一些深谙此道的 coder 而言,这不算什么.但是对于此刻的我来说,从未如此清晰体会到闭包和 currying.如此之美.</p>
<p>开发者编写代码的时候会在应用中编写日志,下面我们编写一个<code>日志函数</code>.</p>
<pre><code class="language-js">const loggerHelper = (mode, msg, errorMsg, lineNo) =&gt; {
  if (mode === &quot;DEBUG&quot;) {
    console.debug(msg, errorMsg + &quot;at line:&quot; + lineNo);
  } else if (mode === &quot;WARN&quot;) {
    console.warn(msg, errorMsg + &quot;at line:&quot; + lineNo);
  } else if (mode === &quot;ERROR&quot;) {
    console.error(msg, errorMsg + &quot;at line:&quot; + lineNo);
  } else {
    throw &quot;WRONG MODE&quot;;
  }
};
</code></pre>
<p>上述代码不是良好的设计,多次重用了部分代码,让整体不够简洁.之前创建的<code>curry</code>函数也无法处理这个日志函数.我们需要<strong>更进一步</strong>.我们需要把多参数函数转化为<code>unary function</code>.</p>
<pre><code class="language-js">const curry = (fn) =&gt; {
  if(typeof fn !== &#39;function&#39;) throw Error(&#39;No function provided&#39;)
  // args 是可变参数
  return function curryFn(...args) {
    // 如果可变参数少于被柯里化的函数的参数数量
    if(args.length &lt; fn.length) {
      return function() {
        // 执行此函数,返回一个处理一次参数的函数
        return curryFn.apply(null, args.concat(
            Array.slice.call(arguments)
        ))
      }
    }
    return fn.apply(null, args)
}
</code></pre>
<blockquote>
<p><code>arguments</code>对象是所有（非箭头）函数中都可用的<strong>局部变量</strong>。你可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引 0 处。</p>
</blockquote>
<p>回到<code>日志函数</code>:</p>
<pre><code class="language-js">const errorDebugLog = curry(loggerHelper)(&quot;ERROR&quot;)(&quot;ERROR:&quot;);
const warnDebugLog = curry(loggerHelper)(&quot;WARN&quot;)(&quot;WARN:&quot;);
errorDebugLog(&quot;balabala..&quot;, 21); // output: &#39;ERROR: balabala at line 21&#39;
</code></pre>
<p>这就是闭包的魅力,在首次传入<code>loggerHelper</code>的时候,闭包生成了可访问变量作用域,记住了函数信息.</p>
<p>现在,让我们来解决两个问题:</p>
<ul>
<li>在数组内容中检查是否存在数字</li>
<li>求数组的平方</li>
</ul>
<p>首先,创建一个检查函数:<code>findNumberInArr</code></p>
<pre><code class="language-js">const match = curry((expr, str) =&gt; str.match(expr));
const hasNumber = curry(match(/[0-9]+/));
const filter = curry((fn, arr) =&gt; arr.filter(fn));
// create fn
const findNumberInArr = filter(hasNumber);
// test
findNumberInArr([&quot;demo&quot;, &quot;demo1&quot;]); // output: [&#39;demo1&#39;]
</code></pre>
<p>现在求数组的平方,我们通过<code>curry</code>函数进行处理,这次不要直接通过<code>map</code>函数传入一个平方函数解决这个问题.换一个视角.</p>
<pre><code class="language-js">const map = curry((fn, arr) =&gt; arr.map(f));
const squareAll = map((x) =&gt; x * x);
// 现在,squareAll 是一个unary 函数
squareAll([1, 2, 3]); // output: [1, 4, 9]
</code></pre>
<p>我们可以很多地方直接使用<code>squareAll</code>函数了.如果需要在多个地方求数组的平方,这个函数可以简化降低代码量,当然,我们还可以配合<code>memoized</code>函数进行缓存处理!</p>
<p>是时候谈谈<code>偏应用</code>了,接下来我们将创建一个<code>partial</code>函数以解决我们的问题.</p>
<p>比如我们有这样一个场景,我们需要在 10 秒后执行一个函数,这个需求在多个地方用得上,也许我们会直接如此编程:</p>
<pre><code class="language-js">setTimeout(() =&gt; {
  // some code
}, 10000);
</code></pre>
<p>一旦需要在另一个地方使用这个逻辑,就需要重写一遍这些代码.而且无法使用<code>curry</code>函数进行处理,因为时间参数是最后一个参数.解决这个问题的方案之一就是创建一个封装函数:</p>
<pre><code class="language-js">const setTimeoutWrapper = (time, fn) =&gt; {
  setTimeout(fn, time);
};
</code></pre>
<p>然后使用<code>curry</code>函数进行优化.然而,我们可以进一步减少创建此类函数的开销.</p>
<p><strong>这就是偏应用</strong>的应用场景.</p>
<pre><code class="language-js">var partial = (fn, ...partialArgs) =&gt; {
  let args = partialArgs
  return (...fullArguments) {
    let arg = 0
    for(let i=0;i&lt;args.length &amp;&amp; arg &lt; fullArguments.length;i++) {
      if(args[i] === undefined) {
        args[i] = fullArguments[arg++]
      }
    }
    return fn.apply(null, args)
  }
}

const delayTenMs = partial(setTimeout, undefined, 10)
const demoFn = () =&gt; {
  // sdasdsadad
}
delayTenMs(demoFn)
</code></pre>
<p>再次使用了闭包,记住了<code>setTimeout</code>需要的参数列表长度,暂未提供的参数用 undefined 代替.后续返回一个函数,提供参数的同时,补全之前用 undefined 代替的部分参数,最终执行函数.</p>
<p>例如,我们需要美化一个<code>json</code>对象的输出.先看看 json stringify 函数的定义.</p>
<pre><code class="language-js">JSON.stringify(value[, replacer [, space]])
</code></pre>
<p><strong>参数</strong></p>
<ul>
<li><p><code>value</code></p>
<p>将要序列化成 一个 JSON 字符串的值。</p>
</li>
<li><p><code>replacer</code> 可选</p>
<p>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</p>
</li>
<li><p><code>space</code> 可选</p>
<p>指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</p>
</li>
</ul>
<pre><code class="language-js">const obj = { foo: &quot;bar&quot;, bar: &quot;foo&quot; };
// 第二参数
JSON.stringify(obj, null, 2);
// 想办法移除样板代码 null 和 2
const prettyJson = partial(JSON.stringify, undefined, null, 2);
prettyJson(obj);
</code></pre>
<p>啊!<code>partial</code>函数有 bug.<code>partialArgs</code>传递的是数组,数组传递的是引用.如果不创建一个新的数组,并且在最后重置数组的话,执行一次<code>partial</code>化后的函数<code>delayTenMs</code>,内部 args 就固定了,闭包变量保存了首次执行的时候提供的参数去替换<code>undefined</code>,这里的<code>undefined</code>就像占位符.</p>
<p>书上并没有给出一个示例代码来解决问题,只是提出存在 bug 的观点,我写下了如下代码,使用扩展运算符重置占位符效果的<code>undefined</code>变量.</p>
<pre><code class="language-js">const partial = (fn, ...partialArgs) =&gt; {
  let args = [...partialArgs];
  return (...fullArgs) =&gt; {
    let argIndex = 0;
    for (
      let index = 0;
      index &lt; args.length &amp;&amp; argIndex &lt; fullArgs.length;
      index++
    ) {
      if (args[index] === undefined) {
        args[index] = fullArgs[argIndex++];
      }
    }
    const result = fn.apply(null, args);
    args = [...partialArgs];
    return result;
  };
};
</code></pre>
<p>晚安.</p>
<p>2020 年 12 月 21 日 01:41:11</p>
<h1>管道和组合</h1>
<p>函数式组合在函数式编程中被称为<code>组合 composition</code>.</p>
<blockquote>
<p>每个程序只为做好一件事,重构要比在旧的复杂程序中添加新属性更好. From Ken·Thompson</p>
</blockquote>
<blockquote>
<p>每一个程序的输出应该是另一个未知程序的输入.</p>
</blockquote>
<p>我们将要创建<code>compose</code>函数,例如:</p>
<pre><code class="language-js">const compose = (a, b) =&gt; (c) =&gt; a(b(c));
</code></pre>
<p>依然是熟悉的高阶函数,接收函数作为参数,返回函数.返回的函数的<code>参数</code>是关键.</p>
<p><code>compose</code>函数能解决我们常见的一些问题.你是否写过类似如下代码:</p>
<pre><code class="language-js">const data = someFn(&quot;this&quot;);
const result = otherFn(data);
</code></pre>
<p>一个函数的输出,作为另一个函数的输入.<code>compose</code>函数为此而生.</p>
<pre><code class="language-js">const getResult = compose(otherFn, someFn);
</code></pre>
<p><code>getResult</code>是一个函数,接收的参数跟<code>someFn</code>函数一致.我们创建了一个函数<code>getResult</code>.这是一种优雅而简单的实现方式.</p>
<p>上述<code>someFn</code>只接收一个参数,如果需要接收多个参数的话,我们可以使用<code>curry</code>和<code>partial</code>两个函数进行优化.</p>
<blockquote>
<p>组合的思想就是把小函数组合成大函数,简单的函数易于阅读,测试和维护.</p>
</blockquote>
<p>创建小的函数单元,可以通过 compose 组合重建应对各种需求.</p>
<p>但是,上述<code>compose</code>函数无法处理更多函数作为参数.仅仅支持两个函数作为参数是不够的,让我们来优化一下.</p>
<pre><code class="language-js">const compose =
  (...fns) =&gt;
  (value) =&gt;
    reduce(fns.reverse(), (acc, fn) =&gt; fn(acc), value);
</code></pre>
<p>竟然如此简单桥面,接收一个入口参数<code>value</code>,首先设置为初始的<code>acc</code>值,依次执行并且返回作为下一个函数的入口.</p>
<p>组合是从右到左执行的,而管道则从左到右.接下来创建<code>pipe</code>管道函数.</p>
<pre><code class="language-js">const pipe =
  (...fns) =&gt;
  (value) =&gt;
    reduce(fns, (acc, fn) =&gt; fn(acc), value);
</code></pre>
<p>只是执行方向不同而已,因此参数列表不必反向.</p>
<blockquote>
<p>在公共代码库中建议使用单一的数据流,我更喜欢管道,因为这让我想起 shell 知识.同时使用管道和组合容易在团队中引起混淆.</p>
</blockquote>
<p>接下来,本书描述了<strong>组合</strong>的优势.</p>
<p>组合支持结合律.书上并没有详细的介绍和案例分析.只是单纯举例:</p>
<pre><code class="language-js">compose(f, compose(g, h)) == compose(compose(f, g), h);
</code></pre>
<p>通过组合小函数的方式,让函数的组合更加灵活.</p>
<p>下面,我们来创建一个<code>identity</code>函数,用于分析调试.接收一个参数,打印并且返回.</p>
<pre><code class="language-js">const identity = (it) =&gt; {
  console.log(it);
  return it;
};
</code></pre>
<p>由于组合和管道数据是流动的关系,可以在其间插入<code>identity</code>函数,输出数据用于调试.这确实非常简单有效.</p>
<h1>函子</h1>
<p>本章最重要的内容就是<code>编程错误处理</code>.我们需要了解一个新的概念:<code>functor:函子</code>,它将以纯函数的形式帮我们处理错误.</p>
<blockquote>
<p>函子是一个普通对象,它实现了<code>map</code>函数,在遍历每一个对象的时候生成一个新的对象.</p>
</blockquote>
<p>函子是<code>容器</code>,其持有值.</p>
<pre><code class="language-js">const Container = function (val) {
  this.value = val;
};
</code></pre>
<blockquote>
<p>不使用箭头函数,箭头函数没有<code>[[construct]]</code>和<code>prototype</code>属性,无法用<code>new</code>实例化.</p>
</blockquote>
<p>现在,<code>container</code>可以持有传给它的任何值.</p>
<pre><code class="language-js">let a = new Container(3)
=&gt; Container(value: 3)
let bObj = new Container({a: 1})
=&gt; Container({a:1})
</code></pre>
<p>继续,创建一个<code>of</code>静态方法.</p>
<pre><code class="language-js">Container.of = function (value) {
  return new Container(value);
};
</code></pre>
<p>于是,我们可以使用<code>static</code>函数创建对象了.</p>
<pre><code class="language-js">const testObj = Container.of(3)
=&gt; Container(value:3)
</code></pre>
<p>接下来,我们需要创建<code>map</code>函数,之后这便是一个<code>函子</code>.</p>
<p><img src="https://i.loli.net/2020/12/24/vX1AIKxhgOlQzMd.png" alt=""></p>
<p>看代码:</p>
<pre><code class="language-js">Container.prototype.map = function (fn) {
  return Container.of(fn(this.value));
};
</code></pre>
<p>经过<code>map</code>函数处理,会返回一个新的 container 对象.于是,我们可以进行如下编码:</p>
<pre><code class="language-js">let double = x =&gt; x + x
Container.of(3).map(double)
=&gt; Container(6)
Container.of(3).map(double).map(double)
=&gt; Container(12)
</code></pre>
<p>得到了我个人一直以来不够了解的链式调用的实现思路.</p>
<blockquote>
<p>函子是一个实现了 map 契约的对象</p>
</blockquote>
<p>所以,函子能用在什么地方?</p>
<pre><code class="language-js">const MayBe = function (val) {
  this.value = val;
};
MayBe.of = function (v) {
  return new MayBe(v);
};
MayBe.prototype.isNothing = function () {
  return this.value === null || this.value === undefined;
};
MayBe.prototype.map = function (fn) {
  return this.isNothing() ? MayBe.of(null) : MayBe.of(this.value);
};
</code></pre>
<p>:construction_worker:</p>
<p>上用例</p>
<pre><code class="language-js">MayBe.of(&#39;string&#39;).map(x =&gt; x.toUpperCase())
=&gt; MayBe {value: &#39;STRING&#39;}
</code></pre>
<p>即使不是<code>typescript</code>,无法避免<code>of</code>方法传入<code>null</code>或者<code>undefined</code>,内部的<code>map</code>方法也会做一次检查,逻辑抽象出来避免了错误.代码没有在<code>null</code>或者<code>undefined</code>下崩溃.这是一种声明式的方式去编程,这也是一个安全的容器.</p>
<pre><code class="language-js">MayBe.of(&quot;pg&quot;)
  .map((x) =&gt; x.toUpperCase())
  .map((x) =&gt; `Mr. ${x}`);
</code></pre>
<p>链式调用,优美简洁.</p>
<p><strong>另一个函子</strong><code>Either</code>,上述<code>MayBe</code>函子在传入<code>null</code>或者<code>undefined</code>后,最后的结果是<code>null</code>.可是我们很难分析出问题出在哪里.我们需要一个更强大的函子,解决分支拓展的问题.</p>
<pre><code class="language-js">const Nothing = function (val) {
  this.value = val;
};
Nothing.of = function (v) {
  return new Nothing(v);
};
Nothing.prototype.map = function (f) {
  return this;
};
const Some = function (val) {
  this.value = val;
};
Some.of = function (v) {
  return new Some(v);
};
Some.prototype.map = function (f) {
  return Some.of(f(this.value));
};
</code></pre>
<p><code>Nothing</code>的 map 函数,返回自身,而不是运行函数<code>f</code>.</p>
<p>2020 年 12 月 25 日 12:57:10 :100:</p>
<p>能在<code>Some</code>上运行函数,而<code>Nothing</code>不行.来吧,实现<code>Either</code>.</p>
<pre><code class="language-js">const Either = {
  Some,
  Nothing,
};
</code></pre>
<p>如果我们有一个<code>web</code>请求,返回数据可能是正常数据,或者一条错误信息.</p>
<pre><code class="language-js">const getData = (type) =&gt; {
  let resp;
  try {
    resp = Some.of(data);
  } catch {
    resp = Nothing.of(error);
  }
};
</code></pre>
<p>后续返回的 response 对象依然是函子,可以使用链式调用的 map 函数.但是,错误信息能保存下去,<code>Nothing</code>从头到尾都不会变,直接返回<code>this</code>使得后续的 map 函数<code>失效</code>.</p>
<p>现在,你根据上下文,可以很容易看出异常出在哪里.是的,是<code>catch</code>到了错误.</p>
<p>上述函子都是<code>pointed</code>函子,ES6 的 Array.of 也是<code>pointed</code>函子.</p>
<h1>深入理解 Monad 函子</h1>
<p><code>reddit</code>开放了一些<code>api</code>接口,例如:<strong><a href="https://www.reddit.com/search.json?q=something">https://www.reddit.com/search.json?q=something</a></strong></p>
<p>粘贴一个随机的返回数据,不必详细深究:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: &quot;Listing&quot;,
  &quot;data&quot;: {
    &quot;after&quot;: &quot;t3_k1qcrx&quot;,
    &quot;dist&quot;: 25,
    &quot;facets&quot;: {}.
    &quot;modhash&quot;: &quot;&quot;,
    &quot;children&quot;: [...],
  &quot;before&quot;: null
  }
}
</code></pre>
<p><code>children</code>部分非常庞大,不再展开.每一个<code>children</code>都是一个对象,内含一个<code>Permalink</code>键,值是一个相对<code>url</code>,访问这个<code>url</code>则能获取到评论数组.</p>
<p>我们如何按搜索的结果,获取文章的评论,最后返回一个数组,每个元素是一个对象,对象内是<code>title</code>和<code>comments</code>.</p>
<pre><code class="language-js">const request = require(&quot;sync-request&quot;);
const searchReddit = (search) =&gt; {
  let response;
  try {
    response = JSON.parse(
      request(
        &quot;GET&quot;,
        &quot;https://www.reddit.com/saerch.json?q=&quot; + encodeURI(search)
      ).getBody(&quot;utf8&quot;)
    );
  } catch (err) {
    response = { msg: &quot;something wrong&quot;, errorCode: err[&quot;statusCode&quot;] };
  }
  return response;
};

const getComments = (link) =&gt; {
  let resp;
  try {
    resp = JSON.parse(
      request(&quot;GET&quot;, &quot;https://www.reddit.com/&quot; + link).getBody(&quot;utf8&quot;)
    );
  } catch (err) {
    resp = {
      msg: &quot;get comment failed&quot;,
      errorCode: err[&quot;statusCode&quot;],
    };
  }
  return resp;
};

// 合并两个函数
const mergeViaMayBe = (searchText) =&gt; {
  let redditMayBe = MayBe.of(searchReddit(searchText));
  let ans = redditMayBe
    .map((arr) =&gt; arr[&quot;data&quot;])
    .map((arr) =&gt; arr[&quot;children&quot;])
    .map((arr) =&gt;
      map(arr, (x) =&gt; {
        return {
          title: x[&quot;data&quot;].title,
          permalink: x[&quot;data&quot;].permalink,
        };
      })
    )
    .map((obj) =&gt;
      map(obj, (x) =&gt; {
        return {
          title: x.title,
          comments: MayBe.of(
            getComments(x.permalink.replace(&quot;?ref=search_posts&quot;, &quot;.json&quot;))
          ),
        };
      })
    );
};
</code></pre>
<p>运用函子,可以使用链式方法解决问题,非常优雅.</p>
<p>但是,这依然不够,观察上述结果中<code>comments</code>依然是<code>MayBe</code>对象,想要真正取值还是需要继续<code>map</code>调用.</p>
<p>下面,介绍<code>Monad</code>函子以解决过多的<code>map</code>嵌套问题.让<code>MayBe</code>武装到牙齿.</p>
<pre><code class="language-js">MayBe.prototype.join = function () {
  return this.isNothing() ? MayBe.of(null) : this.value
}
let joinExample = MayBe.of(MayBe.of(1))
=&gt; MayBe{value: MayBe{value: 1}}
joinExample.join()
// 返回值展开一个层级
=&gt; MayBe {value: 1}
</code></pre>
<p>如果我们想要对内部的值进行操作,也许可以先展开层级,再执行<code>map</code>函数,以减少<code>map</code>的调用.那么既然当我们需要展开一层的时候都需要在后面跟一个<code>join</code>方法,我们可以再封装一个<code>chain</code>函数来做这件事.</p>
<pre><code class="language-js">MayBe.prototype.chain = function (f) {
  return this.map(f).join();
};
</code></pre>
<p><code>Monad</code>就是包含<code>chain</code>方法的特殊函子.或者说,一个函子拥有<code>chain</code>方法,就可以称为<code>Monad</code></p>
<p>2020 年 12 月 26 日 01:34:57</p>
<h1>使用 Generator</h1>
<p>如果你是<code>promise</code>的粉丝,建议学习<code>Generator</code>及其解决异步代码问题的方式.</p>
<p>让我们先来谈谈<code>同步和异步</code>:</p>
<ul>
<li><p>同步:函数执行的时候阻塞调用者,直到函数执行结束返回结果.</p>
</li>
<li><p>异步:函数执行不会阻塞,但是函数执行结束就会返回结果.</p>
</li>
</ul>
<p>让我们来创建<code>Generator</code>,注意观察这个特殊语法.</p>
<pre><code class="language-js">function* gen() {
  return &quot;first generator&quot;;
}
</code></pre>
<p>我们在函数前面用一个星号 <strong>*</strong> 来表示这是一个<code>Generator</code>函数.</p>
<pre><code class="language-js">let genResult = gen();
</code></pre>
<p>此刻,<code>genResult</code>并不是<code>first generator</code>,而是:</p>
<p><code>gen {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorRecevier]]: Window}</code></p>
<p>这是一个<code>Generator</code>原始类型的实例.这个实例拥有<code>next</code>方法.执行此方法,上面的代码返回一个对象:</p>
<p><code>{value: &#39;first generator&#39;, done: true}</code></p>
<p><code>Generator</code>实例如同序列,一旦使用<code>next</code>消费,则不能再次得到上次消费的值.也就是说,如果你继续执行<code>next()</code>方法,结果的<code>vaue</code>将是<code>undefined</code>.</p>
<pre><code class="language-js">function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
</code></pre>
<p>有趣的是,实例执行<code>next</code>将会返回<code>yield</code>后的结果,并且下次执行<code>next</code>会从当前<code>yield</code>后继续执行.当所有<code>yield</code>结果都消费之后,<code>done</code>属性变成<code>true</code>.</p>
<pre><code class="language-js">let genResult = gen();
for (let v of genResult()) {
  console.log(v);
}
// 1
// 2
// 3
</code></pre>
<p><code>for..of..</code>利用了<code>next</code>和<code>done</code>属性完成遍历.</p>
<p><code>Generator</code>不止如此,还可以想其实例通过<code>next</code>函数传递数据.</p>
<pre><code class="language-js">function * sayFullName(){
  let firstName = yield
  let secondName = yield
  console.log(`${firstName} - ${secondName}`)
}

// call it
let fullName = sayFullName()
fullName.next()
fullName.next(&#39;Fname&#39;)
fullName.next(&#39;Sname&#39;)
=&gt; console log : Fname - Sname
</code></pre>
<p>首次运行<code>next</code>,函数暂停于: <code>let firstName = yield</code></p>
<p>再次运行带参数的<code>next</code>,则<code>let firstName = yield</code>转为<code>let firstName = &quot;Fname&quot;</code></p>
<blockquote>
<p><code>Generator</code>与<code>异步应用</code>可以很和谐.</p>
</blockquote>
<p>假如有两个本质上是异步的函数如下:</p>
<pre><code class="language-js">let getDataOne = (cb) =&gt; {
  setTimeout(() =&gt; {
    cb(&quot;dummy data one&quot;);
  }, 1000);
};

let getDataTwo = (cb) =&gt; {
  setTimeout(() =&gt; {
    cb(&quot;dummy data two&quot;);
  }, 1000);
};
</code></pre>
<p>一旦时间过去,就执行传入的回调函数<code>cb</code>.如果要用<code>generator</code>来解决回调函数可能导致的函数回调地狱的问题?</p>
<p>让我们来改造<code>getDataOne</code>:</p>
<pre><code class="language-js">let geneator;
let getDataOne = () =&gt; {
  setTimeout(() =&gt; {
    // 调用 Generator
    // 使用 next 加参数传送数据
    generator.next(&quot;fake data one&quot;);
  }, 1000);
};
</code></pre>
<p>然而,我并不是很理解这段代码,<code>generator</code>是<code>undefined</code>,为何调用<code>next</code>.</p>
<p>2020 年 12 月 26 日 22:56:50</p>
<p>2020 年即将结束,在异步编程的问题上让我们拥抱<code>async</code>和<code>await</code>吧.</p>
<p>终于看完了这本书,这本书非常适合我现在的水平,让我能够学习得很愉快.再次感谢,即使昨天是圣诞节我依然一个人过.</p>
<p>再会啦.</p>
]]></content:encoded>
        </item>
    </channel>
</rss>
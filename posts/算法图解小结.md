---
title: '算法图解小结(摘抄)'
date: '12/2/2021'
tags:
- 算法
mainImg: 'https://images.unsplash.com/photo-1589149098258-3e9102cd63d3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2Mzg0MzE5NjI&ixlib=rb-1.2.1&q=80&w=1080'
coverImg: 'https://images.unsplash.com/photo-1589149098258-3e9102cd63d3?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2Mzg0MzE5NjI&ixlib=rb-1.2.1&q=80&w=400'
intro: '读了算法图解这本书📚，摘抄其总结一些便于以后回顾。'
---

感谢这本书将算法基础知识讲解得非常有趣且易懂，如果你看到这里，建议买一本~[《算法图解（图灵出品）》- 京东图书](https://item.jd.com/12911513.html)!



### 算法简介

- 二分查找的速度远超简单查找
- 需要搜索的元素越多，`O(log n)`远比`O(n)`快
- 算法运行时间并不是以`秒`为单位，而是从其增速的角度考量的，并且用`大 O 表示法`来表示

### 选择排序

- 计算机内存如一大堆`抽屉`
- 需要存储多个元素时，可以使用数组或链表
- 数组的元素都在一起
- 链表的元素都是分开的，其中每一个元素都存储了下一个元素的地址
- 数组的读取速度快
- 链表的插入和删除的速度快
- 同一个数组中，所有元素的类型都必须相同

### 递归

- 递归指的是调用自己的函数
- 递归的两个必要条件：
  - 基线条件，何时终止
  - 递归条件，如何继续
- 栈的两个操作：压入和弹出
- 所有函数调用都进入调用栈
- 调用栈太长将会占用更多内存



### 快速排序

- D&C（分治算法）将问题逐步分解，使用此算法处理数组时，基线条件常常是空数组或只包含一个元素的数组
- 实现快速排序时，随机的选择用做基准值的元素，快速排序的平均运行时间是`O(nlog n)`
- 大 O 表示法中的常量有时候事关重大，这就是快速排序比合并排序快的最重要原因
- 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，`O(log n)`远远快于`O(n)`



### 散列表

- 你可以结合散列函数和数组来创建散列表
- 冲突很糟糕，选择更好的散列函数有助于减少冲突
- 散列表的查找、插入、删除的速度非常快
- 散列表适合用于模拟映射关系
- 一旦填装因子大于 0.7，就应该调整散列表长度
- 散列表可以用于缓存数据
- 散列表适合防止重复



### 广度优先搜索

- 广度优先搜索适用于检查是否有从`A`到`B`的路径，并且在存在的情况下检查出最短路径
- 面临寻找最短路径的问题时，可以`建立图模型`，再利用广度优先搜索来解决问题
- 有向图中的箭头指代方向和双边关系
- 无向图中不带箭头，双边关系是双向的
- 队列先入先出
- 栈先入后出
- 广度优先搜索列表必须是队列，否则找到的就不是最短路径
- 检查过的则无序再次检查，否则可能存在闭环



### 狄克斯特拉算法

- 广度优先搜索用于在`非加权图`中查找最短路径
- 狄克斯特拉算法用于在`加权图`中查找最短路径
- 仅当权重为`正`时，狄克斯特拉算法才有效
- 图中包含负权重，则使用`贝尔曼-福德`算法



### 贪婪算法

> 每一步都采取局部最优解，最终产生全局最优解，有时候`完美`是`优秀`的敌人。




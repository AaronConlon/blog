---
title: "动态规划浅解"
date: "12/11/2021"
tags:
  - 算法
mainImg: "https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=1080"
coverImg: "https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=400"
intro: "动态规划到底是什么玩意?"
---

### 前言

为了能通过大厂的笔试,算法这一关是必须闯的,其中动态规划可以单独拉出来学习.

### 思想

> 简而言之

动态规划的核心在于`拆`和`解`!在于`尽可能缩小可能的解的空间`!

将一个问题拆成几个子问题,求解这些子问题,把子问题的答案保存起来,最终推断出最大的问题的解.

最大的问题的`最优解`通常是某个算法问题的答案,这个最优解可以由小问题的最优解推出.

对于使用`DP`算法解决问题,需要明确以下三点:

- 设计状态
- 设计状态转移方程
- 转移状态

### 实例解析

[剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

当年校招时,我一直以为这种笔试题是脑筋急转弯,现在才知道当时有多可笑.

首先,定义一个数组保存若干台阶时有多少种跳法,数组为`dp`,跳上`i`级的台阶的跳法有`dp[i]`种.
那么最终的结果就是：`dp[n] = dp[n-1] + dp[n-2]`

这里我们就思考初始化状态是什么？显然 dp[0] = 1, dp[1] = 1

代码如下：

```js
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function (n) {
  let dp = [1, 1];
  if (n < 2) return 1;
  for (let i = 2; i <= n; i++) {
    let types = (dp[0] + dp[1]) % 1000000007;
    dp[0] = dp[1];
    dp[1] = types;
  }
  return dp[1];
};
```

初始化其状态，得出跳 2 次以下都只有 1 种方法的初始状态，然后逐步求新增的台阶直到 n 级。在上述代码中，使用固定长度的数组能节省空间，实质上依然是取最后两个选择的结果，这两个选择的结果被保存到了数组开头而已。

[62. 不同路径 - 力扣（LeetCode）](https://leetcode-cn.com/problems/unique-paths/)

首先，如何设计状态？用函数的思路来设计，那么可以用 f(i,j) 表示从左上角走到坐标 (i,j) 的总路径数。
显然，要走到最后只有两种选择：

- 从目标的上面往下
- 从目标的左边往右

那么最终的状态转移方程可得：
`f(i,j) = f(i-1, j) + f(i, j-1)`

接着，我们来初始化一些状态。根据实际题目可知，我们需要用一个二维数组来保存每一个坐标的路径总数。并且无论是第一行还是第一列，都只有一条路可走。

```js
const uniquePaths = (m, n) => {
  // 初始化二维数组
  const f = new Array(m).fill(0).map(() => new Array(n).fill(0));
  // 初始化第一行和第一列的路径总数
  for (let i = 0; i < m; i++) {
    // 第一行
    f[0][i] = 1;
  }
  for (let j = 0; j < n; j++) {
    // 第一列
    f[j][0] = 1;
  }
  // 其他位置
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      // 某坐标的路径总数可以根据此前的历史数据计算出来，最终得到 f(i, j)
      f[i][j] = f[i - 1][j] + f[i][j - 1];
    }
  }
  return f[m - 1][n - 1];
};
```

另有题：[64. 最小路径和 - 力扣（LeetCode）](https://leetcode-cn.com/problems/minimum-path-sum/)

依然是状态转移方程的设计：
`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

雷同于上一题，但这一题为每一个坐标提供了路径值，以下代码最佳：

```js
const minPathSum = (grid) => {
  const row = grid.length,
    col = grid[0].length;
  // 将初始化的数据直接写在 grid 上节省空间
  for (let i = 1; i < row; i++) {
    grid[i][0] += grid[i - 1][0];
  }
  for (let j = 1; j < col; j++) {
    grid[0][j] += grid[0][j - 1];
  }
  for (let i = 1; i < row; i++) {
    for (let j = 1; j < col; j++) {
      grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
    }
  }
  return grid[row - 1][col - 1];
};
```

首先，获取到行和列的数。由于第一行和第一列都只有一个上层选项，并且内部贴边的坐标都依赖于第一行或第一列，因此可以将数据直接更新到二维数组上，然后更新第一行和第一列某个坐标的路径值。

再来一题`Hard`难题,这道题就是[72. 编辑距离 - 力扣（LeetCode）](https://leetcode-cn.com/problems/edit-distance/).说实话,在一开始看这道题的时候我真的一点想法都没有,如果说非要有想法,那就是怀疑我自己智力不足.

这一题需要计算最少的操作数,那么可以脑补一下要用到`Math.min()`来从若干个操作中获取操作数最小的.

`接下来就是顿悟时刻`.

每一个单词都有长度,这两个长度就是`m`和`n`!
当在某个阶段想要获得最少的操作数时,就可以根据二者的动态下标,选择最佳的操作.

首先是初始化,显然无论如何当某个单词为空字符串的时候,下标会有 0 的存在,这个数组元素就等于添加若干个字母.

也就是说:
`dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i-1][j]) + 1`

当我们得知历史数据后,可以根据最小的操作去做下一步,选择最小的操作再+1.

```js
const minDistance = (word1 = 'horse', word2 = 'ros') => {
  let dp = Array.from(Array(word1.length + 1), () => Array(word2.length + 1).fill(0));
  console.log(dp);
  for (let i = 1; i <= word1.length; i++) {
    dp[i][0] = i;
  }

  for (let j = 1; j <= word2.length; j++) {
    dp[0][j] = j;
  }

  for (let i = 1; i <= word1.length; i++) {
    for (let j = 1; j <= word2.length; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
      }
    }
  }

  return dp[word1.length][word2.length];
};
```

在 LeetCode 看到一个更好的解法：

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    let n = word1.length;
    let m = word2.length;
    if(n*m === 0) return n+m;
    if(word1 === word2) return 0;
    let dp = [];
    for(let i = 0;i <= n;i++){
        dp.push([])
        for(let j = 0;j <= m;j++){
            if(i*j){
                dp[i][j] = word1[i-1] == word2[j-1]? dp[i-1][j-1]: (Math.min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1);
            }else{
                dp[i][j] = i + j;
            }
        }
    }
    return dp[n][m];
};
```

不用初始化，直接判断是否有字符长度为 0，是则返回另一个的长度。否则根据动态规划的转移方程计算出结果。

> 官方题解的评论区有一个 Python 版本的最优解，使用滚动数组压缩空间，笔者智力不足，有兴趣的可以去看看。

### 总结

其实，算法对笔者这类非天才开发者来说，需要在日常中多思考和积累，临时抱佛脚是不现实的。

---
title: "动态规划浅解"
date: "12/11/2021"
tags:
  - 算法
mainImg: "https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=1080"
coverImg: "https://images.unsplash.com/photo-1555066931-bf19f8fd1085?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8fDE2MzkyMTEzNDE&ixlib=rb-1.2.1&q=80&w=400"
intro: "动态规划到底是什么玩意?"
---

### 前言

为了能通过大厂的笔试,算法这一关是必须闯的,其中动态规划可以单独拉出来学习.

### 思想

> 简而言之

动态规划的核心在于`拆`和`解`!在于`尽可能缩小可能的解的空间`!

将一个问题拆成几个子问题,求解这些子问题,把子问题的答案保存起来,最终推断出最大的问题的解.

最大的问题的`最优解`通常是某个算法问题的答案,这个最优解可以由小问题的最优解推出.

对于使用`DP`算法解决问题,需要明确以下三点:

- 设计状态
- 设计状态转移方程
- 转移状态

### 实例解析

[剑指 Offer 10- II. 青蛙跳台阶问题 - 力扣（LeetCode）](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

当年校招时,我一直以为这种笔试题是脑筋急转弯,现在才知道当时有多可笑.

首先,定义一个数组保存若干台阶时有多少种跳法,数组为`dp`,跳上`i`级的台阶的跳法有`dp[i]`种.
那么最终的结果就是：dp[n] = dp[n-1] + dp[n-2]

这里我们就思考初始化状态是什么？显然 dp[0] = 1, dp[1] = 1

代码如下：

```js
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function (n) {
  let dp = [1, 1];
  if (n < 2) return 1;
  for (let i = 2; i <= n; i++) {
    let types = (dp[0] + dp[1]) % 1000000007;
    dp[0] = dp[1];
    dp[1] = types;
  }
  return dp[1];
};
```

初始化其状态，得出跳 2 次以下都只有 1 种方法的初始状态，然后逐步求新增的台阶直到 n 级。在上述代码中，使用固定长度的数组能节省空间，实质上依然是取最后两个选择的结果，这两个选择的结果被保存到了数组开头而已。

[62. 不同路径 - 力扣（LeetCode）](https://leetcode-cn.com/problems/unique-paths/)

首先，如何设计状态？用函数的思路来设计，那么可以用 f(i,j) 表示从左上角走到坐标 (i,j) 的总路径数。
显然，要走到最后只有两种选择：

- 从目标的上面往下
- 从目标的左边往右

那么最终的状态转移方程可得：
`f(i,j) = f(i-1, j) + f(i, j-1)`

接着，我们来初始化一些状态。根据实际题目可知，我们需要用一个二维数组来保存每一个坐标的路径总数。并且无论是第一行还是第一列，都只有一条路可走。

```js
const uniquePaths = (m, n) => {
  // 初始化二维数组
  const f = new Array(m).fill(0).map(() => new Array(n).fill(0));
  // 初始化第一行和第一列的路径总数
  for (let i = 0; i < m; i++) {
    // 第一行
    f[0][i] = 1;
  }
  for (let j = 0; j < n; j++) {
    // 第一列
    f[j][0] = 1;
  }
  // 其他位置
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      // 某坐标的路径总数可以根据此前的历史数据计算出来，最终得到 f(i, j)
      f[i][j] = f[i - 1][j] + f[i][j - 1];
    }
  }
  return f[m - 1][n - 1];
};
```

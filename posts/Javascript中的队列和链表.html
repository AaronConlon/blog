<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta name="description" content="javascript node deno linux web developer"/><meta charSet="utf-8"/><link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text y=%22.9em%22 font-size=%2290%22&gt;🎯&lt;/text&gt;&lt;/svg&gt;"/><title>Javascript中的队列和链表</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css"/><link rel="stylesheet" href="/blog/post.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-J0BNBT8YXG"></script><script><!-- Global site tag (gtag.js) - Google Analytics -->
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-J0BNBT8YXG');</script><link rel="preload" href="/blog/_next/static/css/15b7ac151cc27d0bf446.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/15b7ac151cc27d0bf446.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/59a87fe619da797e3375.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/59a87fe619da797e3375.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/blog/_next/static/chunks/main-c37f7d67026ad75148c3.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/webpack-eb080e3f091731f228fb.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.cb58dfc173e18379cc5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/6335da8543c52d3af527c387f688061357787349.aa32db8a194765817dea.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-ebdd114948c696bf4519.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/2c3b9bffc7150b37a7b3810dfcf1c0b0fac2bd18.d9c1a918e36a147107c0.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-e51ccb5d21ce0f0d298e.js" as="script"/></head><body><div id="__next"><style data-emotion-css="d6jcgn">html{line-height:1.15;-webkit-text-size-adjust:100%;}body{margin:0;}main{display:block;}h1{font-size:2em;margin:0.67em 0;}hr{box-sizing:content-box;height:0;overflow:visible;}pre{font-family:monospace,monospace;font-size:1em;}a{background-color:transparent;}abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration:underline dotted;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;}b,strong{font-weight:bolder;}code,kbd,samp{font-family:monospace,monospace;font-size:1em;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sub{bottom:-0.25em;}sup{top:-0.5em;}img{border-style:none;}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0;}button,input{overflow:visible;}button,select{text-transform:none;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}fieldset{padding:0.35em 0.75em 0.625em;}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{vertical-align:baseline;}textarea{overflow:auto;}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none !important;}input[type="number"]{-moz-appearance:textfield;}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}[type="search"]::-webkit-search-decoration{-webkit-appearance:none !important;}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details{display:block;}summary{display:list-item;}template{display:none;}[hidden]{display:none !important;}html{box-sizing:border-box;font-family:sans-serif;}*,*::before,*::after{box-sizing:border-box;}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0;}button{background:transparent;padding:0;}fieldset{margin:0;padding:0;}ol,ul{margin:0;padding:0;}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";line-height:1.5;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;text-rendering:optimizelegibility;}hr{border-top-width:1px;}img{border-style:solid;}textarea{resize:vertical;}button,[role="button"]{cursor:pointer;}button::-moz-focus-inner{border:0 !important;}table{border-collapse:collapse;}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit;}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;}pre,code,kbd,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;}img,video{max-width:100%;height:auto;}html{line-height:1.5;color:#1A202C;}*,*::before,*::after{border-width:0;border-style:solid;border-color:#E2E8F0;}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#A0AEC0;}input::-ms-input-placeholder,textarea::-ms-input-placeholder{color:#A0AEC0;}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#A0AEC0;}input::-moz-placeholder,textarea::-moz-placeholder{color:#A0AEC0;}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#A0AEC0;}input::placeholder,textarea::placeholder{color:#A0AEC0;}</style><div><div class="layout_container__1BBI- css-0"><header><div class="css-0"><style data-emotion-css="em7ozm">.css-em7ozm{font-size:2.25rem;line-height:1.25;font-weight:700;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";text-align:center;margin:0 auto;padding:1.4rem 1rem;color:#0069d6;}@media screen and (min-width:48em){.css-em7ozm{font-size:3rem;}}</style><h1 class="css-em7ozm"><a href="/blog">妙才<style data-emotion-css="1i1myri">.css-1i1myri{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:30%;}</style><sub class="css-1i1myri">blog</sub></a></h1></div></header><main><div class="css-0"><style data-emotion-css="t9c2rr">.css-t9c2rr{width:100%;margin:0 auto;padding-bottom:2rem;max-width:960px;}</style><div class="css-t9c2rr"><style data-emotion-css="8atqhb">.css-8atqhb{width:100%;}</style><img alt="" class="css-8atqhb"/></div><style data-emotion-css="1td051d">.css-1td051d{width:100%;margin:0 auto;max-width:960px;}</style><div class="css-1td051d"><style data-emotion-css="1299f13">.css-1299f13{font-size:1.875rem;line-height:2.5rem!important;font-weight:700;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";text-align:center;overflow:hidden;}@media screen and (min-width:30em){.css-1299f13{line-height:3rem!important;}}@media screen and (min-width:48em){.css-1299f13{font-size:2.25rem;}}</style><h1 class="css-1299f13">Javascript中的队列和链表</h1><style data-emotion-css="7e9jz6">.css-7e9jz6{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:2rem;margin:0 auto;margin-right:0.4rem;float:right;}</style><div id="tags" class="css-7e9jz6"><style data-emotion-css="18h3rpj">.css-18h3rpj{display:inline-block;padding-left:8px;padding-right:0.25rem;text-transform:uppercase;font-size:0.6rem;border-radius:5px;font-weight:700;white-space:nowrap;vertical-align:middle;background-color:#c6f6d5;color:#22543d;height:2rem;line-height:2rem;min-width:4rem;margin-right:0.5rem;}</style><div class="css-18h3rpj">JavaScript</div><style data-emotion-css="qgikqf">.css-qgikqf{display:inline-block;padding-left:8px;padding-right:0.25rem;text-transform:uppercase;font-size:0.6rem;border-radius:5px;font-weight:700;white-space:nowrap;vertical-align:middle;background-color:#c6f6d5;color:#22543d;height:2rem;line-height:2rem;min-width:4rem;}</style><div class="css-qgikqf">数据结构与算法</div></div><style data-emotion-css="8ddayy">.css-8ddayy{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:2rem;max-width:100%;border-radius:0.25rem;font-weight:500;min-width:2rem;padding-left:0.75rem;padding-right:0.75rem;background-color:#c6f6d5;color:#22543d;margin-bottom:2rem;font-size:0.6rem;margin-left:0.4rem;}</style><div class="css-8ddayy">最后更新: <!-- -->2021/1/7</div><div><p>长话短说,本文将队列和链表的知识合二为一.通过一些示例再次巩固这部分的知识.大概内容分为:</p><ul><li>简单队列</li><li>双端队列</li><li>队列应用
<ul><li>击鼓传花</li><li>回文字检查</li></ul></li><li>单向链表</li><li>双向链表</li><li>循环链表</li><li><p>排序链表</p></li></ul><h1 id="">队列</h1><p>队列,先进先出.排过队吗?按顺序添加和处理的任务,都可以用<code>队列</code>的结构进行存储和消费.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class Queue {
  constructor () {
    this._items = {}
    this._count = 0
    this._lowestCount = 0
  }

  enqueue(e) {
    this._items[this._count] = e
    this._count++
  }
  dequeue() {
    if(this.isEmpty()) return undefined
    const r = this._items[this._lowestCount]
    delete this._items[this._lowestCount]
    this._lowestCount += 1
    return r
  }

  isEmpty() {
    return this._lowestCount === this._count
  }
  peek() {
    return this.isEmpty()  ? undefined : this._items[this._lowestCount]
  }

  size() {
    return this._count - this._lowestCount
  }

  clear() {
    this._items = {}
    this._count = 0
    this._lowestCount = 0
  }
  toString() {
    if(this.isEmpty()) return &#x27;&#x27;
    let r = &#x27;&#x27;
    for (const iterator of Object.values(this._items)) {
      r += r === &#x27;&#x27; ? `${iterator}` : `, ${iterator}`
    }
    return r
  }
}

let a = new Queue()
console.log(a.isEmpty())
a.enqueue(1)
a.enqueue(&#x27;just for fun&#x27;)
console.log(a.toString())
a.clear()
console.log(a.toString())</code></pre></div></div></details><p>普通队列简单,但是有些场景需要对最新入队的元素进行操作.例如,针对需要存储一系列操作的需求.此时,需要灵活处理队首和队尾的数据内容.</p><p>当引发撤销操作的时候,操作队列可以从尾部弹出最后的操作记录.</p><p>我们需要双端队列.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class Deque extends Queue{
  constructor () {
    super()
  }
  addFront(e) {
    if(this.isEmpty()) {
      this.enqueue(e)
    } else if(this._lowestCount &gt; 0) {
      this._lowestCount--      
      this._items[this._lowestCount] = e
    } else {
      for (let i = this._count;i&gt;0;i--) {
        // 往后移动一位
        this._items[i] = this._items[i - 1]
      }
      this._count++
      this._lowestCount = 0
      this._items[0] = e
    }
  }
    // 从队尾出队
  removeBack() {
    if(this.isEmpty()) return undefined
    const lastOne = this._items[this._count - 1]
    if(this.size() === 1) {
      this.clear()
    }
    delete this._items[this._count - 1]
    this._count--
    return lastOne
  }

  peekBack() {
    return this._items[this._count]
  }
}</code></pre></div></div></details><p>其他方法继承于<code>Queue</code>,可以实现双端数据操作.</p><p>现在,让我们来模拟<code>击鼓传花</code>问题.</p><style data-emotion-css="1xvrksk">.css-1xvrksk{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;padding:1.5rem;}</style><div class="css-1xvrksk"><style data-emotion-css="1v59okt">.css-1v59okt{width:42px;height:42px;padding:0.5rem;}</style><div class="css-1v59okt"><svg viewBox="0 0 36 36"><path fill="#FFAC33" d="M8.916 12.88c-.111 1.652 1.768 3.126-.712 2.959-2.48-.167-7.836-2.533-7.768-3.53s3.708-2.757 6.188-2.59c2.48.166 2.404 1.508 2.292 3.161zm20.122 16.049c-.202-.032-.392.015-.564.095-2.325.232-3.225-1.885-3.225-1.885-.439-.336-.981-2.009-1.589-1.215l.187 1.402c.187 1.402 2.57 3.224 2.57 3.224l-1.215 1.589c-.336.439-.252 1.066.187 1.402.439.336 1.066.252 1.402-.187l.673-.88-.039.249c-.087.546.285 1.058.831 1.145.546.087 1.058-.285 1.145-.831l.47-2.963c.085-.546-.287-1.058-.833-1.145zm-6.278.623c-.196-.058-.39-.037-.572.018-2.335-.082-2.944-2.3-2.944-2.3-.39-.392-.703-2.123-1.412-1.417l-.003 1.414c-.003 1.414 2.115 3.539 2.115 3.539l-1.417 1.412c-.392.39-.393 1.023-.003 1.414.39.392 1.023.393 1.414.003l.785-.782-.073.242c-.159.529.141 1.086.67 1.246.529.159 1.087-.141 1.246-.67l.862-2.873c.162-.53-.138-1.087-.668-1.246z"></path><path fill="#DD2E44" d="M35.009 6.729c-.383-.17-.758-.057-1.05.244-.054.056-4.225 6.306-14.532 4.944-.34-.045 3.139 11.968 3.199 11.962.124-.014 3.07-.368 6.14-2.553 2.818-2.005 6.284-5.991 6.797-13.598.028-.418-.171-.828-.554-.999z"></path><path fill="#DD2E44" d="M34.477 21.108c-.204-.336-.59-.56-.979-.471-1.293.295-3.197.543-4.53.453-6.357-.428-9.361-4.129-9.392-4.16-.275-.282.466 11.552.816 11.576 9.194.62 13.862-6.027 14.057-6.31.222-.326.233-.751.028-1.088z"></path><path fill="#DD2E44" d="M24.586 19.016c-.371 5.51 1.316 9.861-4.194 9.489-5.51-.371-10.145-4.92-9.774-10.431s14.34-4.568 13.968.942z"></path><path fill="#DD2E44" d="M23.257 12.412c-.353 5.235-3.922 9.257-9.156 8.904-5.235-.353-9.193-4.882-8.84-10.117.353-5.235 4.832-8.444 10.067-8.091 4.001.269 8.24 4.683 7.929 9.304z"></path><circle fill="#292F33" cx="10.67" cy="8.989" r="2"></circle><path fill="#A0041E" d="M18.179 16.645s7.63 5.648 12.387-4.459c.396-.842 1.685.793.099 4.162s-8.175 6.44-12.04 1.536c-.815-1.035-.446-1.239-.446-1.239z"></path><path fill="#DD2E44" d="M15.327 3.107s6.246.254 7.798-.477.136 2.932-3.262 3.789-4.536-3.312-4.536-3.312z"></path><path fill="#DD2E44" d="M17.428 5.788s4.501.136 6.054-.594.136 2.932-3.262 3.789c-3.399.857-2.792-3.195-2.792-3.195z"></path></svg></div><style data-emotion-css="pbmhrg">.css-pbmhrg{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background-color:#fff2f2;border-radius:8px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="css-pbmhrg"><p><em>班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。这个时候某个人（比方班长），在击鼓，鼓声停下的一刻，花落在谁手里，谁就进去表演节目</em>.</p></div></div><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">let a = new Queue();
[&#x27;杜小帅&#x27;, &#x27;高海&#x27;, &#x27;董文武&#x27;, &#x27;雪儿&#x27;, &#x27;洛克斯&#x27;, &#x27;庄杯&#x27;, &#x27;K&#x27;].forEach(i =&gt; a.enqueue(i));
let createANum =  () =&gt; Math.random().toFixed(1) * 10
function start(queue) {
  if(queue.size() === 1) {
    console.log(`现场唯一的观众: ${queue.dequeue()}`);
  } else {
    if(createANum() &gt; 7) {
      console.log(`${a.dequeue()}, 请开始你的表演.`);
    } else {
      queue.enqueue(queue.dequeue())
    }
  }
}
while(a.size() &gt;= 1) {
  start(a)
}

// output
// 庄杯, 请开始你的表演.
// 董文武, 请开始你的表演.
// 高海, 请开始你的表演.
// 杜小帅, 请开始你的表演.
// 我, 请开始你的表演.
// 洛克斯, 请开始你的表演.
// 现场唯一的观众: 雪儿</code></pre></div></div></details><p>接下来是回文检查,什么是回文字?</p><div class="css-1xvrksk"><div class="css-1v59okt"><svg viewBox="0 0 36 36"><path fill="#FFAC33" d="M8.916 12.88c-.111 1.652 1.768 3.126-.712 2.959-2.48-.167-7.836-2.533-7.768-3.53s3.708-2.757 6.188-2.59c2.48.166 2.404 1.508 2.292 3.161zm20.122 16.049c-.202-.032-.392.015-.564.095-2.325.232-3.225-1.885-3.225-1.885-.439-.336-.981-2.009-1.589-1.215l.187 1.402c.187 1.402 2.57 3.224 2.57 3.224l-1.215 1.589c-.336.439-.252 1.066.187 1.402.439.336 1.066.252 1.402-.187l.673-.88-.039.249c-.087.546.285 1.058.831 1.145.546.087 1.058-.285 1.145-.831l.47-2.963c.085-.546-.287-1.058-.833-1.145zm-6.278.623c-.196-.058-.39-.037-.572.018-2.335-.082-2.944-2.3-2.944-2.3-.39-.392-.703-2.123-1.412-1.417l-.003 1.414c-.003 1.414 2.115 3.539 2.115 3.539l-1.417 1.412c-.392.39-.393 1.023-.003 1.414.39.392 1.023.393 1.414.003l.785-.782-.073.242c-.159.529.141 1.086.67 1.246.529.159 1.087-.141 1.246-.67l.862-2.873c.162-.53-.138-1.087-.668-1.246z"></path><path fill="#DD2E44" d="M35.009 6.729c-.383-.17-.758-.057-1.05.244-.054.056-4.225 6.306-14.532 4.944-.34-.045 3.139 11.968 3.199 11.962.124-.014 3.07-.368 6.14-2.553 2.818-2.005 6.284-5.991 6.797-13.598.028-.418-.171-.828-.554-.999z"></path><path fill="#DD2E44" d="M34.477 21.108c-.204-.336-.59-.56-.979-.471-1.293.295-3.197.543-4.53.453-6.357-.428-9.361-4.129-9.392-4.16-.275-.282.466 11.552.816 11.576 9.194.62 13.862-6.027 14.057-6.31.222-.326.233-.751.028-1.088z"></path><path fill="#DD2E44" d="M24.586 19.016c-.371 5.51 1.316 9.861-4.194 9.489-5.51-.371-10.145-4.92-9.774-10.431s14.34-4.568 13.968.942z"></path><path fill="#DD2E44" d="M23.257 12.412c-.353 5.235-3.922 9.257-9.156 8.904-5.235-.353-9.193-4.882-8.84-10.117.353-5.235 4.832-8.444 10.067-8.091 4.001.269 8.24 4.683 7.929 9.304z"></path><circle fill="#292F33" cx="10.67" cy="8.989" r="2"></circle><path fill="#A0041E" d="M18.179 16.645s7.63 5.648 12.387-4.459c.396-.842 1.685.793.099 4.162s-8.175 6.44-12.04 1.536c-.815-1.035-.446-1.239-.446-1.239z"></path><path fill="#DD2E44" d="M15.327 3.107s6.246.254 7.798-.477.136 2.932-3.262 3.789-4.536-3.312-4.536-3.312z"></path><path fill="#DD2E44" d="M17.428 5.788s4.501.136 6.054-.594.136 2.932-3.262 3.789c-3.399.857-2.792-3.195-2.792-3.195z"></path></svg></div><div class="css-pbmhrg"><p>回文是指正反序都相等的字符串序列,例如 <code>lol</code>,<code>madam</code>等等.</p></div></div><p>最简单的方式就是使用双端队列来处理这个问题.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">function palindromeCheaker(str) {
  if(str === undefined || str === &#x27;&#x27; || str === null) return false;
  const deque = new Deque();
  [...str].forEach(i =&gt; deque.enqueue(i));
  while(deque.size() &gt; 1) {
    if(deque.removeBack() !== deque.dequeue()) return false
  }
  return true
}

console.log(palindromeCheaker(&#x27;121&#x27;), palindromeCheaker(&#x27;madam&#x27;), palindromeCheaker(&#x27;jay&#x27;))
// output
// true, true, false</code></pre></div></div></details><p>JavaScript 任务也使用了队列这种数据结构.详情可以看看:</p><p><a href="https://zhuanlan.zhihu.com/p/33058983">详解JavaScript中的Event Loop（事件循环）机制 - 知乎</a></p><h1 id="">链表</h1><p>存储多个元素,数组可能是最常用的数据结构,如果需要从起点或者中间插入元素,数组的操作成本很高.尽管<code>JavaScript</code>数组支持了一些方法来做这些事,但是背后的情况同样如此.</p><div class="css-1xvrksk"><div class="css-1v59okt"><svg viewBox="0 0 36 36"><path fill="#FFAC33" d="M8.916 12.88c-.111 1.652 1.768 3.126-.712 2.959-2.48-.167-7.836-2.533-7.768-3.53s3.708-2.757 6.188-2.59c2.48.166 2.404 1.508 2.292 3.161zm20.122 16.049c-.202-.032-.392.015-.564.095-2.325.232-3.225-1.885-3.225-1.885-.439-.336-.981-2.009-1.589-1.215l.187 1.402c.187 1.402 2.57 3.224 2.57 3.224l-1.215 1.589c-.336.439-.252 1.066.187 1.402.439.336 1.066.252 1.402-.187l.673-.88-.039.249c-.087.546.285 1.058.831 1.145.546.087 1.058-.285 1.145-.831l.47-2.963c.085-.546-.287-1.058-.833-1.145zm-6.278.623c-.196-.058-.39-.037-.572.018-2.335-.082-2.944-2.3-2.944-2.3-.39-.392-.703-2.123-1.412-1.417l-.003 1.414c-.003 1.414 2.115 3.539 2.115 3.539l-1.417 1.412c-.392.39-.393 1.023-.003 1.414.39.392 1.023.393 1.414.003l.785-.782-.073.242c-.159.529.141 1.086.67 1.246.529.159 1.087-.141 1.246-.67l.862-2.873c.162-.53-.138-1.087-.668-1.246z"></path><path fill="#DD2E44" d="M35.009 6.729c-.383-.17-.758-.057-1.05.244-.054.056-4.225 6.306-14.532 4.944-.34-.045 3.139 11.968 3.199 11.962.124-.014 3.07-.368 6.14-2.553 2.818-2.005 6.284-5.991 6.797-13.598.028-.418-.171-.828-.554-.999z"></path><path fill="#DD2E44" d="M34.477 21.108c-.204-.336-.59-.56-.979-.471-1.293.295-3.197.543-4.53.453-6.357-.428-9.361-4.129-9.392-4.16-.275-.282.466 11.552.816 11.576 9.194.62 13.862-6.027 14.057-6.31.222-.326.233-.751.028-1.088z"></path><path fill="#DD2E44" d="M24.586 19.016c-.371 5.51 1.316 9.861-4.194 9.489-5.51-.371-10.145-4.92-9.774-10.431s14.34-4.568 13.968.942z"></path><path fill="#DD2E44" d="M23.257 12.412c-.353 5.235-3.922 9.257-9.156 8.904-5.235-.353-9.193-4.882-8.84-10.117.353-5.235 4.832-8.444 10.067-8.091 4.001.269 8.24 4.683 7.929 9.304z"></path><circle fill="#292F33" cx="10.67" cy="8.989" r="2"></circle><path fill="#A0041E" d="M18.179 16.645s7.63 5.648 12.387-4.459c.396-.842 1.685.793.099 4.162s-8.175 6.44-12.04 1.536c-.815-1.035-.446-1.239-.446-1.239z"></path><path fill="#DD2E44" d="M15.327 3.107s6.246.254 7.798-.477.136 2.932-3.262 3.789-4.536-3.312-4.536-3.312z"></path><path fill="#DD2E44" d="M17.428 5.788s4.501.136 6.054-.594.136 2.932-3.262 3.789c-3.399.857-2.792-3.195-2.792-3.195z"></path></svg></div><div class="css-pbmhrg"><p>数组的元素在内存中是连续的,链表则可以是不连续的,链表的关键是使用节点的属性保存下一个或者上一个链表的信息.</p></div></div><p>相比于传统数组,链表添加或者移除一个元素不需要移动其他元素,大大降低了内存成本.</p><p><img src="https://pic2.zhimg.com/v2-8158f5bef33b4d38c0ff43d11139a003_1440w.jpg?source=172ae18b"/></p><p>上图是从网上随便找的示意图.观察可以发现,如果要找到某个节点,需要从<code>head</code>一路往下查找.让我们来实现这一数据结构.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class LinkedList {
  constructor() {
    this.count = 0;
    this.head = undefined;
  }

  push(e) {
    const element = new Node(e)
    this.count++
    if (this.head === undefined) {
      this.head = element
    } else {
      let current = this.head
      while (current.next) {
        current = current.next
      }
      current.next = element
    }
  }
  /**
   * 
   * @param {number} index 返回删除节点的 element
   */
  removeAt(index) {
    if (index &gt;= 0 &amp;&amp; index &lt; this.count) {
      let current = this.head
      if (index == 0) {
        this.head = current.next
      } else {
        let prev = this.getElementByIndex(index - 1)
        current = prev.next
        prev.next = current.next
      }
      this.count--
      return current.element
    } else {
      return undefined
    }
  }

  removeValue(element) {
    const index = this.indexOf(element)
    return this.removeAt(index)
  }

  getElementByIndex(index) {
    if (index &gt;= 0 &amp;&amp; index &lt; this.count) {
      let node = this.head
      for (let i = 0; i &lt; index &amp;&amp; node !== null; i++) {
        node = node.next
      }
      return node
    } else {
      return undefined
    }
  }

  insert(element, index) {
    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {
      const node = new Node(element)
      if (this.count === 0) {
        this.head = node
      } else {
        let prev = this.getElementByIndex(index - 1)
        node.next = prev.next
        prev.next = node
      }
      this.count++
    } else {
      return false
    }
  }

  /**
   * 
   * @param {any} element search a element, return a index
   */
  indexOf(element) {
    let current = this.head
    let index = 0
    while (current) {
      if (current.element !== element) {
        current = current.next
        index++
      } else {
        return index
      }
    }
    return -1
  }

  isEmpty() {
    return this.count === 0
  }

  size() {
    return this.count
  }

  getHead() {
    return this.head
  }

  toString() {
    if (this.count === 0) {
      return &#x27;&#x27;
    }
    let current = this.head
    while (current.next !== undefined) {
      console.log(current.element);
      current = current.next
    }
    console.log(current.element);
  }
}

class Node {
  constructor(element) {
    this.element = element;
    this.next = undefined;
  }
}</code></pre></div></div></details><p>来思考一个算法题目,翻转链表:</p><div class="css-1xvrksk"><div class="css-1v59okt"><svg viewBox="0 0 36 36"><path fill="#FFAC33" d="M8.916 12.88c-.111 1.652 1.768 3.126-.712 2.959-2.48-.167-7.836-2.533-7.768-3.53s3.708-2.757 6.188-2.59c2.48.166 2.404 1.508 2.292 3.161zm20.122 16.049c-.202-.032-.392.015-.564.095-2.325.232-3.225-1.885-3.225-1.885-.439-.336-.981-2.009-1.589-1.215l.187 1.402c.187 1.402 2.57 3.224 2.57 3.224l-1.215 1.589c-.336.439-.252 1.066.187 1.402.439.336 1.066.252 1.402-.187l.673-.88-.039.249c-.087.546.285 1.058.831 1.145.546.087 1.058-.285 1.145-.831l.47-2.963c.085-.546-.287-1.058-.833-1.145zm-6.278.623c-.196-.058-.39-.037-.572.018-2.335-.082-2.944-2.3-2.944-2.3-.39-.392-.703-2.123-1.412-1.417l-.003 1.414c-.003 1.414 2.115 3.539 2.115 3.539l-1.417 1.412c-.392.39-.393 1.023-.003 1.414.39.392 1.023.393 1.414.003l.785-.782-.073.242c-.159.529.141 1.086.67 1.246.529.159 1.087-.141 1.246-.67l.862-2.873c.162-.53-.138-1.087-.668-1.246z"></path><path fill="#DD2E44" d="M35.009 6.729c-.383-.17-.758-.057-1.05.244-.054.056-4.225 6.306-14.532 4.944-.34-.045 3.139 11.968 3.199 11.962.124-.014 3.07-.368 6.14-2.553 2.818-2.005 6.284-5.991 6.797-13.598.028-.418-.171-.828-.554-.999z"></path><path fill="#DD2E44" d="M34.477 21.108c-.204-.336-.59-.56-.979-.471-1.293.295-3.197.543-4.53.453-6.357-.428-9.361-4.129-9.392-4.16-.275-.282.466 11.552.816 11.576 9.194.62 13.862-6.027 14.057-6.31.222-.326.233-.751.028-1.088z"></path><path fill="#DD2E44" d="M24.586 19.016c-.371 5.51 1.316 9.861-4.194 9.489-5.51-.371-10.145-4.92-9.774-10.431s14.34-4.568 13.968.942z"></path><path fill="#DD2E44" d="M23.257 12.412c-.353 5.235-3.922 9.257-9.156 8.904-5.235-.353-9.193-4.882-8.84-10.117.353-5.235 4.832-8.444 10.067-8.091 4.001.269 8.24 4.683 7.929 9.304z"></path><circle fill="#292F33" cx="10.67" cy="8.989" r="2"></circle><path fill="#A0041E" d="M18.179 16.645s7.63 5.648 12.387-4.459c.396-.842 1.685.793.099 4.162s-8.175 6.44-12.04 1.536c-.815-1.035-.446-1.239-.446-1.239z"></path><path fill="#DD2E44" d="M15.327 3.107s6.246.254 7.798-.477.136 2.932-3.262 3.789-4.536-3.312-4.536-3.312z"></path><path fill="#DD2E44" d="M17.428 5.788s4.501.136 6.054-.594.136 2.932-3.262 3.789c-3.399.857-2.792-3.195-2.792-3.195z"></path></svg></div><div class="css-pbmhrg"><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></div></div><p>直接翻转指针,可以避免多余的链表创建和内存占用.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">// data is a LinkedList
function reverseLinkList(data) {
  if (data.size() &gt; 1) {
    let current = data.head
    let prev = undefined
    let next = undefined
    while (current !== undefined) {
      next = current.next;
      current.next = prev;
      prev = current
      current = next
    }
    data.head = prev
    return data
  } else {
    return data
  }
}</code></pre></div></div></details><p>接着,看看<code>双向链表</code>:</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class DoublyNode extends Node {
  constructor(element, prev = undefined, next = undefined) {
    super(element, next)
    this.prev = prev;
  }
}

class DoublyLinkedList extends LinkedList {
  constructor() {
    super()
    this.tail = undefined;
  }
  push(element) {
    const node = new DoublyNode(element)
    if (this.count === 0) {
      this.head = node
      this.tail = node
    } else {
      let current = this.head
      while (current.next) {
        current = current.next
      }
      current.next = node
      node.prev = current
    }
    this.tail = node
    this.count++
  }
  insert(element, index) {
    const node = new DoublyNode(element)
    if (index &gt;= 0 &amp;&amp; index &lt;= this.count) {
      if (this.count === 0) {
        this.head = node
        this.tail = node
      } else {
        let oldNode = this.getElementByIndex(index)
        console.log(oldNode.element, &#x27;is old node&#x27;);
        // 新插入节点设置了前后节点
        node.next = oldNode
        node.prev = oldNode.prev
        // 旧的节点设置了 prev
        oldNode.prev = node
        if (node.prev) {
          // 如果前节点存在
          node.prev.next = node
        } else {
          // 不存在则说明插入的是链表头
          this.head = node
        }
      }
      this.count++
      return true
    }
    return false
  }
  getTail() {
    return this.tail
  }
  /**
   * 
   * @param {number} index 1. 链表长为 1
   * 2. 长不为 1 =&gt; 1.删除首个元素/ 2.删除最后元素 / 3.删除中间元素
   */
  removeAt(index) {
    const node = this.getElementByIndex(index)
    // 空链表和无效 index
    if (this.count === 0 &amp;&amp; node === undefined) return undefined

    // 链长 1,删除 1
    if (this.count === 1 &amp;&amp; node === this.head) {
      this.head = undefined
      this.tail = undefined
      this.count = 0
      return node
    }
    // 链长不为 1
    // index 对应的 node 有效
    if (node === this.head) {
      this.head = node.next
    } else if (node === this.tail) {
      node.prev.next = undefined
      this.tail = node.prev
    } else {
      node.prev.next = node.next
      node.next.prev = node.prev
    }
    this.count--
    return node
  }
}</code></pre></div></div></details><p>双向链表增加了<code>tail</code>属性,保存了链表尾部元素,且对每个节点的结构,增加了<code>prev</code>属性保存前一个节点信息.</p><p>下面看看<code>双向循环链表</code>,其跟双向链表的区别在于,对首个元素的<code>prev</code>设置为最后一个元素.最后一个元素的<code>next</code>设置为首个元素.因此,需要稍微调整代码结构.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class LoopDoublyLinkedList extends DoublyLinkedList {
  constructor() {
    super()
  }
  push(element) {
    const node = new DoublyNode(element)
    if (this.count === 0) {
      this.head = node
      this.tail = node
      node.prev = node
      node.next = node
    } else {
      // 新节点的头和尾部改一下
      node.next = this.head
      node.prev = this.tail
      this.tail.next = node
      this.head.prev = node
      this.tail = node
    }
    this.count++
  }

  removeAt(index) {
    const node = this.getElementByIndex(index)
    if (node) {
      if (this.count === 1) {
        this.clear()
      } else {
        let prev = node.prev
        let next = node.next
        prev.next = next
        next.prev = prev
        this.count--
      }
      return node
    } else {
      return undefined
    }
  }
  insert(element, index) {
    const node = new DoublyNode(element)
    let targetNode = this.getElementByIndex(index)
    if (targetNode === undefined) return false

    // 确定了插入位置
    if (index === 0) {
      // 插入表头
      node.next = this.head.next
      node.prev = this.tail
      this.head.prev = node
      this.head = node
      this.tail.next = node
    } else {
      node.prev = targetNode.prev
      node.next = targetNode
      targetNode.prev.next = node
      targetNode.prev = node
    }
    this.count++
  }
  clear() {
    this.head = undefined
    this.tail = undefined
    this.count = 0
  }

  toString() {
    if (this.count === 0) return &#x27;&#x27;
    let current = this.head
    // console.log(current.element);
    // console.log(current.next, this.head);
    while (current !== this.tail) {
      console.log(current.element);
      current = current.next
    }
    console.log(current.element);
  }
}</code></pre></div></div></details><p>双向循环链表的关键在于处理新节点的<code>prev</code>和<code>next</code>值,只要不是<code>空</code>链表,则每一个节点都有这两个值.</p><p>接下来是<code>有序链表</code>.为了让节点之间保持顺序,我们可以修改<code>insert</code>方法,让插入的位置由内部计算得出.</p><details open=""><summary class="Code_summary__2YXsZ">Details</summary><div class="Code_container__2ip2n"><div class="Code_header__6pHWW"><div class="CopyCode_normal__JylQA"><div style="cursor:pointer"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" width="15" height="15"><path d="M11 1.5h2.5v12a1 1 0 01-1 1h-10a1 1 0 01-1-1v-12H4m.5-1h6v2a1 1 0 01-1 1h-4a1 1 0 01-1-1v-2z" stroke="currentColor"></path></svg></div></div></div><div class="Code_code_area__GjtJr"><div class="Code_line_num__3uYIf"><ul></ul></div><pre class="Code_code__1ValO"><code class="lang-js">class SortedLinkedList extends LinkedList {
  constructor() {
    super()
  }
  insert(element, index=0) {
    if(this.isEmpty()) {
      return super.insert(element, 0)
    }
    // 自定义方法定义插入位置,用默认 index 代替 index 的效果.
    const pos = this.getIndexNextSortedElement(element);
    return super.insert(element, pos)
  }
  
  getIndexNextSortedElement(element) {
    let current = this.head;
    let i = 0;
    // 遍历,直接判断大小,也可以重新定义一个比较函数
    for(;i &lt; this.size() &amp;&amp; current; i++) {
      if(current.element &lt; element) {
        return i
      }
      current = current.next
    }
    return i
  }
}</code></pre></div></div></details><p>其他方法都是继承的,不需要改变.由于插入的位置程序内部通过特定的比较算法去判断,因此实现了链表的有序性.</p><p>在操作和查找一个有序的链表的场景之下,可以使用不同的查找算法提高查找效率.</p><div class="css-1xvrksk"><div class="css-1v59okt"><svg viewBox="0 0 36 36"><path fill="#FFAC33" d="M8.916 12.88c-.111 1.652 1.768 3.126-.712 2.959-2.48-.167-7.836-2.533-7.768-3.53s3.708-2.757 6.188-2.59c2.48.166 2.404 1.508 2.292 3.161zm20.122 16.049c-.202-.032-.392.015-.564.095-2.325.232-3.225-1.885-3.225-1.885-.439-.336-.981-2.009-1.589-1.215l.187 1.402c.187 1.402 2.57 3.224 2.57 3.224l-1.215 1.589c-.336.439-.252 1.066.187 1.402.439.336 1.066.252 1.402-.187l.673-.88-.039.249c-.087.546.285 1.058.831 1.145.546.087 1.058-.285 1.145-.831l.47-2.963c.085-.546-.287-1.058-.833-1.145zm-6.278.623c-.196-.058-.39-.037-.572.018-2.335-.082-2.944-2.3-2.944-2.3-.39-.392-.703-2.123-1.412-1.417l-.003 1.414c-.003 1.414 2.115 3.539 2.115 3.539l-1.417 1.412c-.392.39-.393 1.023-.003 1.414.39.392 1.023.393 1.414.003l.785-.782-.073.242c-.159.529.141 1.086.67 1.246.529.159 1.087-.141 1.246-.67l.862-2.873c.162-.53-.138-1.087-.668-1.246z"></path><path fill="#DD2E44" d="M35.009 6.729c-.383-.17-.758-.057-1.05.244-.054.056-4.225 6.306-14.532 4.944-.34-.045 3.139 11.968 3.199 11.962.124-.014 3.07-.368 6.14-2.553 2.818-2.005 6.284-5.991 6.797-13.598.028-.418-.171-.828-.554-.999z"></path><path fill="#DD2E44" d="M34.477 21.108c-.204-.336-.59-.56-.979-.471-1.293.295-3.197.543-4.53.453-6.357-.428-9.361-4.129-9.392-4.16-.275-.282.466 11.552.816 11.576 9.194.62 13.862-6.027 14.057-6.31.222-.326.233-.751.028-1.088z"></path><path fill="#DD2E44" d="M24.586 19.016c-.371 5.51 1.316 9.861-4.194 9.489-5.51-.371-10.145-4.92-9.774-10.431s14.34-4.568 13.968.942z"></path><path fill="#DD2E44" d="M23.257 12.412c-.353 5.235-3.922 9.257-9.156 8.904-5.235-.353-9.193-4.882-8.84-10.117.353-5.235 4.832-8.444 10.067-8.091 4.001.269 8.24 4.683 7.929 9.304z"></path><circle fill="#292F33" cx="10.67" cy="8.989" r="2"></circle><path fill="#A0041E" d="M18.179 16.645s7.63 5.648 12.387-4.459c.396-.842 1.685.793.099 4.162s-8.175 6.44-12.04 1.536c-.815-1.035-.446-1.239-.446-1.239z"></path><path fill="#DD2E44" d="M15.327 3.107s6.246.254 7.798-.477.136 2.932-3.262 3.789-4.536-3.312-4.536-3.312z"></path><path fill="#DD2E44" d="M17.428 5.788s4.501.136 6.054-.594.136 2.932-3.262 3.789c-3.399.857-2.792-3.195-2.792-3.195z"></path></svg></div><div class="css-pbmhrg"><p>我想把这些数据结构都保存到自己的工具库中去,因此需要暂时停止下一步:集合和散列表的学习.转向 webpack5 和 babel7 ,用于创建良好的环境,支持自己保存工具库和自己的数据结构.</p><p>2021年01月13日00:27:40,晚安.</p></div></div><h1 id="">参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/52878334">数据结构与算法-链表(上) - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/52841915">数据结构与算法-链表(下) - 知乎</a></li></ul></div></div></div></main><style data-emotion-css="1fic0ux">.css-1fic0ux{border:0;opacity:0.6;border-bottom:0.0625rem solid;width:auto;margin-top:0.5rem;margin-bottom:0.5rem;border-color:inherit;}</style><hr class="css-1fic0ux"/><style data-emotion-css="1w0yaz1">.css-1w0yaz1{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;max-width:1100px;margin:0 auto;}@media screen and (min-width:30em){.css-1w0yaz1{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}@media screen and (min-width:48em){.css-1w0yaz1{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}@media screen and (min-width:62em){.css-1w0yaz1{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}</style><div class="css-1w0yaz1"><style data-emotion-css="5ez2yz">.css-5ez2yz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;max-width:440px;margin:2rem auto;}</style><div class="css-5ez2yz"><style data-emotion-css="bi78j0">.css-bi78j0{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";margin-bottom:0.5rem;}</style><p class="css-bi78j0">友链</p><style data-emotion-css="2imjyh">.css-2imjyh{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><div class="css-2imjyh"><style data-emotion-css="y9ryki">.css-y9ryki{font-size:calc(3rem / 2.5);line-height:3rem;vertical-align:top;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;border-radius:9999px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;position:relative;width:3rem;height:3rem;background-color:#A0AEC0;color:#fff;}</style><div style="cursor:pointer" class="css-y9ryki"><style data-emotion-css="uwwqev">.css-uwwqev{width:100%;height:100%;}</style><div class="css-uwwqev"><svg fill="#fff" viewBox="0 0 128 128" role="img"><g><path d="M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"></path><path d="M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"></path></g></svg></div></div></div></div><style data-emotion-css="1a1kbs3">.css-1a1kbs3{margin:2rem;text-align:center;margin-left:auto;}</style><div class="css-1a1kbs3"><p id="msg">谢谢你能看到这里!<span role="img" aria-label="emoji">🤗</span> 如果你有任何想与我讨论的内容,请给我发邮件.<span role="img" aria-label="emoji">🕊</span></p><br/><a style="text-decoration:none" href="mailto:rivenqinyy@gmail.com"><style data-emotion-css="meafa5">.css-meafa5{display:inline-block;padding-left:0.25rem;padding-right:0.25rem;text-transform:uppercase;font-size:0.75rem;border-radius:0.125rem;font-weight:700;white-space:nowrap;vertical-align:middle;background-color:#c6f6d5;color:#22543d;}</style><div class="css-meafa5">我的邮件</div><span role="img" aria-label="my email">📮</span></a><br/><br/><style data-emotion-css="1fb5c92">.css-1fb5c92{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";color:#4A5568;font-size:.7rem;}</style><p class="css-1fb5c92">妙才 © 2020. All rights reserved.</p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"Javascript中的队列和链表","content":"\n长话短说,本文将队列和链表的知识合二为一.通过一些示例再次巩固这部分的知识.大概内容分为:\n\n- 简单队列\n- 双端队列\n- 队列应用\n  - 击鼓传花\n  - 回文字检查\n- 单向链表\n- 双向链表\n- 循环链表\n- 排序链表\n\n  \n\n\n\n# 队列\n\n队列,先进先出.排过队吗?按顺序添加和处理的任务,都可以用`队列`的结构进行存储和消费.\n\n```js\nclass Queue {\n  constructor () {\n    this._items = {}\n    this._count = 0\n    this._lowestCount = 0\n  }\n\n  enqueue(e) {\n    this._items[this._count] = e\n    this._count++\n  }\n  dequeue() {\n    if(this.isEmpty()) return undefined\n    const r = this._items[this._lowestCount]\n    delete this._items[this._lowestCount]\n    this._lowestCount += 1\n    return r\n  }\n\n  isEmpty() {\n    return this._lowestCount === this._count\n  }\n  peek() {\n    return this.isEmpty()  ? undefined : this._items[this._lowestCount]\n  }\n\n  size() {\n    return this._count - this._lowestCount\n  }\n\n  clear() {\n    this._items = {}\n    this._count = 0\n    this._lowestCount = 0\n  }\n  toString() {\n    if(this.isEmpty()) return ''\n    let r = ''\n    for (const iterator of Object.values(this._items)) {\n      r += r === '' ? `${iterator}` : `, ${iterator}`\n    }\n    return r\n  }\n}\n\nlet a = new Queue()\nconsole.log(a.isEmpty())\na.enqueue(1)\na.enqueue('just for fun')\nconsole.log(a.toString())\na.clear()\nconsole.log(a.toString())\n```\n\n普通队列简单,但是有些场景需要对最新入队的元素进行操作.例如,针对需要存储一系列操作的需求.此时,需要灵活处理队首和队尾的数据内容.\n\n当引发撤销操作的时候,操作队列可以从尾部弹出最后的操作记录.\n\n我们需要双端队列.\n\n```js\nclass Deque extends Queue{\n  constructor () {\n    super()\n  }\n  addFront(e) {\n    if(this.isEmpty()) {\n      this.enqueue(e)\n    } else if(this._lowestCount \u003e 0) {\n      this._lowestCount--      \n      this._items[this._lowestCount] = e\n    } else {\n      for (let i = this._count;i\u003e0;i--) {\n        // 往后移动一位\n        this._items[i] = this._items[i - 1]\n      }\n      this._count++\n      this._lowestCount = 0\n      this._items[0] = e\n    }\n  }\n\t// 从队尾出队\n  removeBack() {\n    if(this.isEmpty()) return undefined\n    const lastOne = this._items[this._count - 1]\n    if(this.size() === 1) {\n      this.clear()\n    }\n    delete this._items[this._count - 1]\n    this._count--\n    return lastOne\n  }\n\n  peekBack() {\n    return this._items[this._count]\n  }\n}\n```\n\n其他方法继承于`Queue`,可以实现双端数据操作.\n\n现在,让我们来模拟`击鼓传花`问题.\n\n\u003e *班级中玩一个游戏，所有学生围成一圈，从某位同学手里开始向旁边的同学传一束花。这个时候某个人（比方班长），在击鼓，鼓声停下的一刻，花落在谁手里，谁就进去表演节目*.\n\n```js\nlet a = new Queue();\n['杜小帅', '高海', '董文武', '雪儿', '洛克斯', '庄杯', 'K'].forEach(i =\u003e a.enqueue(i));\nlet createANum =  () =\u003e Math.random().toFixed(1) * 10\nfunction start(queue) {\n  if(queue.size() === 1) {\n    console.log(`现场唯一的观众: ${queue.dequeue()}`);\n  } else {\n    if(createANum() \u003e 7) {\n      console.log(`${a.dequeue()}, 请开始你的表演.`);\n    } else {\n      queue.enqueue(queue.dequeue())\n    }\n  }\n}\nwhile(a.size() \u003e= 1) {\n  start(a)\n}\n\n// output\n// 庄杯, 请开始你的表演.\n// 董文武, 请开始你的表演.\n// 高海, 请开始你的表演.\n// 杜小帅, 请开始你的表演.\n// 我, 请开始你的表演.\n// 洛克斯, 请开始你的表演.\n// 现场唯一的观众: 雪儿\n```\n\n接下来是回文检查,什么是回文字?\n\n\u003e 回文是指正反序都相等的字符串序列,例如 `lol`,`madam`等等.\n\n最简单的方式就是使用双端队列来处理这个问题.\n\n```js\nfunction palindromeCheaker(str) {\n  if(str === undefined || str === '' || str === null) return false;\n  const deque = new Deque();\n  [...str].forEach(i =\u003e deque.enqueue(i));\n  while(deque.size() \u003e 1) {\n    if(deque.removeBack() !== deque.dequeue()) return false\n  }\n  return true\n}\n\nconsole.log(palindromeCheaker('121'), palindromeCheaker('madam'), palindromeCheaker('jay'))\n// output\n// true, true, false\n```\n\nJavaScript 任务也使用了队列这种数据结构.详情可以看看:\n\n[详解JavaScript中的Event Loop（事件循环）机制 - 知乎](https://zhuanlan.zhihu.com/p/33058983)\n\n\n\n# 链表\n\n存储多个元素,数组可能是最常用的数据结构,如果需要从起点或者中间插入元素,数组的操作成本很高.尽管`JavaScript`数组支持了一些方法来做这些事,但是背后的情况同样如此.\n\n\u003e 数组的元素在内存中是连续的,链表则可以是不连续的,链表的关键是使用节点的属性保存下一个或者上一个链表的信息.\n\n相比于传统数组,链表添加或者移除一个元素不需要移动其他元素,大大降低了内存成本.\n\n![](https://pic2.zhimg.com/v2-8158f5bef33b4d38c0ff43d11139a003_1440w.jpg?source=172ae18b)\n\n上图是从网上随便找的示意图.观察可以发现,如果要找到某个节点,需要从`head`一路往下查找.让我们来实现这一数据结构.\n\n```js\nclass LinkedList {\n  constructor() {\n    this.count = 0;\n    this.head = undefined;\n  }\n\n  push(e) {\n    const element = new Node(e)\n    this.count++\n    if (this.head === undefined) {\n      this.head = element\n    } else {\n      let current = this.head\n      while (current.next) {\n        current = current.next\n      }\n      current.next = element\n    }\n  }\n  /**\n   * \n   * @param {number} index 返回删除节点的 element\n   */\n  removeAt(index) {\n    if (index \u003e= 0 \u0026\u0026 index \u003c this.count) {\n      let current = this.head\n      if (index == 0) {\n        this.head = current.next\n      } else {\n        let prev = this.getElementByIndex(index - 1)\n        current = prev.next\n        prev.next = current.next\n      }\n      this.count--\n      return current.element\n    } else {\n      return undefined\n    }\n  }\n\n  removeValue(element) {\n    const index = this.indexOf(element)\n    return this.removeAt(index)\n  }\n\n  getElementByIndex(index) {\n    if (index \u003e= 0 \u0026\u0026 index \u003c this.count) {\n      let node = this.head\n      for (let i = 0; i \u003c index \u0026\u0026 node !== null; i++) {\n        node = node.next\n      }\n      return node\n    } else {\n      return undefined\n    }\n  }\n\n  insert(element, index) {\n    if (index \u003e= 0 \u0026\u0026 index \u003c= this.count) {\n      const node = new Node(element)\n      if (this.count === 0) {\n        this.head = node\n      } else {\n        let prev = this.getElementByIndex(index - 1)\n        node.next = prev.next\n        prev.next = node\n      }\n      this.count++\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * \n   * @param {any} element search a element, return a index\n   */\n  indexOf(element) {\n    let current = this.head\n    let index = 0\n    while (current) {\n      if (current.element !== element) {\n        current = current.next\n        index++\n      } else {\n        return index\n      }\n    }\n    return -1\n  }\n\n  isEmpty() {\n    return this.count === 0\n  }\n\n  size() {\n    return this.count\n  }\n\n  getHead() {\n    return this.head\n  }\n\n  toString() {\n    if (this.count === 0) {\n      return ''\n    }\n    let current = this.head\n    while (current.next !== undefined) {\n      console.log(current.element);\n      current = current.next\n    }\n    console.log(current.element);\n  }\n}\n\nclass Node {\n  constructor(element) {\n    this.element = element;\n    this.next = undefined;\n  }\n}\n```\n\n来思考一个算法题目,翻转链表:\n\n\u003e 题意：反转一个单链表。\n\u003e\n\u003e 示例: 输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL\n\u003e 输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL\n\n直接翻转指针,可以避免多余的链表创建和内存占用.\n\n```js\n// data is a LinkedList\nfunction reverseLinkList(data) {\n  if (data.size() \u003e 1) {\n    let current = data.head\n    let prev = undefined\n    let next = undefined\n    while (current !== undefined) {\n      next = current.next;\n      current.next = prev;\n      prev = current\n      current = next\n    }\n    data.head = prev\n    return data\n  } else {\n    return data\n  }\n}\n```\n\n\n\n接着,看看`双向链表`:\n\n```js\nclass DoublyNode extends Node {\n  constructor(element, prev = undefined, next = undefined) {\n    super(element, next)\n    this.prev = prev;\n  }\n}\n\nclass DoublyLinkedList extends LinkedList {\n  constructor() {\n    super()\n    this.tail = undefined;\n  }\n  push(element) {\n    const node = new DoublyNode(element)\n    if (this.count === 0) {\n      this.head = node\n      this.tail = node\n    } else {\n      let current = this.head\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n      node.prev = current\n    }\n    this.tail = node\n    this.count++\n  }\n  insert(element, index) {\n    const node = new DoublyNode(element)\n    if (index \u003e= 0 \u0026\u0026 index \u003c= this.count) {\n      if (this.count === 0) {\n        this.head = node\n        this.tail = node\n      } else {\n        let oldNode = this.getElementByIndex(index)\n        console.log(oldNode.element, 'is old node');\n        // 新插入节点设置了前后节点\n        node.next = oldNode\n        node.prev = oldNode.prev\n        // 旧的节点设置了 prev\n        oldNode.prev = node\n        if (node.prev) {\n          // 如果前节点存在\n          node.prev.next = node\n        } else {\n          // 不存在则说明插入的是链表头\n          this.head = node\n        }\n      }\n      this.count++\n      return true\n    }\n    return false\n  }\n  getTail() {\n    return this.tail\n  }\n  /**\n   * \n   * @param {number} index 1. 链表长为 1\n   * 2. 长不为 1 =\u003e 1.删除首个元素/ 2.删除最后元素 / 3.删除中间元素\n   */\n  removeAt(index) {\n    const node = this.getElementByIndex(index)\n    // 空链表和无效 index\n    if (this.count === 0 \u0026\u0026 node === undefined) return undefined\n\n    // 链长 1,删除 1\n    if (this.count === 1 \u0026\u0026 node === this.head) {\n      this.head = undefined\n      this.tail = undefined\n      this.count = 0\n      return node\n    }\n    // 链长不为 1\n    // index 对应的 node 有效\n    if (node === this.head) {\n      this.head = node.next\n    } else if (node === this.tail) {\n      node.prev.next = undefined\n      this.tail = node.prev\n    } else {\n      node.prev.next = node.next\n      node.next.prev = node.prev\n    }\n    this.count--\n    return node\n  }\n}\n```\n\n\n\n双向链表增加了`tail`属性,保存了链表尾部元素,且对每个节点的结构,增加了`prev`属性保存前一个节点信息.\n\n下面看看`双向循环链表`,其跟双向链表的区别在于,对首个元素的`prev`设置为最后一个元素.最后一个元素的`next`设置为首个元素.因此,需要稍微调整代码结构.\n\n```js\nclass LoopDoublyLinkedList extends DoublyLinkedList {\n  constructor() {\n    super()\n  }\n  push(element) {\n    const node = new DoublyNode(element)\n    if (this.count === 0) {\n      this.head = node\n      this.tail = node\n      node.prev = node\n      node.next = node\n    } else {\n      // 新节点的头和尾部改一下\n      node.next = this.head\n      node.prev = this.tail\n      this.tail.next = node\n      this.head.prev = node\n      this.tail = node\n    }\n    this.count++\n  }\n\n  removeAt(index) {\n    const node = this.getElementByIndex(index)\n    if (node) {\n      if (this.count === 1) {\n        this.clear()\n      } else {\n        let prev = node.prev\n        let next = node.next\n        prev.next = next\n        next.prev = prev\n        this.count--\n      }\n      return node\n    } else {\n      return undefined\n    }\n  }\n  insert(element, index) {\n    const node = new DoublyNode(element)\n    let targetNode = this.getElementByIndex(index)\n    if (targetNode === undefined) return false\n\n    // 确定了插入位置\n    if (index === 0) {\n      // 插入表头\n      node.next = this.head.next\n      node.prev = this.tail\n      this.head.prev = node\n      this.head = node\n      this.tail.next = node\n    } else {\n      node.prev = targetNode.prev\n      node.next = targetNode\n      targetNode.prev.next = node\n      targetNode.prev = node\n    }\n    this.count++\n  }\n  clear() {\n    this.head = undefined\n    this.tail = undefined\n    this.count = 0\n  }\n\n  toString() {\n    if (this.count === 0) return ''\n    let current = this.head\n    // console.log(current.element);\n    // console.log(current.next, this.head);\n    while (current !== this.tail) {\n      console.log(current.element);\n      current = current.next\n    }\n    console.log(current.element);\n  }\n}\n```\n\n双向循环链表的关键在于处理新节点的`prev`和`next`值,只要不是`空`链表,则每一个节点都有这两个值.\n\n接下来是`有序链表`.为了让节点之间保持顺序,我们可以修改`insert`方法,让插入的位置由内部计算得出.\n\n```js\nclass SortedLinkedList extends LinkedList {\n  constructor() {\n    super()\n  }\n  insert(element, index=0) {\n    if(this.isEmpty()) {\n      return super.insert(element, 0)\n    }\n    // 自定义方法定义插入位置,用默认 index 代替 index 的效果.\n    const pos = this.getIndexNextSortedElement(element);\n    return super.insert(element, pos)\n  }\n  \n  getIndexNextSortedElement(element) {\n    let current = this.head;\n    let i = 0;\n    // 遍历,直接判断大小,也可以重新定义一个比较函数\n    for(;i \u003c this.size() \u0026\u0026 current; i++) {\n      if(current.element \u003c element) {\n        return i\n      }\n      current = current.next\n    }\n    return i\n  }\n}\n```\n\n其他方法都是继承的,不需要改变.由于插入的位置程序内部通过特定的比较算法去判断,因此实现了链表的有序性.\n\n在操作和查找一个有序的链表的场景之下,可以使用不同的查找算法提高查找效率.\n\n\n\n\u003e 我想把这些数据结构都保存到自己的工具库中去,因此需要暂时停止下一步:集合和散列表的学习.转向 webpack5 和 babel7 ,用于创建良好的环境,支持自己保存工具库和自己的数据结构.\n\u003e\n\u003e 2021年01月13日00:27:40,晚安.\n\n\n\n# 参考\n\n- [数据结构与算法-链表(上) - 知乎](https://zhuanlan.zhihu.com/p/52878334)\n- [数据结构与算法-链表(下) - 知乎](https://zhuanlan.zhihu.com/p/52841915)\n\n","title":"Javascript中的队列和链表","date":"2021/1/7","tags":["JavaScript","数据结构与算法"],"mainImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8\u0026ixlib=rb-1.2.1\u0026q=80\u0026w=1080","coverImg":"https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=MXwxNjUyNjZ8MHwxfHJhbmRvbXx8fHx8fHx8\u0026ixlib=rb-1.2.1\u0026q=80\u0026w=400","intro":"几年前在学校使用 c++ 进行数据结构与算法的学习.学得跟屎一样,丢人现眼.前段时间在飞机上看完了队列和链表部分的内容,还是觉得需要整理一下写成文章."}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Javascript中的队列和链表"},"buildId":"lVRrrGdl7kIFQAxrKI4-h","assetPrefix":"/blog","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"name":"description","content":"javascript node deno linux web developer"}],["meta",{"charSet":"utf-8"}],["link",{"rel":"icon","href":"data:image/svg+xml,\u003csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22\u003e\u003ctext y=%22.9em%22 font-size=%2290%22\u003e🎯\u003c/text\u003e\u003c/svg\u003e"}],["title",{"children":"Javascript中的队列和链表"}],["link",{"rel":"stylesheet","href":"https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css"}],["link",{"rel":"stylesheet","href":"/blog/post.css"}],["script",{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-J0BNBT8YXG"}],["script",{"dangerouslySetInnerHTML":{"__html":"\u003c!-- Global site tag (gtag.js) - Google Analytics --\u003e\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-J0BNBT8YXG');"}}]]}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-86dac49abe0e0232b575.js"></script><script src="/blog/_next/static/chunks/main-c37f7d67026ad75148c3.js" async=""></script><script src="/blog/_next/static/chunks/webpack-eb080e3f091731f228fb.js" async=""></script><script src="/blog/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/blog/_next/static/chunks/commons.cb58dfc173e18379cc5b.js" async=""></script><script src="/blog/_next/static/chunks/6335da8543c52d3af527c387f688061357787349.aa32db8a194765817dea.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-ebdd114948c696bf4519.js" async=""></script><script src="/blog/_next/static/chunks/2c3b9bffc7150b37a7b3810dfcf1c0b0fac2bd18.d9c1a918e36a147107c0.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-e51ccb5d21ce0f0d298e.js" async=""></script><script src="/blog/_next/static/lVRrrGdl7kIFQAxrKI4-h/_buildManifest.js" async=""></script><script src="/blog/_next/static/lVRrrGdl7kIFQAxrKI4-h/_ssgManifest.js" async=""></script></body></html>